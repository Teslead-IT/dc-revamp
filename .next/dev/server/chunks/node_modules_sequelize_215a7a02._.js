module.exports = [
"[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    default: ()=>base_error_default
});
class BaseError extends Error {
    constructor(message){
        super(message);
        this.name = "SequelizeBaseError";
    }
}
var base_error_default = BaseError; //# sourceMappingURL=base-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>database_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class DatabaseError extends import_base_error.default {
    constructor(parent, options = {}){
        super(parent.message);
        __publicField(this, "parent");
        __publicField(this, "original");
        __publicField(this, "sql");
        __publicField(this, "parameters");
        var _a;
        this.name = "SequelizeDatabaseError";
        this.parent = parent;
        this.original = parent;
        this.sql = parent.sql;
        this.parameters = (_a = parent.parameters) != null ? _a : {};
        if (options.stack) {
            this.stack = options.stack;
        }
    }
}
var database_error_default = DatabaseError; //# sourceMappingURL=database-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/aggregate-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>aggregate_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class AggregateError extends import_base_error.default {
    constructor(errors){
        super();
        __publicField(this, "errors");
        this.errors = errors;
        this.name = "AggregateError";
    }
    toString() {
        const message = `AggregateError of:
${this.errors.map((error)=>error === this ? "[Circular AggregateError]" : error instanceof AggregateError ? String(error).replace(/\n$/, "").replace(/^/gm, "  ") : String(error).replace(/^/gm, "    ").substring(2)).join("\n")}
`;
        return message;
    }
}
var aggregate_error_default = AggregateError; //# sourceMappingURL=aggregate-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/association-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>association_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class AssociationError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeAssociationError";
    }
}
var association_error_default = AssociationError; //# sourceMappingURL=association-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/bulk-record-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>bulk_record_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class BulkRecordError extends import_base_error.default {
    constructor(error, record){
        super(error.message);
        __publicField(this, "errors");
        __publicField(this, "record");
        this.name = "SequelizeBulkRecordError";
        this.errors = error;
        this.record = record;
    }
}
var bulk_record_error_default = BulkRecordError; //# sourceMappingURL=bulk-record-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>connection_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class ConnectionError extends import_base_error.default {
    constructor(parent){
        super(parent ? parent.message : "");
        __publicField(this, "parent");
        __publicField(this, "original");
        this.name = "SequelizeConnectionError";
        this.parent = parent;
        this.original = parent;
    }
}
var connection_error_default = ConnectionError; //# sourceMappingURL=connection-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/eager-loading-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>eager_loading_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class EagerLoadingError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeEagerLoadingError";
    }
}
var eager_loading_error_default = EagerLoadingError; //# sourceMappingURL=eager-loading-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/empty-result-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>empty_result_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class EmptyResultError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeEmptyResultError";
    }
}
var empty_result_error_default = EmptyResultError; //# sourceMappingURL=empty-result-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/instance-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>instance_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class InstanceError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeInstanceError";
    }
}
var instance_error_default = InstanceError; //# sourceMappingURL=instance-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/optimistic-lock-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>optimistic_lock_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class OptimisticLockError extends import_base_error.default {
    constructor(options){
        options = options || {};
        options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;
        super(options.message);
        __publicField(this, "modelName");
        __publicField(this, "values");
        __publicField(this, "where");
        this.name = "SequelizeOptimisticLockError";
        this.modelName = options.modelName;
        this.values = options.values;
        this.where = options.where;
    }
}
var optimistic_lock_error_default = OptimisticLockError; //# sourceMappingURL=optimistic-lock-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/query-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>query_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class QueryError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeQueryError";
    }
}
var query_error_default = QueryError; //# sourceMappingURL=query-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/sequelize-scope-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>sequelize_scope_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
class SequelizeScopeError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeScopeError";
    }
}
var sequelize_scope_error_default = SequelizeScopeError; //# sourceMappingURL=sequelize-scope-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/validation-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    ValidationErrorItem: ()=>ValidationErrorItem,
    ValidationErrorItemOrigin: ()=>ValidationErrorItemOrigin,
    ValidationErrorItemType: ()=>ValidationErrorItemType,
    default: ()=>validation_error_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
var ValidationErrorItemType = /* @__PURE__ */ ((ValidationErrorItemType2)=>{
    ValidationErrorItemType2["notnull violation"] = "CORE";
    ValidationErrorItemType2["string violation"] = "CORE";
    ValidationErrorItemType2["unique violation"] = "DB";
    ValidationErrorItemType2["validation error"] = "FUNCTION";
    return ValidationErrorItemType2;
})(ValidationErrorItemType || {});
var ValidationErrorItemOrigin = /* @__PURE__ */ ((ValidationErrorItemOrigin2)=>{
    ValidationErrorItemOrigin2["CORE"] = "CORE";
    ValidationErrorItemOrigin2["DB"] = "DB";
    ValidationErrorItemOrigin2["FUNCTION"] = "FUNCTION";
    return ValidationErrorItemOrigin2;
})(ValidationErrorItemOrigin || {});
class ValidationErrorItem {
    constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs){
        __publicField(this, "message");
        __publicField(this, "type");
        __publicField(this, "path");
        __publicField(this, "value");
        __publicField(this, "origin");
        __publicField(this, "instance");
        __publicField(this, "validatorKey");
        __publicField(this, "validatorName");
        __publicField(this, "validatorArgs");
        this.message = message || "";
        this.type = null;
        this.path = path || null;
        this.value = value !== void 0 ? value : null;
        this.origin = null;
        this.instance = instance || null;
        this.validatorKey = validatorKey || null;
        this.validatorName = fnName || null;
        this.validatorArgs = fnArgs || [];
        if (type) {
            if (this.isValidationErrorItemOrigin(type)) {
                this.origin = type;
            } else {
                const lowercaseType = this.normalizeString(type);
                const realType = ValidationErrorItemType[lowercaseType];
                if (realType && ValidationErrorItemOrigin[realType]) {
                    this.origin = realType;
                    this.type = type;
                }
            }
        }
    }
    isValidationErrorItemOrigin(origin) {
        return ValidationErrorItemOrigin[origin] !== void 0;
    }
    normalizeString(str) {
        return str.toLowerCase().trim();
    }
    getValidatorKey(useTypeAsNS, NSSeparator) {
        const useTANS = useTypeAsNS === void 0 || !!useTypeAsNS;
        const NSSep = NSSeparator === void 0 ? "." : NSSeparator;
        const type = this.origin;
        const key = this.validatorKey || this.validatorName;
        const useNS = useTANS && type && ValidationErrorItemOrigin[type];
        if (useNS && (typeof NSSep !== "string" || !NSSep.length)) {
            throw new Error("Invalid namespace separator given, must be a non-empty string");
        }
        if (!(typeof key === "string" && key.length)) {
            return "";
        }
        return (useNS ? [
            this.origin,
            key
        ].join(NSSep) : key).toLowerCase().trim();
    }
}
__publicField(ValidationErrorItem, "TypeStringMap", ValidationErrorItemType);
__publicField(ValidationErrorItem, "Origins", ValidationErrorItemOrigin);
class ValidationError extends import_base_error.default {
    constructor(message, errors, options = {}){
        super(message);
        __publicField(this, "errors");
        this.name = "SequelizeValidationError";
        this.message = "Validation Error";
        this.errors = errors || [];
        if (message) {
            this.message = message;
        } else if (this.errors.length > 0 && this.errors[0].message) {
            this.message = this.errors.map((err)=>`${err.type || err.origin}: ${err.message}`).join(",\n");
        }
        if (options.stack) {
            this.stack = options.stack;
        }
    }
    get(path) {
        return this.errors.reduce((reduced, error)=>{
            if (error.path === path) {
                reduced.push(error);
            }
            return reduced;
        }, []);
    }
}
var validation_error_default = ValidationError; //# sourceMappingURL=validation-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/access-denied-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>access_denied_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class AccessDeniedError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeAccessDeniedError";
    }
}
var access_denied_error_default = AccessDeniedError; //# sourceMappingURL=access-denied-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>connection_acquire_timeout_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class ConnectionAcquireTimeoutError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeConnectionAcquireTimeoutError";
    }
}
var connection_acquire_timeout_error_default = ConnectionAcquireTimeoutError; //# sourceMappingURL=connection-acquire-timeout-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/connection-refused-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>connection_refused_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class ConnectionRefusedError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeConnectionRefusedError";
    }
}
var connection_refused_error_default = ConnectionRefusedError; //# sourceMappingURL=connection-refused-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>connection_timed_out_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class ConnectionTimedOutError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeConnectionTimedOutError";
    }
}
var connection_timed_out_error_default = ConnectionTimedOutError; //# sourceMappingURL=connection-timed-out-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/host-not-found-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>host_not_found_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class HostNotFoundError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeHostNotFoundError";
    }
}
var host_not_found_error_default = HostNotFoundError; //# sourceMappingURL=host-not-found-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>host_not_reachable_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class HostNotReachableError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeHostNotReachableError";
    }
}
var host_not_reachable_error_default = HostNotReachableError; //# sourceMappingURL=host-not-reachable-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/connection/invalid-connection-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>invalid_connection_error_default
});
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class InvalidConnectionError extends import_connection_error.default {
    constructor(parent){
        super(parent);
        this.name = "SequelizeInvalidConnectionError";
    }
}
var invalid_connection_error_default = InvalidConnectionError; //# sourceMappingURL=invalid-connection-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>exclusion_constraint_error_default
});
var import_database_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)"));
class ExclusionConstraintError extends import_database_error.default {
    constructor(options){
        options = options || {};
        options.parent = options.parent || {
            sql: "",
            name: "",
            message: ""
        };
        super(options.parent, {
            stack: options.stack
        });
        __publicField(this, "constraint");
        __publicField(this, "fields");
        __publicField(this, "table");
        this.name = "SequelizeExclusionConstraintError";
        this.message = options.message || options.parent.message || "";
        this.constraint = options.constraint;
        this.fields = options.fields;
        this.table = options.table;
    }
}
var exclusion_constraint_error_default = ExclusionConstraintError; //# sourceMappingURL=exclusion-constraint-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    RelationshipType: ()=>RelationshipType,
    default: ()=>foreign_key_constraint_error_default
});
var import_database_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)"));
var RelationshipType = /* @__PURE__ */ ((RelationshipType2)=>{
    RelationshipType2["parent"] = "parent";
    RelationshipType2["child"] = "child";
    return RelationshipType2;
})(RelationshipType || {});
class ForeignKeyConstraintError extends import_database_error.default {
    constructor(options){
        options = options || {};
        options.parent = options.parent || {
            sql: "",
            name: "",
            message: ""
        };
        super(options.parent, {
            stack: options.stack
        });
        __publicField(this, "table");
        __publicField(this, "fields");
        __publicField(this, "value");
        __publicField(this, "index");
        __publicField(this, "reltype");
        this.name = "SequelizeForeignKeyConstraintError";
        this.message = options.message || options.parent.message || "Database Error";
        this.fields = options.fields;
        this.table = options.table;
        this.value = options.value;
        this.index = options.index;
        this.reltype = options.reltype;
    }
}
var foreign_key_constraint_error_default = ForeignKeyConstraintError; //# sourceMappingURL=foreign-key-constraint-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/database/timeout-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    default: ()=>timeout_error_default
});
var import_database_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)"));
class TimeoutError extends import_database_error.default {
    constructor(parent, options = {}){
        super(parent, options);
        this.name = "SequelizeTimeoutError";
    }
}
var timeout_error_default = TimeoutError; //# sourceMappingURL=timeout-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/database/unknown-constraint-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>unknown_constraint_error_default
});
var import_database_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)"));
class UnknownConstraintError extends import_database_error.default {
    constructor(options){
        options = options || {};
        options.parent = options.parent || {
            sql: "",
            name: "",
            message: ""
        };
        super(options.parent, {
            stack: options.stack
        });
        __publicField(this, "constraint");
        __publicField(this, "fields");
        __publicField(this, "table");
        this.name = "SequelizeUnknownConstraintError";
        this.message = options.message || "The specified constraint does not exist";
        this.constraint = options.constraint;
        this.fields = options.fields;
        this.table = options.table;
    }
}
var unknown_constraint_error_default = UnknownConstraintError; //# sourceMappingURL=unknown-constraint-error.js.map
}),
"[project]/node_modules/sequelize/lib/errors/validation/unique-constraint-error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    default: ()=>unique_constraint_error_default
});
var import_validation_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/validation-error.js [app-route] (ecmascript)"));
class UniqueConstraintError extends import_validation_error.default {
    constructor(options){
        var _a, _b, _c;
        options = options != null ? options : {};
        options.parent = (_a = options.parent) != null ? _a : {
            sql: "",
            name: "",
            message: ""
        };
        options.message = options.message || options.parent.message || "Validation Error";
        options.errors = (_b = options.errors) != null ? _b : [];
        super(options.message, options.errors, {
            stack: options.stack
        });
        __publicField(this, "parent");
        __publicField(this, "original");
        __publicField(this, "fields");
        __publicField(this, "sql");
        this.name = "SequelizeUniqueConstraintError";
        this.fields = (_c = options.fields) != null ? _c : {};
        this.parent = options.parent;
        this.original = options.parent;
        this.sql = options.parent.sql;
    }
}
var unique_constraint_error_default = UniqueConstraintError; //# sourceMappingURL=unique-constraint-error.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/async-queue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    AsyncQueueError: ()=>AsyncQueueError,
    default: ()=>async_queue_default
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
class AsyncQueueError extends import_base_error.default {
    constructor(message){
        super(message);
        this.name = "SequelizeAsyncQueueError";
    }
}
class AsyncQueue {
    constructor(){
        __publicField(this, "previous");
        __publicField(this, "closed");
        __publicField(this, "rejectCurrent");
        this.previous = Promise.resolve();
        this.closed = false;
        this.rejectCurrent = ()=>{};
    }
    close() {
        this.closed = true;
        this.rejectCurrent(new import_connection_error.default(new AsyncQueueError("the connection was closed before this query could finish executing")));
    }
    enqueue(asyncFunction) {
        return new Promise((resolve, reject)=>{
            this.previous = this.previous.then(()=>{
                this.rejectCurrent = reject;
                if (this.closed) {
                    return reject(new import_connection_error.default(new AsyncQueueError("the connection was closed before this query could be executed")));
                }
                return asyncFunction().then(resolve, reject);
            });
        });
    }
}
var async_queue_default = AsyncQueue; //# sourceMappingURL=async-queue.js.map
}),
"[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    AccessDeniedError: ()=>import_access_denied_error.default,
    AggregateError: ()=>import_aggregate_error.default,
    AssociationError: ()=>import_association_error.default,
    AsyncQueueError: ()=>import_async_queue.AsyncQueueError,
    BaseError: ()=>import_base_error.default,
    BulkRecordError: ()=>import_bulk_record_error.default,
    ConnectionAcquireTimeoutError: ()=>import_connection_acquire_timeout_error.default,
    ConnectionError: ()=>import_connection_error.default,
    ConnectionRefusedError: ()=>import_connection_refused_error.default,
    ConnectionTimedOutError: ()=>import_connection_timed_out_error.default,
    DatabaseError: ()=>import_database_error.default,
    EagerLoadingError: ()=>import_eager_loading_error.default,
    EmptyResultError: ()=>import_empty_result_error.default,
    ExclusionConstraintError: ()=>import_exclusion_constraint_error.default,
    ForeignKeyConstraintError: ()=>import_foreign_key_constraint_error.default,
    HostNotFoundError: ()=>import_host_not_found_error.default,
    HostNotReachableError: ()=>import_host_not_reachable_error.default,
    InstanceError: ()=>import_instance_error.default,
    InvalidConnectionError: ()=>import_invalid_connection_error.default,
    OptimisticLockError: ()=>import_optimistic_lock_error.default,
    QueryError: ()=>import_query_error.default,
    SequelizeScopeError: ()=>import_sequelize_scope_error.default,
    TimeoutError: ()=>import_timeout_error.default,
    UniqueConstraintError: ()=>import_unique_constraint_error.default,
    UnknownConstraintError: ()=>import_unknown_constraint_error.default,
    ValidationError: ()=>import_validation_error.default,
    ValidationErrorItem: ()=>import_validation_error.ValidationErrorItem,
    ValidationErrorItemOrigin: ()=>import_validation_error.ValidationErrorItemOrigin,
    ValidationErrorItemType: ()=>import_validation_error.ValidationErrorItemType
});
var import_base_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/base-error.js [app-route] (ecmascript)"));
var import_database_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database-error.js [app-route] (ecmascript)"));
var import_aggregate_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/aggregate-error.js [app-route] (ecmascript)"));
var import_association_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/association-error.js [app-route] (ecmascript)"));
var import_bulk_record_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/bulk-record-error.js [app-route] (ecmascript)"));
var import_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection-error.js [app-route] (ecmascript)"));
var import_eager_loading_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/eager-loading-error.js [app-route] (ecmascript)"));
var import_empty_result_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/empty-result-error.js [app-route] (ecmascript)"));
var import_instance_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/instance-error.js [app-route] (ecmascript)"));
var import_optimistic_lock_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/optimistic-lock-error.js [app-route] (ecmascript)"));
var import_query_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/query-error.js [app-route] (ecmascript)"));
var import_sequelize_scope_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/sequelize-scope-error.js [app-route] (ecmascript)"));
var import_validation_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/validation-error.js [app-route] (ecmascript)"));
var import_access_denied_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/access-denied-error.js [app-route] (ecmascript)"));
var import_connection_acquire_timeout_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js [app-route] (ecmascript)"));
var import_connection_refused_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/connection-refused-error.js [app-route] (ecmascript)"));
var import_connection_timed_out_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js [app-route] (ecmascript)"));
var import_host_not_found_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/host-not-found-error.js [app-route] (ecmascript)"));
var import_host_not_reachable_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js [app-route] (ecmascript)"));
var import_invalid_connection_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/connection/invalid-connection-error.js [app-route] (ecmascript)"));
var import_exclusion_constraint_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js [app-route] (ecmascript)"));
var import_foreign_key_constraint_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js [app-route] (ecmascript)"));
var import_timeout_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database/timeout-error.js [app-route] (ecmascript)"));
var import_unknown_constraint_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/database/unknown-constraint-error.js [app-route] (ecmascript)"));
var import_unique_constraint_error = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/validation/unique-constraint-error.js [app-route] (ecmascript)"));
var import_async_queue = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/async-queue.js [app-route] (ecmascript)")); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/utils/validator-extras.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const validator = _.cloneDeep(__turbopack_context__.r("[project]/node_modules/validator/index.js [app-route] (ecmascript)"));
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
const extensions = {
    extend (name, fn) {
        this[name] = fn;
        return this;
    },
    notEmpty (str) {
        return !str.match(/^[\s\t\r\n]*$/);
    },
    len (str, min, max) {
        return this.isLength(str, min, max);
    },
    isUrl (str) {
        return this.isURL(str);
    },
    isIPv6 (str) {
        return this.isIP(str, 6);
    },
    isIPv4 (str) {
        return this.isIP(str, 4);
    },
    notIn (str, values) {
        return !this.isIn(str, values);
    },
    regex (str, pattern, modifiers) {
        str += "";
        if (Object.prototype.toString.call(pattern).slice(8, -1) !== "RegExp") {
            pattern = new RegExp(pattern, modifiers);
        }
        return str.match(pattern);
    },
    notRegex (str, pattern, modifiers) {
        return !this.regex(str, pattern, modifiers);
    },
    isDecimal (str) {
        return str !== "" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);
    },
    min (str, val) {
        const number = parseFloat(str);
        return isNaN(number) || number >= val;
    },
    max (str, val) {
        const number = parseFloat(str);
        return isNaN(number) || number <= val;
    },
    not (str, pattern, modifiers) {
        return this.notRegex(str, pattern, modifiers);
    },
    contains (str, elem) {
        return !!elem && str.includes(elem);
    },
    notContains (str, elem) {
        return !this.contains(str, elem);
    },
    is (str, pattern, modifiers) {
        return this.regex(str, pattern, modifiers);
    }
};
exports.extensions = extensions;
validator.isImmutable = function(value, validatorArgs, field, modelInstance) {
    return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];
};
validator.notNull = function(val) {
    return val !== null && val !== void 0;
};
_.forEach(extensions, (extend, key)=>{
    validator[key] = extend;
});
validator.isNull = validator.isEmpty;
validator.isDate = function(dateString) {
    const parsed = Date.parse(dateString);
    if (isNaN(parsed)) {
        return false;
    }
    const date = new Date(parsed);
    return moment(date.toISOString()).isValid();
};
exports.validator = validator; //# sourceMappingURL=validator-extras.js.map
}),
"[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    Logger: ()=>Logger,
    logger: ()=>logger
});
var import_debug = __toModule(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
var import_util = __toModule(__turbopack_context__.r("[externals]/util [external] (util, cjs)"));
class Logger {
    constructor(_a = {}){
        __publicField(this, "config");
        var _b = _a, { context = "sequelize" } = _b, rest = __objRest(_b, [
            "context"
        ]);
        this.config = __spreadValues({
            context
        }, rest);
    }
    warn(message) {
        console.warn(`(${this.config.context}) Warning: ${message}`);
    }
    inspect(value) {
        return import_util.default.inspect(value, {
            showHidden: false,
            depth: 1
        });
    }
    debugContext(name) {
        return (0, import_debug.default)(`${this.config.context}:${name}`);
    }
}
const logger = new Logger(); //# sourceMappingURL=logger.js.map
}),
"[project]/node_modules/sequelize/lib/utils/class-to-invokable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    classToInvokable: ()=>classToInvokable
});
function classToInvokable(Class) {
    return new Proxy(Class, {
        apply (_target, _thisArg, args) {
            return new Class(...args);
        },
        construct (_target, args) {
            return new Class(...args);
        }
    });
} //# sourceMappingURL=class-to-invokable.js.map
}),
"[project]/node_modules/sequelize/lib/utils/join-sql-fragments.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
__export(exports, {
    JoinSQLFragmentsError: ()=>JoinSQLFragmentsError,
    joinSQLFragments: ()=>joinSQLFragments
});
function doesNotWantLeadingSpace(str) {
    return /^[;,)]/.test(str);
}
function doesNotWantTrailingSpace(str) {
    return /\($/.test(str);
}
function singleSpaceJoinHelper(parts) {
    return parts.reduce(({ skipNextLeadingSpace, result }, part)=>{
        if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {
            result += part.trim();
        } else {
            result += ` ${part.trim()}`;
        }
        return {
            skipNextLeadingSpace: doesNotWantTrailingSpace(part),
            result
        };
    }, {
        skipNextLeadingSpace: true,
        result: ""
    }).result;
}
function joinSQLFragments(array) {
    if (array.length === 0) return "";
    const truthyArray = array.filter((x)=>!!x);
    const flattenedArray = truthyArray.map((fragment)=>{
        if (Array.isArray(fragment)) {
            return joinSQLFragments(fragment);
        }
        return fragment;
    });
    for (const fragment of flattenedArray){
        if (fragment && typeof fragment !== "string") {
            throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);
        }
    }
    const trimmedArray = flattenedArray.map((x)=>x.trim());
    const nonEmptyStringArray = trimmedArray.filter((x)=>x !== "");
    return singleSpaceJoinHelper(nonEmptyStringArray);
}
class JoinSQLFragmentsError extends TypeError {
    constructor(args, fragment, message){
        super(message);
        __publicField(this, "args");
        __publicField(this, "fragment");
        this.args = args;
        this.fragment = fragment;
        this.name = "JoinSQLFragmentsError";
    }
} //# sourceMappingURL=join-sql-fragments.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/hstore.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const hstore = __turbopack_context__.r("[project]/node_modules/pg-hstore/lib/index.js [app-route] (ecmascript)")({
    sanitize: true
});
function stringify(data) {
    if (data === null) return null;
    return hstore.stringify(data);
}
exports.stringify = stringify;
function parse(value) {
    if (value === null) return null;
    return hstore.parse(value);
}
exports.parse = parse; //# sourceMappingURL=hstore.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
function stringifyRangeBound(bound) {
    if (bound === null) {
        return "";
    }
    if (bound === Infinity || bound === -Infinity) {
        return bound.toString().toLowerCase();
    }
    return JSON.stringify(bound);
}
function parseRangeBound(bound, parseType) {
    if (!bound) {
        return null;
    }
    if (bound === "infinity") {
        return Infinity;
    }
    if (bound === "-infinity") {
        return -Infinity;
    }
    return parseType(bound);
}
function stringify(data) {
    if (data === null) return null;
    if (!Array.isArray(data)) throw new Error("range must be an array");
    if (!data.length) return "empty";
    if (data.length !== 2) throw new Error("range array length must be 0 (empty) or 2 (lower and upper bounds)");
    if (Object.prototype.hasOwnProperty.call(data, "inclusive")) {
        if (data.inclusive === false) data.inclusive = [
            false,
            false
        ];
        else if (!data.inclusive) data.inclusive = [
            true,
            false
        ];
        else if (data.inclusive === true) data.inclusive = [
            true,
            true
        ];
    } else {
        data.inclusive = [
            true,
            false
        ];
    }
    _.each(data, (value, index)=>{
        if (_.isObject(value)) {
            if (Object.prototype.hasOwnProperty.call(value, "inclusive")) data.inclusive[index] = !!value.inclusive;
            if (Object.prototype.hasOwnProperty.call(value, "value")) data[index] = value.value;
        }
    });
    const lowerBound = stringifyRangeBound(data[0]);
    const upperBound = stringifyRangeBound(data[1]);
    return `${(data.inclusive[0] ? "[" : "(") + lowerBound},${upperBound}${data.inclusive[1] ? "]" : ")"}`;
}
exports.stringify = stringify;
function parse(value, parser) {
    if (value === null) return null;
    if (value === "empty") {
        return [];
    }
    let result = value.substring(1, value.length - 1).split(",", 2);
    if (result.length !== 2) return value;
    result = result.map((item, index)=>{
        return {
            value: parseRangeBound(item, parser),
            inclusive: index === 0 ? value[0] === "[" : value[value.length - 1] === "]"
        };
    });
    return result;
}
exports.parse = parse; //# sourceMappingURL=range.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const wkx = __turbopack_context__.r("[project]/node_modules/wkx/lib/wkx.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    const warn = BaseTypes.ABSTRACT.warn.bind(void 0, "http://www.postgresql.org/docs/9.4/static/datatype.html");
    function removeUnsupportedIntegerOptions(dataType) {
        if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
            warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
            dataType._length = void 0;
            dataType.options.length = void 0;
            dataType._unsigned = void 0;
            dataType._zerofill = void 0;
        }
    }
    BaseTypes.UUID.types.postgres = [
        "uuid"
    ];
    BaseTypes.CIDR.types.postgres = [
        "cidr"
    ];
    BaseTypes.INET.types.postgres = [
        "inet"
    ];
    BaseTypes.MACADDR.types.postgres = [
        "macaddr"
    ];
    BaseTypes.TSVECTOR.types.postgres = [
        "tsvector"
    ];
    BaseTypes.JSON.types.postgres = [
        "json"
    ];
    BaseTypes.JSONB.types.postgres = [
        "jsonb"
    ];
    BaseTypes.TIME.types.postgres = [
        "time"
    ];
    class DATEONLY extends BaseTypes.DATEONLY {
        _stringify(value, options) {
            if (value === Infinity) {
                return "Infinity";
            }
            if (value === -Infinity) {
                return "-Infinity";
            }
            return super._stringify(value, options);
        }
        _sanitize(value, options) {
            if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower === "infinity") {
                        return Infinity;
                    }
                    if (lower === "-infinity") {
                        return -Infinity;
                    }
                }
                return super._sanitize(value);
            }
            return value;
        }
        static parse(value) {
            if (value === "infinity") {
                return Infinity;
            }
            if (value === "-infinity") {
                return -Infinity;
            }
            return value;
        }
    }
    BaseTypes.DATEONLY.types.postgres = [
        "date"
    ];
    class DECIMAL extends BaseTypes.DECIMAL {
        static parse(value) {
            return value;
        }
    }
    BaseTypes.DECIMAL.types.postgres = [
        "numeric"
    ];
    class STRING extends BaseTypes.STRING {
        toSql() {
            if (this._binary) {
                return "BYTEA";
            }
            return super.toSql();
        }
    }
    BaseTypes.STRING.types.postgres = [
        "varchar"
    ];
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            if (this._length) {
                warn("PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.");
                this._length = void 0;
            }
            return "TEXT";
        }
    }
    BaseTypes.TEXT.types.postgres = [
        "text"
    ];
    class CITEXT extends BaseTypes.CITEXT {
        static parse(value) {
            return value;
        }
    }
    BaseTypes.CITEXT.types.postgres = [
        "citext"
    ];
    class CHAR extends BaseTypes.CHAR {
        toSql() {
            if (this._binary) {
                return "BYTEA";
            }
            return super.toSql();
        }
    }
    BaseTypes.CHAR.types.postgres = [
        "char",
        "bpchar"
    ];
    class BOOLEAN extends BaseTypes.BOOLEAN {
        toSql() {
            return "BOOLEAN";
        }
        _sanitize(value) {
            if (value !== null && value !== void 0) {
                if (Buffer.isBuffer(value) && value.length === 1) {
                    value = value[0];
                }
                if (typeof value === "string") {
                    return [
                        "true",
                        "t"
                    ].includes(value) ? true : [
                        "false",
                        "f"
                    ].includes(value) ? false : value;
                }
                if (typeof value === "number") {
                    return value === 1 ? true : value === 0 ? false : value;
                }
            }
            return value;
        }
    }
    BOOLEAN.parse = BOOLEAN.prototype._sanitize;
    BaseTypes.BOOLEAN.types.postgres = [
        "bool"
    ];
    class DATE extends BaseTypes.DATE {
        toSql() {
            return "TIMESTAMP WITH TIME ZONE";
        }
        validate(value) {
            if (value !== Infinity && value !== -Infinity) {
                return super.validate(value);
            }
            return true;
        }
        _stringify(value, options) {
            if (value === Infinity) {
                return "Infinity";
            }
            if (value === -Infinity) {
                return "-Infinity";
            }
            return super._stringify(value, options);
        }
        _sanitize(value, options) {
            if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {
                if (typeof value === "string") {
                    const lower = value.toLowerCase();
                    if (lower === "infinity") {
                        return Infinity;
                    }
                    if (lower === "-infinity") {
                        return -Infinity;
                    }
                }
                return new Date(value);
            }
            return value;
        }
    }
    BaseTypes.DATE.types.postgres = [
        "timestamptz"
    ];
    class TINYINT extends BaseTypes.TINYINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    BaseTypes.TINYINT.types.postgres = [
        "int2"
    ];
    class SMALLINT extends BaseTypes.SMALLINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    BaseTypes.SMALLINT.types.postgres = [
        "int2"
    ];
    class INTEGER extends BaseTypes.INTEGER {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    INTEGER.parse = function parse(value) {
        return parseInt(value, 10);
    };
    BaseTypes.INTEGER.types.postgres = [
        "int4"
    ];
    class BIGINT extends BaseTypes.BIGINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    BaseTypes.BIGINT.types.postgres = [
        "int8"
    ];
    class REAL extends BaseTypes.REAL {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    BaseTypes.REAL.types.postgres = [
        "float4"
    ];
    class DOUBLE extends BaseTypes.DOUBLE {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    BaseTypes.DOUBLE.types.postgres = [
        "float8"
    ];
    class FLOAT extends BaseTypes.FLOAT {
        constructor(length, decimals){
            super(length, decimals);
            if (this._decimals) {
                warn("PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
                this._decimals = void 0;
            }
            if (this._unsigned) {
                warn("PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.");
                this._unsigned = void 0;
            }
            if (this._zerofill) {
                warn("PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.");
                this._zerofill = void 0;
            }
        }
    }
    delete FLOAT.parse;
    class BLOB extends BaseTypes.BLOB {
        toSql() {
            if (this._length) {
                warn("PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.");
                this._length = void 0;
            }
            return "BYTEA";
        }
        _hexify(hex) {
            return `E'\\\\x${hex}'`;
        }
    }
    BaseTypes.BLOB.types.postgres = [
        "bytea"
    ];
    class GEOMETRY extends BaseTypes.GEOMETRY {
        toSql() {
            let result = this.key;
            if (this.type) {
                result += `(${this.type}`;
                if (this.srid) {
                    result += `,${this.srid}`;
                }
                result += ")";
            }
            return result;
        }
        static parse(value) {
            const b = Buffer.from(value, "hex");
            return wkx.Geometry.parse(b).toGeoJSON({
                shortCrs: true
            });
        }
        _stringify(value, options) {
            return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
        }
        _bindParam(value, options) {
            return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
        }
    }
    BaseTypes.GEOMETRY.types.postgres = [
        "geometry"
    ];
    class GEOGRAPHY extends BaseTypes.GEOGRAPHY {
        toSql() {
            let result = "GEOGRAPHY";
            if (this.type) {
                result += `(${this.type}`;
                if (this.srid) {
                    result += `,${this.srid}`;
                }
                result += ")";
            }
            return result;
        }
        static parse(value) {
            const b = Buffer.from(value, "hex");
            return wkx.Geometry.parse(b).toGeoJSON({
                shortCrs: true
            });
        }
        _stringify(value, options) {
            return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;
        }
        bindParam(value, options) {
            return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;
        }
    }
    BaseTypes.GEOGRAPHY.types.postgres = [
        "geography"
    ];
    let hstore;
    class HSTORE extends BaseTypes.HSTORE {
        constructor(){
            super();
            if (!hstore) {
                hstore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/hstore.js [app-route] (ecmascript)");
            }
        }
        _value(value) {
            if (!hstore) {
                hstore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/hstore.js [app-route] (ecmascript)");
            }
            return hstore.stringify(value);
        }
        _stringify(value) {
            return `'${this._value(value)}'`;
        }
        _bindParam(value, options) {
            return options.bindParam(this._value(value));
        }
        static parse(value) {
            if (!hstore) {
                hstore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/hstore.js [app-route] (ecmascript)");
            }
            return hstore.parse(value);
        }
    }
    HSTORE.prototype.escape = false;
    BaseTypes.HSTORE.types.postgres = [
        "hstore"
    ];
    class RANGE extends BaseTypes.RANGE {
        _value(values, options) {
            if (!Array.isArray(values)) {
                return this.options.subtype.stringify(values, options);
            }
            const valueInclusivity = [
                true,
                false
            ];
            const valuesStringified = values.map((value, index)=>{
                if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, "value")) {
                    if (Object.prototype.hasOwnProperty.call(value, "inclusive")) {
                        valueInclusivity[index] = value.inclusive;
                    }
                    value = value.value;
                }
                if (value === null || value === -Infinity || value === Infinity) {
                    return value;
                }
                if (this.options.subtype.stringify) {
                    return this.options.subtype.stringify(value, options);
                }
                return options.escape(value);
            });
            valuesStringified.inclusive = valueInclusivity;
            return range.stringify(valuesStringified);
        }
        _stringify(values, options) {
            const value = this._value(values, options);
            if (!Array.isArray(values)) {
                return `'${value}'::${this.toCastType()}`;
            }
            return `'${value}'`;
        }
        _bindParam(values, options) {
            const value = this._value(values, options);
            if (!Array.isArray(values)) {
                return `${options.bindParam(value)}::${this.toCastType()}`;
            }
            return options.bindParam(value);
        }
        toSql() {
            return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];
        }
        toCastType() {
            return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];
        }
        static parse(value, options = {
            parser: (val)=>val
        }) {
            return range.parse(value, options.parser);
        }
    }
    const range = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/range.js [app-route] (ecmascript)");
    RANGE.prototype.escape = false;
    BaseTypes.RANGE.types.postgres = {
        subtypes: {
            integer: "int4range",
            decimal: "numrange",
            date: "tstzrange",
            dateonly: "daterange",
            bigint: "int8range"
        },
        castTypes: {
            integer: "int4",
            decimal: "numeric",
            date: "timestamptz",
            dateonly: "date",
            bigint: "int8"
        }
    };
    BaseTypes.ARRAY.prototype.escape = false;
    BaseTypes.ARRAY.prototype._value = function _value(values, options) {
        return values.map((value)=>{
            if (options && options.bindParam && this.type && this.type._value) {
                return this.type._value(value, options);
            }
            if (this.type && this.type.stringify) {
                value = this.type.stringify(value, options);
                if (this.type.escape === false) {
                    return value;
                }
            }
            return options.escape(value);
        }, this);
    };
    BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {
        let str = `ARRAY[${this._value(values, options).join(",")}]`;
        if (this.type) {
            const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
            let castKey = this.toSql();
            if (this.type instanceof BaseTypes.ENUM) {
                const table = options.field.Model.getTableName();
                const useSchema = table.schema !== void 0;
                const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '"')}${table.delimiter}` : "";
                castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '"')}[]`;
                str += `::${schemaWithDelimiter}${castKey}`;
            } else {
                str += `::${castKey}`;
            }
        }
        return str;
    };
    BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {
        return options.bindParam(this._value(values, options));
    };
    class ENUM extends BaseTypes.ENUM {
        static parse(value) {
            return value;
        }
    }
    BaseTypes.ENUM.types.postgres = [
        null
    ];
    return {
        DECIMAL,
        BLOB,
        STRING,
        CHAR,
        TEXT,
        CITEXT,
        TINYINT,
        SMALLINT,
        INTEGER,
        BIGINT,
        BOOLEAN,
        DATE,
        DATEONLY,
        REAL,
        "DOUBLE PRECISION": DOUBLE,
        FLOAT,
        GEOMETRY,
        GEOGRAPHY,
        HSTORE,
        RANGE,
        ENUM
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const wkx = __turbopack_context__.r("[project]/node_modules/wkx/lib/wkx.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    BaseTypes.ABSTRACT.prototype.dialectTypes = "https://dev.mysql.com/doc/refman/5.7/en/data-types.html";
    BaseTypes.DATE.types.mysql = [
        "DATETIME"
    ];
    BaseTypes.STRING.types.mysql = [
        "VAR_STRING"
    ];
    BaseTypes.CHAR.types.mysql = [
        "STRING"
    ];
    BaseTypes.TEXT.types.mysql = [
        "BLOB"
    ];
    BaseTypes.TINYINT.types.mysql = [
        "TINY"
    ];
    BaseTypes.SMALLINT.types.mysql = [
        "SHORT"
    ];
    BaseTypes.MEDIUMINT.types.mysql = [
        "INT24"
    ];
    BaseTypes.INTEGER.types.mysql = [
        "LONG"
    ];
    BaseTypes.BIGINT.types.mysql = [
        "LONGLONG"
    ];
    BaseTypes.FLOAT.types.mysql = [
        "FLOAT"
    ];
    BaseTypes.TIME.types.mysql = [
        "TIME"
    ];
    BaseTypes.DATEONLY.types.mysql = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.mysql = [
        "TINY"
    ];
    BaseTypes.BLOB.types.mysql = [
        "TINYBLOB",
        "BLOB",
        "LONGBLOB"
    ];
    BaseTypes.DECIMAL.types.mysql = [
        "NEWDECIMAL"
    ];
    BaseTypes.UUID.types.mysql = false;
    BaseTypes.ENUM.types.mysql = false;
    BaseTypes.REAL.types.mysql = [
        "DOUBLE"
    ];
    BaseTypes.DOUBLE.types.mysql = [
        "DOUBLE"
    ];
    BaseTypes.GEOMETRY.types.mysql = [
        "GEOMETRY"
    ];
    BaseTypes.JSON.types.mysql = [
        "JSON"
    ];
    class DECIMAL extends BaseTypes.DECIMAL {
        toSql() {
            let definition = super.toSql();
            if (this._unsigned) {
                definition += " UNSIGNED";
            }
            if (this._zerofill) {
                definition += " ZEROFILL";
            }
            return definition;
        }
    }
    class DATE extends BaseTypes.DATE {
        toSql() {
            return this._length ? `DATETIME(${this._length})` : "DATETIME";
        }
        _stringify(date, options) {
            if (!moment.isMoment(date)) {
                date = this._applyTimezone(date, options);
            }
            if (this._length) {
                return date.format("YYYY-MM-DD HH:mm:ss.SSS");
            }
            return date.format("YYYY-MM-DD HH:mm:ss");
        }
        static parse(value, options) {
            value = value.string();
            if (value === null) {
                return value;
            }
            if (momentTz.tz.zone(options.timezone)) {
                value = momentTz.tz(value, options.timezone).toDate();
            } else {
                value = new Date(`${value} ${options.timezone}`);
            }
            return value;
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(value) {
            return value.string();
        }
    }
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "CHAR(36) BINARY";
        }
    }
    const SUPPORTED_GEOMETRY_TYPES = [
        "POINT",
        "LINESTRING",
        "POLYGON"
    ];
    class GEOMETRY extends BaseTypes.GEOMETRY {
        constructor(type, srid){
            super(type, srid);
            if (_.isEmpty(this.type)) {
                this.sqlType = this.key;
                return;
            }
            if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {
                this.sqlType = this.type;
                return;
            }
            throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(", ")}`);
        }
        static parse(value) {
            value = value.buffer();
            if (!value || value.length === 0) {
                return null;
            }
            value = value.slice(4);
            return wkx.Geometry.parse(value).toGeoJSON({
                shortCrs: true
            });
        }
        toSql() {
            return this.sqlType;
        }
    }
    class ENUM extends BaseTypes.ENUM {
        toSql(options) {
            return `ENUM(${this.values.map((value)=>options.escape(value)).join(", ")})`;
        }
    }
    class JSONTYPE extends BaseTypes.JSON {
        _stringify(value, options) {
            return options.operation === "where" && typeof value === "string" ? value : JSON.stringify(value);
        }
    }
    return {
        ENUM,
        DATE,
        DATEONLY,
        UUID,
        GEOMETRY,
        DECIMAL,
        JSON: JSONTYPE
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mariadb/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const wkx = __turbopack_context__.r("[project]/node_modules/wkx/lib/wkx.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    BaseTypes.ABSTRACT.prototype.dialectTypes = "https://mariadb.com/kb/en/library/resultset/#field-types";
    BaseTypes.DATE.types.mariadb = [
        "DATETIME"
    ];
    BaseTypes.STRING.types.mariadb = [
        "VAR_STRING"
    ];
    BaseTypes.CHAR.types.mariadb = [
        "STRING"
    ];
    BaseTypes.TEXT.types.mariadb = [
        "BLOB"
    ];
    BaseTypes.TINYINT.types.mariadb = [
        "TINY"
    ];
    BaseTypes.SMALLINT.types.mariadb = [
        "SHORT"
    ];
    BaseTypes.MEDIUMINT.types.mariadb = [
        "INT24"
    ];
    BaseTypes.INTEGER.types.mariadb = [
        "LONG"
    ];
    BaseTypes.BIGINT.types.mariadb = [
        "LONGLONG"
    ];
    BaseTypes.FLOAT.types.mariadb = [
        "FLOAT"
    ];
    BaseTypes.TIME.types.mariadb = [
        "TIME"
    ];
    BaseTypes.DATEONLY.types.mariadb = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.mariadb = [
        "TINY"
    ];
    BaseTypes.BLOB.types.mariadb = [
        "TINYBLOB",
        "BLOB",
        "LONGBLOB"
    ];
    BaseTypes.DECIMAL.types.mariadb = [
        "NEWDECIMAL"
    ];
    BaseTypes.UUID.types.mariadb = false;
    BaseTypes.ENUM.types.mariadb = false;
    BaseTypes.REAL.types.mariadb = [
        "DOUBLE"
    ];
    BaseTypes.DOUBLE.types.mariadb = [
        "DOUBLE"
    ];
    BaseTypes.GEOMETRY.types.mariadb = [
        "GEOMETRY"
    ];
    BaseTypes.JSON.types.mariadb = [
        "JSON"
    ];
    class DECIMAL extends BaseTypes.DECIMAL {
        toSql() {
            let definition = super.toSql();
            if (this._unsigned) {
                definition += " UNSIGNED";
            }
            if (this._zerofill) {
                definition += " ZEROFILL";
            }
            return definition;
        }
    }
    class DATE extends BaseTypes.DATE {
        toSql() {
            return this._length ? `DATETIME(${this._length})` : "DATETIME";
        }
        _stringify(date, options) {
            if (!moment.isMoment(date)) {
                date = this._applyTimezone(date, options);
            }
            return date.format("YYYY-MM-DD HH:mm:ss.SSS");
        }
        static parse(value, options) {
            value = value.string();
            if (value === null) {
                return value;
            }
            if (momentTz.tz.zone(options.timezone)) {
                value = momentTz.tz(value, options.timezone).toDate();
            } else {
                value = new Date(`${value} ${options.timezone}`);
            }
            return value;
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(value) {
            return value.string();
        }
    }
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "CHAR(36) BINARY";
        }
    }
    class GEOMETRY extends BaseTypes.GEOMETRY {
        constructor(type, srid){
            super(type, srid);
            if (_.isEmpty(this.type)) {
                this.sqlType = this.key;
            } else {
                this.sqlType = this.type;
            }
        }
        static parse(value) {
            value = value.buffer();
            if (!value || value.length === 0) {
                return null;
            }
            value = value.slice(4);
            return wkx.Geometry.parse(value).toGeoJSON({
                shortCrs: true
            });
        }
        toSql() {
            return this.sqlType;
        }
    }
    class ENUM extends BaseTypes.ENUM {
        toSql(options) {
            return `ENUM(${this.values.map((value)=>options.escape(value)).join(", ")})`;
        }
    }
    class JSONTYPE extends BaseTypes.JSON {
        _stringify(value, options) {
            return options.operation === "where" && typeof value === "string" ? value : JSON.stringify(value);
        }
    }
    return {
        ENUM,
        DATE,
        DATEONLY,
        UUID,
        GEOMETRY,
        DECIMAL,
        JSON: JSONTYPE
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (BaseTypes)=>{
    const warn = BaseTypes.ABSTRACT.warn.bind(void 0, "https://www.sqlite.org/datatype3.html");
    function removeUnsupportedIntegerOptions(dataType) {
        if (dataType._zerofill || dataType._unsigned) {
            warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);
            dataType._unsigned = void 0;
            dataType._zerofill = void 0;
        }
    }
    BaseTypes.DATE.types.sqlite = [
        "DATETIME"
    ];
    BaseTypes.STRING.types.sqlite = [
        "VARCHAR",
        "VARCHAR BINARY"
    ];
    BaseTypes.CHAR.types.sqlite = [
        "CHAR",
        "CHAR BINARY"
    ];
    BaseTypes.TEXT.types.sqlite = [
        "TEXT"
    ];
    BaseTypes.TINYINT.types.sqlite = [
        "TINYINT"
    ];
    BaseTypes.SMALLINT.types.sqlite = [
        "SMALLINT"
    ];
    BaseTypes.MEDIUMINT.types.sqlite = [
        "MEDIUMINT"
    ];
    BaseTypes.INTEGER.types.sqlite = [
        "INTEGER"
    ];
    BaseTypes.BIGINT.types.sqlite = [
        "BIGINT"
    ];
    BaseTypes.FLOAT.types.sqlite = [
        "FLOAT"
    ];
    BaseTypes.TIME.types.sqlite = [
        "TIME"
    ];
    BaseTypes.DATEONLY.types.sqlite = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.sqlite = [
        "TINYINT"
    ];
    BaseTypes.BLOB.types.sqlite = [
        "TINYBLOB",
        "BLOB",
        "LONGBLOB"
    ];
    BaseTypes.DECIMAL.types.sqlite = [
        "DECIMAL"
    ];
    BaseTypes.UUID.types.sqlite = [
        "UUID"
    ];
    BaseTypes.ENUM.types.sqlite = false;
    BaseTypes.REAL.types.sqlite = [
        "REAL"
    ];
    BaseTypes.DOUBLE.types.sqlite = [
        "DOUBLE PRECISION"
    ];
    BaseTypes.GEOMETRY.types.sqlite = false;
    BaseTypes.JSON.types.sqlite = [
        "JSON",
        "JSONB"
    ];
    class JSONTYPE extends BaseTypes.JSON {
        static parse(data) {
            return JSON.parse(data);
        }
    }
    class DATE extends BaseTypes.DATE {
        static parse(date, options) {
            if (!date.includes("+")) {
                return new Date(date + options.timezone);
            }
            return new Date(date);
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(date) {
            return date;
        }
    }
    class STRING extends BaseTypes.STRING {
        toSql() {
            if (this._binary) {
                return `VARCHAR BINARY(${this._length})`;
            }
            return super.toSql(this);
        }
    }
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            if (this._length) {
                warn("SQLite does not support TEXT with options. Plain `TEXT` will be used instead.");
                this._length = void 0;
            }
            return "TEXT";
        }
    }
    class CITEXT extends BaseTypes.CITEXT {
        toSql() {
            return "TEXT COLLATE NOCASE";
        }
    }
    class CHAR extends BaseTypes.CHAR {
        toSql() {
            if (this._binary) {
                return `CHAR BINARY(${this._length})`;
            }
            return super.toSql();
        }
    }
    class NUMBER extends BaseTypes.NUMBER {
        toSql() {
            let result = this.key;
            if (this._unsigned) {
                result += " UNSIGNED";
            }
            if (this._zerofill) {
                result += " ZEROFILL";
            }
            if (this._length) {
                result += `(${this._length}`;
                if (typeof this._decimals === "number") {
                    result += `,${this._decimals}`;
                }
                result += ")";
            }
            return result;
        }
    }
    class TINYINT extends BaseTypes.TINYINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class SMALLINT extends BaseTypes.SMALLINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class MEDIUMINT extends BaseTypes.MEDIUMINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class INTEGER extends BaseTypes.INTEGER {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class BIGINT extends BaseTypes.BIGINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class FLOAT extends BaseTypes.FLOAT {
    }
    class DOUBLE extends BaseTypes.DOUBLE {
    }
    class REAL extends BaseTypes.REAL {
    }
    function parseFloating(value) {
        if (typeof value !== "string") {
            return value;
        }
        if (value === "NaN") {
            return NaN;
        }
        if (value === "Infinity") {
            return Infinity;
        }
        if (value === "-Infinity") {
            return -Infinity;
        }
    }
    for (const floating of [
        FLOAT,
        DOUBLE,
        REAL
    ]){
        floating.parse = parseFloating;
    }
    for (const num of [
        FLOAT,
        DOUBLE,
        REAL,
        TINYINT,
        SMALLINT,
        MEDIUMINT,
        INTEGER,
        BIGINT
    ]){
        num.prototype.toSql = NUMBER.prototype.toSql;
    }
    class ENUM extends BaseTypes.ENUM {
        toSql() {
            return "TEXT";
        }
    }
    return {
        DATE,
        DATEONLY,
        STRING,
        CHAR,
        NUMBER,
        FLOAT,
        REAL,
        "DOUBLE PRECISION": DOUBLE,
        TINYINT,
        SMALLINT,
        MEDIUMINT,
        INTEGER,
        BIGINT,
        TEXT,
        ENUM,
        JSON: JSONTYPE,
        CITEXT
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    const warn = BaseTypes.ABSTRACT.warn.bind(void 0, "https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx");
    function removeUnsupportedIntegerOptions(dataType) {
        if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
            warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);
            dataType._length = void 0;
            dataType.options.length = void 0;
            dataType._unsigned = void 0;
            dataType._zerofill = void 0;
        }
    }
    BaseTypes.DATE.types.mssql = [
        43
    ];
    BaseTypes.STRING.types.mssql = [
        231,
        173
    ];
    BaseTypes.CHAR.types.mssql = [
        175
    ];
    BaseTypes.TEXT.types.mssql = false;
    BaseTypes.TINYINT.types.mssql = [
        30
    ];
    BaseTypes.SMALLINT.types.mssql = [
        34
    ];
    BaseTypes.MEDIUMINT.types.mssql = false;
    BaseTypes.INTEGER.types.mssql = [
        38
    ];
    BaseTypes.BIGINT.types.mssql = false;
    BaseTypes.FLOAT.types.mssql = [
        109
    ];
    BaseTypes.TIME.types.mssql = [
        41
    ];
    BaseTypes.DATEONLY.types.mssql = [
        40
    ];
    BaseTypes.BOOLEAN.types.mssql = [
        104
    ];
    BaseTypes.BLOB.types.mssql = [
        165
    ];
    BaseTypes.DECIMAL.types.mssql = [
        106
    ];
    BaseTypes.UUID.types.mssql = false;
    BaseTypes.ENUM.types.mssql = false;
    BaseTypes.REAL.types.mssql = [
        109
    ];
    BaseTypes.DOUBLE.types.mssql = [
        109
    ];
    BaseTypes.GEOMETRY.types.mssql = false;
    class BLOB extends BaseTypes.BLOB {
        toSql() {
            if (this._length) {
                if (this._length.toLowerCase() === "tiny") {
                    warn("MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.");
                    return "VARBINARY(256)";
                }
                warn("MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.");
            }
            return "VARBINARY(MAX)";
        }
        _hexify(hex) {
            return `0x${hex}`;
        }
    }
    class STRING extends BaseTypes.STRING {
        toSql() {
            if (!this._binary) {
                return `NVARCHAR(${this._length})`;
            }
            return `BINARY(${this._length})`;
        }
        _stringify(value, options) {
            if (this._binary) {
                return BLOB.prototype._stringify(value);
            }
            return options.escape(value);
        }
        _bindParam(value, options) {
            return options.bindParam(this._binary ? Buffer.from(value) : value);
        }
    }
    STRING.prototype.escape = false;
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            if (this._length) {
                if (this._length.toLowerCase() === "tiny") {
                    warn("MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.");
                    return "NVARCHAR(256)";
                }
                warn("MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.");
            }
            return "NVARCHAR(MAX)";
        }
    }
    class BOOLEAN extends BaseTypes.BOOLEAN {
        toSql() {
            return "BIT";
        }
    }
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "CHAR(36)";
        }
    }
    class NOW extends BaseTypes.NOW {
        toSql() {
            return "GETDATE()";
        }
    }
    class DATE extends BaseTypes.DATE {
        toSql() {
            return "DATETIMEOFFSET";
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(value) {
            return moment(value).format("YYYY-MM-DD");
        }
    }
    class INTEGER extends BaseTypes.INTEGER {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class TINYINT extends BaseTypes.TINYINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class SMALLINT extends BaseTypes.SMALLINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class BIGINT extends BaseTypes.BIGINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class REAL extends BaseTypes.REAL {
        constructor(length, decimals){
            super(length, decimals);
            if (this._length || this.options.length || this._unsigned || this._zerofill) {
                warn("MSSQL does not support REAL with options. Plain `REAL` will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
                this._unsigned = void 0;
                this._zerofill = void 0;
            }
        }
    }
    class FLOAT extends BaseTypes.FLOAT {
        constructor(length, decimals){
            super(length, decimals);
            if (this._decimals) {
                warn("MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
            }
            if (this._unsigned) {
                warn("MSSQL does not support Float unsigned. `UNSIGNED` was removed.");
                this._unsigned = void 0;
            }
            if (this._zerofill) {
                warn("MSSQL does not support Float zerofill. `ZEROFILL` was removed.");
                this._zerofill = void 0;
            }
        }
    }
    class ENUM extends BaseTypes.ENUM {
        toSql() {
            return "VARCHAR(255)";
        }
    }
    return {
        BLOB,
        BOOLEAN,
        ENUM,
        STRING,
        UUID,
        DATE,
        DATEONLY,
        NOW,
        TINYINT,
        SMALLINT,
        INTEGER,
        BIGINT,
        REAL,
        FLOAT,
        TEXT
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    const warn = BaseTypes.ABSTRACT.warn.bind(void 0, "https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008478.html");
    function removeUnsupportedIntegerOptions(dataType) {
        if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {
            warn(`Db2 does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);
            dataType._length = void 0;
            dataType.options.length = void 0;
            dataType._unsigned = void 0;
            dataType._zerofill = void 0;
        }
    }
    BaseTypes.DATE.types.db2 = [
        "TIMESTAMP"
    ];
    BaseTypes.STRING.types.db2 = [
        "VARCHAR"
    ];
    BaseTypes.CHAR.types.db2 = [
        "CHAR"
    ];
    BaseTypes.TEXT.types.db2 = [
        "VARCHAR",
        "CLOB"
    ];
    BaseTypes.TINYINT.types.db2 = [
        "SMALLINT"
    ];
    BaseTypes.SMALLINT.types.db2 = [
        "SMALLINT"
    ];
    BaseTypes.MEDIUMINT.types.db2 = [
        "INTEGER"
    ];
    BaseTypes.INTEGER.types.db2 = [
        "INTEGER"
    ];
    BaseTypes.BIGINT.types.db2 = [
        "BIGINT"
    ];
    BaseTypes.FLOAT.types.db2 = [
        "DOUBLE",
        "REAL",
        "FLOAT"
    ];
    BaseTypes.TIME.types.db2 = [
        "TIME"
    ];
    BaseTypes.DATEONLY.types.db2 = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.db2 = [
        "BOOLEAN",
        "BOOL",
        "SMALLINT",
        "BIT"
    ];
    BaseTypes.BLOB.types.db2 = [
        "BLOB"
    ];
    BaseTypes.DECIMAL.types.db2 = [
        "DECIMAL"
    ];
    BaseTypes.UUID.types.db2 = [
        "CHAR () FOR BIT DATA"
    ];
    BaseTypes.ENUM.types.db2 = [
        "VARCHAR"
    ];
    BaseTypes.REAL.types.db2 = [
        "REAL"
    ];
    BaseTypes.DOUBLE.types.db2 = [
        "DOUBLE"
    ];
    BaseTypes.GEOMETRY.types.db2 = false;
    class BLOB extends BaseTypes.BLOB {
        toSql() {
            if (this._length) {
                if (this._length.toLowerCase() === "tiny") {
                    return "BLOB(255)";
                }
                if (this._length.toLowerCase() === "medium") {
                    return "BLOB(16M)";
                }
                if (this._length.toLowerCase() === "long") {
                    return "BLOB(2G)";
                }
                return `BLOB(${this._length})`;
            }
            return "BLOB";
        }
        escape(blob) {
            return `BLOB('${blob.toString().replace(/'/g, "''")}')`;
        }
        _stringify(value) {
            if (Buffer.isBuffer(value)) {
                return `BLOB('${value.toString().replace(/'/g, "''")}')`;
            }
            if (Array.isArray(value)) {
                value = Buffer.from(value);
            } else {
                value = Buffer.from(value.toString());
            }
            const hex = value.toString("hex");
            return this._hexify(hex);
        }
        _hexify(hex) {
            return `x'${hex}'`;
        }
    }
    class STRING extends BaseTypes.STRING {
        toSql() {
            if (!this._binary) {
                if (this._length <= 4e3) {
                    return `VARCHAR(${this._length})`;
                }
                return `CLOB(${this._length})`;
            }
            if (this._length < 255) {
                return `CHAR(${this._length}) FOR BIT DATA`;
            }
            if (this._length <= 4e3) {
                return `VARCHAR(${this._length}) FOR BIT DATA`;
            }
            return `BLOB(${this._length})`;
        }
        _stringify(value, options) {
            if (this._binary) {
                return BLOB.prototype._hexify(value.toString("hex"));
            }
            return options.escape(value);
        }
        _bindParam(value, options) {
            return options.bindParam(this._binary ? Buffer.from(value) : value);
        }
    }
    STRING.prototype.escape = false;
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            let len = 0;
            if (this._length) {
                switch(this._length.toLowerCase()){
                    case "tiny":
                        len = 256;
                        break;
                    case "medium":
                        len = 8192;
                        break;
                    case "long":
                        len = 65536;
                        break;
                }
                if (isNaN(this._length)) {
                    this._length = 32672;
                }
                if (len > 0) {
                    this._length = len;
                }
            } else {
                this._length = 32672;
            }
            if (this._length > 32672) {
                len = `CLOB(${this._length})`;
            } else {
                len = `VARCHAR(${this._length})`;
            }
            warn(`Db2 does not support TEXT datatype. ${len} will be used instead.`);
            return len;
        }
    }
    class BOOLEAN extends BaseTypes.BOOLEAN {
        toSql() {
            return "BOOLEAN";
        }
        _sanitize(value) {
            if (value !== null && value !== void 0) {
                if (Buffer.isBuffer(value) && value.length === 1) {
                    value = value[0];
                }
                if (typeof value === "string") {
                    value = value === "true" ? true : value === "false" ? false : value;
                    value = value === "" ? true : value === "\0" ? false : value;
                } else if (typeof value === "number") {
                    value = value === 1 ? true : value === 0 ? false : value;
                }
            }
            return value;
        }
    }
    BOOLEAN.parse = BOOLEAN.prototype._sanitize;
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "CHAR(36) FOR BIT DATA";
        }
    }
    class NOW extends BaseTypes.NOW {
        toSql() {
            return "CURRENT TIME";
        }
    }
    class DATE extends BaseTypes.DATE {
        toSql() {
            if (this._length < 0) {
                this._length = 0;
            }
            if (this._length > 6) {
                this._length = 6;
            }
            return `TIMESTAMP${this._length ? `(${this._length})` : ""}`;
        }
        _stringify(date, options) {
            if (!moment.isMoment(date)) {
                date = this._applyTimezone(date, options);
            }
            if (this._length > 0) {
                let msec = ".";
                for(let i = 0; i < this._length && i < 6; i++){
                    msec += "S";
                }
                return date.format(`YYYY-MM-DD HH:mm:ss${msec}`);
            }
            return date.format("YYYY-MM-DD HH:mm:ss");
        }
        static parse(value) {
            if (typeof value !== "string") {
                value = value.string();
            }
            if (value === null) {
                return value;
            }
            value = new Date(momentTz.utc(value));
            return value;
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(value) {
            return momentTz(value).format("YYYY-MM-DD");
        }
    }
    class INTEGER extends BaseTypes.INTEGER {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class TINYINT extends BaseTypes.TINYINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class SMALLINT extends BaseTypes.SMALLINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class BIGINT extends BaseTypes.BIGINT {
        constructor(length){
            super(length);
            removeUnsupportedIntegerOptions(this);
        }
    }
    class REAL extends BaseTypes.REAL {
        constructor(length, decimals){
            super(length, decimals);
            if (this._length || this.options.length || this._unsigned || this._zerofill) {
                warn("Db2 does not support REAL with options. Plain `REAL` will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
                this._unsigned = void 0;
                this._zerofill = void 0;
            }
        }
    }
    class FLOAT extends BaseTypes.FLOAT {
        constructor(length, decimals){
            super(length, decimals);
            if (this._decimals) {
                warn("Db2 does not support Float with decimals. Plain `FLOAT` will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
            }
            if (this._unsigned) {
                warn("Db2 does not support Float unsigned. `UNSIGNED` was removed.");
                this._unsigned = void 0;
            }
            if (this._zerofill) {
                warn("Db2 does not support Float zerofill. `ZEROFILL` was removed.");
                this._zerofill = void 0;
            }
        }
    }
    class ENUM extends BaseTypes.ENUM {
        toSql() {
            return "VARCHAR(255)";
        }
    }
    class DOUBLE extends BaseTypes.DOUBLE {
        constructor(length, decimals){
            super(length, decimals);
            if (this._length || this.options.length || this._unsigned || this._zerofill) {
                warn("db2 does not support DOUBLE with options. Plain DOUBLE will be used instead.");
                this._length = void 0;
                this.options.length = void 0;
                this._unsigned = void 0;
                this._zerofill = void 0;
            }
        }
        toSql() {
            return "DOUBLE";
        }
    }
    DOUBLE.prototype.key = DOUBLE.key = "DOUBLE";
    return {
        BLOB,
        BOOLEAN,
        ENUM,
        STRING,
        UUID,
        DATE,
        DATEONLY,
        NOW,
        TINYINT,
        SMALLINT,
        INTEGER,
        DOUBLE,
        "DOUBLE PRECISION": DOUBLE,
        BIGINT,
        REAL,
        FLOAT,
        TEXT
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    BaseTypes.ABSTRACT.prototype.dialectTypes = "https://dev.snowflake.com/doc/refman/5.7/en/data-types.html";
    BaseTypes.DATE.types.snowflake = [
        "DATETIME"
    ];
    BaseTypes.STRING.types.snowflake = [
        "VAR_STRING"
    ];
    BaseTypes.CHAR.types.snowflake = [
        "STRING"
    ];
    BaseTypes.TEXT.types.snowflake = [
        "BLOB"
    ];
    BaseTypes.TINYINT.types.snowflake = [
        "TINY"
    ];
    BaseTypes.SMALLINT.types.snowflake = [
        "SHORT"
    ];
    BaseTypes.MEDIUMINT.types.snowflake = [
        "INT24"
    ];
    BaseTypes.INTEGER.types.snowflake = [
        "LONG"
    ];
    BaseTypes.BIGINT.types.snowflake = [
        "LONGLONG"
    ];
    BaseTypes.FLOAT.types.snowflake = [
        "FLOAT"
    ];
    BaseTypes.TIME.types.snowflake = [
        "TIME"
    ];
    BaseTypes.DATEONLY.types.snowflake = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.snowflake = [
        "TINY"
    ];
    BaseTypes.BLOB.types.snowflake = [
        "TINYBLOB",
        "BLOB",
        "LONGBLOB"
    ];
    BaseTypes.DECIMAL.types.snowflake = [
        "NEWDECIMAL"
    ];
    BaseTypes.UUID.types.snowflake = false;
    BaseTypes.ENUM.types.snowflake = false;
    BaseTypes.REAL.types.snowflake = [
        "DOUBLE"
    ];
    BaseTypes.DOUBLE.types.snowflake = [
        "DOUBLE"
    ];
    BaseTypes.GEOMETRY.types.snowflake = [
        "GEOMETRY"
    ];
    BaseTypes.JSON.types.snowflake = [
        "JSON"
    ];
    class DATE extends BaseTypes.DATE {
        toSql() {
            return "TIMESTAMP";
        }
        _stringify(date, options) {
            if (!moment.isMoment(date)) {
                date = this._applyTimezone(date, options);
            }
            if (this._length) {
                return date.format("YYYY-MM-DD HH:mm:ss.SSS");
            }
            return date.format("YYYY-MM-DD HH:mm:ss");
        }
        static parse(value, options) {
            value = value.string();
            if (value === null) {
                return value;
            }
            if (momentTz.tz.zone(options.timezone)) {
                value = momentTz.tz(value, options.timezone).toDate();
            } else {
                value = new Date(`${value} ${options.timezone}`);
            }
            return value;
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        static parse(value) {
            return value.string();
        }
    }
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "VARCHAR(36)";
        }
    }
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            return "TEXT";
        }
    }
    class BOOLEAN extends BaseTypes.BOOLEAN {
        toSql() {
            return "BOOLEAN";
        }
    }
    class JSONTYPE extends BaseTypes.JSON {
        _stringify(value, options) {
            return options.operation === "where" && typeof value === "string" ? value : JSON.stringify(value);
        }
    }
    return {
        TEXT,
        DATE,
        BOOLEAN,
        DATEONLY,
        UUID,
        JSON: JSONTYPE
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
module.exports = (BaseTypes)=>{
    const warn = BaseTypes.ABSTRACT.warn.bind(void 0, "https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C");
    BaseTypes.DATE.types.oracle = [
        "TIMESTAMP",
        "TIMESTAMP WITH LOCAL TIME ZONE"
    ];
    BaseTypes.STRING.types.oracle = [
        "VARCHAR2",
        "NVARCHAR2"
    ];
    BaseTypes.CHAR.types.oracle = [
        "CHAR",
        "RAW"
    ];
    BaseTypes.TEXT.types.oracle = [
        "CLOB"
    ];
    BaseTypes.TINYINT.types.oracle = [
        "NUMBER"
    ];
    BaseTypes.SMALLINT.types.oracle = [
        "NUMBER"
    ];
    BaseTypes.MEDIUMINT.types.oracle = [
        "NUMBER"
    ];
    BaseTypes.INTEGER.types.oracle = [
        "INTEGER"
    ];
    BaseTypes.BIGINT.types.oracle = [
        "NUMBER"
    ];
    BaseTypes.FLOAT.types.oracle = [
        "BINARY_FLOAT"
    ];
    BaseTypes.DATEONLY.types.oracle = [
        "DATE"
    ];
    BaseTypes.BOOLEAN.types.oracle = [
        "CHAR(1)"
    ];
    BaseTypes.BLOB.types.oracle = [
        "BLOB"
    ];
    BaseTypes.DECIMAL.types.oracle = [
        "NUMBER"
    ];
    BaseTypes.UUID.types.oracle = [
        "VARCHAR2"
    ];
    BaseTypes.ENUM.types.oracle = [
        "VARCHAR2"
    ];
    BaseTypes.REAL.types.oracle = [
        "BINARY_DOUBLE"
    ];
    BaseTypes.DOUBLE.types.oracle = [
        "BINARY_DOUBLE"
    ];
    BaseTypes.JSON.types.oracle = [
        "BLOB"
    ];
    BaseTypes.GEOMETRY.types.oracle = false;
    class STRING extends BaseTypes.STRING {
        toSql() {
            if (this.length > 4e3 || this._binary && this._length > 2e3) {
                warn("Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6");
            }
            if (!this._binary) {
                return `NVARCHAR2(${this._length})`;
            }
            return `RAW(${this._length})`;
        }
        _stringify(value, options) {
            if (this._binary) {
                return options.escape(value.toString("hex"));
            }
            return options.escape(value);
        }
        _getBindDef(oracledb) {
            if (this._binary) {
                return {
                    type: oracledb.DB_TYPE_RAW,
                    maxSize: this._length
                };
            }
            return {
                type: oracledb.DB_TYPE_VARCHAR,
                maxSize: this._length
            };
        }
        _bindParam(value, options) {
            return options.bindParam(value);
        }
    }
    STRING.prototype.escape = false;
    class BOOLEAN extends BaseTypes.BOOLEAN {
        toSql() {
            return "CHAR(1)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_CHAR,
                maxSize: 1
            };
        }
        _stringify(value) {
            return value === true ? "1" : value === false ? "0" : value;
        }
        _sanitize(value) {
            if (typeof value === "string") {
                return value === "1" || value === "true" ? true : value === "0" || value === "false" ? false : value;
            }
            return super._sanitize(value);
        }
    }
    class UUID extends BaseTypes.UUID {
        toSql() {
            return "VARCHAR2(36)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_VARCHAR,
                maxSize: 36
            };
        }
    }
    class NOW extends BaseTypes.NOW {
        toSql() {
            return "SYSDATE";
        }
        _stringify() {
            return "SYSDATE";
        }
    }
    class ENUM extends BaseTypes.ENUM {
        toSql() {
            return "VARCHAR2(512)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_VARCHAR,
                maxSize: 512
            };
        }
    }
    class TEXT extends BaseTypes.TEXT {
        toSql() {
            return "CLOB";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_CLOB
            };
        }
    }
    class CHAR extends BaseTypes.CHAR {
        toSql() {
            if (this._binary) {
                warn("Oracle CHAR.BINARY datatype is not of Fixed Length.");
                return `RAW(${this._length})`;
            }
            return super.toSql();
        }
        _getBindDef(oracledb) {
            if (this._binary) {
                return {
                    type: oracledb.DB_TYPE_RAW,
                    maxSize: this._length
                };
            }
            return {
                type: oracledb.DB_TYPE_CHAR,
                maxSize: this._length
            };
        }
        _bindParam(value, options) {
            return options.bindParam(value);
        }
    }
    class DATE extends BaseTypes.DATE {
        toSql() {
            return "TIMESTAMP WITH LOCAL TIME ZONE";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_TIMESTAMP_LTZ
            };
        }
        _stringify(date, options) {
            const format = "YYYY-MM-DD HH24:MI:SS.FFTZH:TZM";
            date = this._applyTimezone(date, options);
            const formatedDate = date.format("YYYY-MM-DD HH:mm:ss.SSS Z");
            return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;
        }
        _applyTimezone(date, options) {
            if (options.timezone) {
                if (momentTz.tz.zone(options.timezone)) {
                    date = momentTz(date).tz(options.timezone);
                } else {
                    date = moment(date).utcOffset(options.timezone);
                }
            } else {
                date = momentTz(date);
            }
            return date;
        }
        static parse(value, options) {
            if (value === null) {
                return value;
            }
            if (options && moment.tz.zone(options.timezone)) {
                value = moment.tz(value.toString(), options.timezone).toDate();
            }
            return value;
        }
        _bindParam(value, options) {
            return options.bindParam(value);
        }
    }
    DATE.prototype.escape = false;
    class DECIMAL extends BaseTypes.DECIMAL {
        toSql() {
            let result = "";
            if (this._length) {
                result += `(${this._length}`;
                if (typeof this._decimals === "number") {
                    result += `,${this._decimals}`;
                }
                result += ")";
            }
            if (!this._length && this._precision) {
                result += `(${this._precision}`;
                if (typeof this._scale === "number") {
                    result += `,${this._scale}`;
                }
                result += ")";
            }
            return `NUMBER${result}`;
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class TINYINT extends BaseTypes.TINYINT {
        toSql() {
            return "NUMBER(3)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class SMALLINT extends BaseTypes.SMALLINT {
        toSql() {
            if (this._length) {
                return `NUMBER(${this._length},0)`;
            }
            return "SMALLINT";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class MEDIUMINT extends BaseTypes.MEDIUMINT {
        toSql() {
            return "NUMBER(8)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class BIGINT extends BaseTypes.BIGINT {
        constructor(length){
            super(length);
            if (!(this instanceof BIGINT)) return new BIGINT(length);
            BaseTypes.BIGINT.apply(this, arguments);
            if (this._length || this.options.length || this._unsigned || this._zerofill) {
                warn("Oracle does not support BIGINT with options");
                this._length = void 0;
                this.options.length = void 0;
                this._unsigned = void 0;
                this._zerofill = void 0;
            }
        }
        toSql() {
            return "NUMBER(19)";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
        _sanitize(value) {
            if (typeof value === "bigint" || typeof value === "number") {
                return value.toString();
            }
            return value;
        }
    }
    class NUMBER extends BaseTypes.NUMBER {
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class INTEGER extends BaseTypes.INTEGER {
        toSql() {
            if (this._length) {
                return `NUMBER(${this._length},0)`;
            }
            return "INTEGER";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_NUMBER
            };
        }
    }
    class FLOAT extends BaseTypes.FLOAT {
        toSql() {
            return "BINARY_FLOAT";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_BINARY_FLOAT
            };
        }
    }
    class REAL extends BaseTypes.REAL {
        toSql() {
            return "BINARY_DOUBLE";
        }
        _stringify(value) {
            if (value === Number.POSITIVE_INFINITY) {
                return "inf";
            }
            if (value === Number.NEGATIVE_INFINITY) {
                return "-inf";
            }
            return value;
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_BINARY_DOUBLE
            };
        }
    }
    class BLOB extends BaseTypes.BLOB {
        _hexify(hex) {
            return `'${hex}'`;
        }
        toSql() {
            return "BLOB";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_BLOB
            };
        }
    }
    class JSONTYPE extends BaseTypes.JSON {
        toSql() {
            return "BLOB";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_BLOB
            };
        }
        _stringify(value, options) {
            return options.operation === "where" && typeof value === "string" ? value : JSON.stringify(value);
        }
        _bindParam(value, options) {
            return options.bindParam(Buffer.from(JSON.stringify(value)));
        }
    }
    class DOUBLE extends BaseTypes.DOUBLE {
        constructor(length, decimals){
            super(length, decimals);
            if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);
            BaseTypes.DOUBLE.apply(this, arguments);
            if (this._length || this._unsigned || this._zerofill) {
                warn("Oracle does not support DOUBLE with options.");
                this._length = void 0;
                this.options.length = void 0;
                this._unsigned = void 0;
                this._zerofill = void 0;
            }
            this.key = "DOUBLE PRECISION";
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_BINARY_DOUBLE
            };
        }
        toSql() {
            return "BINARY_DOUBLE";
        }
    }
    class DATEONLY extends BaseTypes.DATEONLY {
        parse(value) {
            return moment(value).format("YYYY-MM-DD");
        }
        _sanitize(value) {
            if (value) {
                return moment(value).format("YYYY-MM-DD");
            }
            return value;
        }
        _stringify(date, options) {
            if (date) {
                const format = "YYYY/MM/DD";
                return options.escape(`TO_DATE('${date}','${format}')`);
            }
            return options.escape(date);
        }
        _getBindDef(oracledb) {
            return {
                type: oracledb.DB_TYPE_DATE
            };
        }
        _bindParam(value, options) {
            if (typeof value === "string") {
                return options.bindParam(new Date(value));
            }
            return options.bindParam(value);
        }
    }
    DATEONLY.prototype.escape = false;
    return {
        BOOLEAN,
        "DOUBLE PRECISION": DOUBLE,
        DOUBLE,
        STRING,
        TINYINT,
        SMALLINT,
        MEDIUMINT,
        BIGINT,
        NUMBER,
        INTEGER,
        FLOAT,
        UUID,
        DATEONLY,
        DATE,
        NOW,
        BLOB,
        ENUM,
        TEXT,
        CHAR,
        JSON: JSONTYPE,
        REAL,
        DECIMAL
    };
}; //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const wkx = __turbopack_context__.r("[project]/node_modules/wkx/lib/wkx.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const Validator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/validator-extras.js [app-route] (ecmascript)").validator;
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const warnings = {};
const { classToInvokable } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/class-to-invokable.js [app-route] (ecmascript)");
const { joinSQLFragments } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/join-sql-fragments.js [app-route] (ecmascript)");
class ABSTRACT {
    toString(options) {
        return this.toSql(options);
    }
    toSql() {
        return this.key;
    }
    stringify(value, options) {
        if (this._stringify) {
            return this._stringify(value, options);
        }
        return value;
    }
    bindParam(value, options) {
        if (this._bindParam) {
            return this._bindParam(value, options);
        }
        return options.bindParam(this.stringify(value, options));
    }
    static toString() {
        return this.name;
    }
    static warn(link, text) {
        if (!warnings[text]) {
            warnings[text] = true;
            logger.warn(`${text} 
>> Check: ${link}`);
        }
    }
    static extend(oldType) {
        return new this(oldType.options);
    }
}
ABSTRACT.prototype.dialectTypes = "";
class STRING extends ABSTRACT {
    constructor(length, binary){
        super();
        const options = typeof length === "object" && length || {
            length,
            binary
        };
        this.options = options;
        this._binary = options.binary;
        this._length = options.length || 255;
    }
    toSql() {
        return joinSQLFragments([
            `VARCHAR(${this._length})`,
            this._binary && "BINARY"
        ]);
    }
    validate(value) {
        if (Object.prototype.toString.call(value) !== "[object String]") {
            if (this.options.binary && Buffer.isBuffer(value) || typeof value === "number") {
                return true;
            }
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid string", value));
        }
        return true;
    }
    get BINARY() {
        this._binary = true;
        this.options.binary = true;
        return this;
    }
    static get BINARY() {
        return new this().BINARY;
    }
}
class CHAR extends STRING {
    constructor(length, binary){
        super(typeof length === "object" && length || {
            length,
            binary
        });
    }
    toSql() {
        return joinSQLFragments([
            `CHAR(${this._length})`,
            this._binary && "BINARY"
        ]);
    }
}
class TEXT extends ABSTRACT {
    constructor(length){
        super();
        const options = typeof length === "object" && length || {
            length
        };
        this.options = options;
        this._length = options.length || "";
    }
    toSql() {
        switch(this._length.toLowerCase()){
            case "tiny":
                return "TINYTEXT";
            case "medium":
                return "MEDIUMTEXT";
            case "long":
                return "LONGTEXT";
            default:
                return this.key;
        }
    }
    validate(value) {
        if (typeof value !== "string") {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid string", value));
        }
        return true;
    }
}
class CITEXT extends ABSTRACT {
    toSql() {
        return "CITEXT";
    }
    validate(value) {
        if (typeof value !== "string") {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid string", value));
        }
        return true;
    }
}
class NUMBER extends ABSTRACT {
    constructor(options = {}){
        super();
        if (typeof options === "number") {
            options = {
                length: options
            };
        }
        this.options = options;
        this._length = options.length;
        this._zerofill = options.zerofill;
        this._decimals = options.decimals;
        this._precision = options.precision;
        this._scale = options.scale;
        this._unsigned = options.unsigned;
    }
    toSql() {
        let result = this.key;
        if (this._length) {
            result += `(${this._length}`;
            if (typeof this._decimals === "number") {
                result += `,${this._decimals}`;
            }
            result += ")";
        }
        if (this._unsigned) {
            result += " UNSIGNED";
        }
        if (this._zerofill) {
            result += " ZEROFILL";
        }
        return result;
    }
    validate(value) {
        if (!Validator.isFloat(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
        }
        return true;
    }
    _stringify(number) {
        if (typeof number === "number" || typeof number === "bigint" || typeof number === "boolean" || number === null || number === void 0) {
            return number;
        }
        if (typeof number.toString === "function") {
            return number.toString();
        }
        return number;
    }
    get UNSIGNED() {
        this._unsigned = true;
        this.options.unsigned = true;
        return this;
    }
    get ZEROFILL() {
        this._zerofill = true;
        this.options.zerofill = true;
        return this;
    }
    static get UNSIGNED() {
        return new this().UNSIGNED;
    }
    static get ZEROFILL() {
        return new this().ZEROFILL;
    }
}
class INTEGER extends NUMBER {
    validate(value) {
        if (!Validator.isInt(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));
        }
        return true;
    }
}
class TINYINT extends INTEGER {
}
class SMALLINT extends INTEGER {
}
class MEDIUMINT extends INTEGER {
}
class BIGINT extends INTEGER {
}
class FLOAT extends NUMBER {
    constructor(length, decimals){
        super(typeof length === "object" && length || {
            length,
            decimals
        });
    }
    validate(value) {
        if (!Validator.isFloat(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid float", value));
        }
        return true;
    }
}
class REAL extends NUMBER {
    constructor(length, decimals){
        super(typeof length === "object" && length || {
            length,
            decimals
        });
    }
}
class DOUBLE extends NUMBER {
    constructor(length, decimals){
        super(typeof length === "object" && length || {
            length,
            decimals
        });
    }
}
class DECIMAL extends NUMBER {
    constructor(precision, scale){
        super(typeof precision === "object" && precision || {
            precision,
            scale
        });
    }
    toSql() {
        if (this._precision || this._scale) {
            return `DECIMAL(${[
                this._precision,
                this._scale
            ].filter(_.identity).join(",")})`;
        }
        return "DECIMAL";
    }
    validate(value) {
        if (!Validator.isDecimal(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid decimal", value));
        }
        return true;
    }
}
const protoExtensions = {
    escape: false,
    _value (value) {
        if (isNaN(value)) {
            return "NaN";
        }
        if (!isFinite(value)) {
            const sign = value < 0 ? "-" : "";
            return `${sign}Infinity`;
        }
        return value;
    },
    _stringify (value) {
        return `'${this._value(value)}'`;
    },
    _bindParam (value, options) {
        return options.bindParam(this._value(value));
    }
};
for (const floating of [
    FLOAT,
    DOUBLE,
    REAL
]){
    Object.assign(floating.prototype, protoExtensions);
}
class BOOLEAN extends ABSTRACT {
    toSql() {
        return "TINYINT(1)";
    }
    validate(value) {
        if (!Validator.isBoolean(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid boolean", value));
        }
        return true;
    }
    _sanitize(value) {
        if (value !== null && value !== void 0) {
            if (Buffer.isBuffer(value) && value.length === 1) {
                value = value[0];
            }
            const type = typeof value;
            if (type === "string") {
                return value === "true" ? true : value === "false" ? false : value;
            }
            if (type === "number") {
                return value === 1 ? true : value === 0 ? false : value;
            }
        }
        return value;
    }
}
BOOLEAN.parse = BOOLEAN.prototype._sanitize;
class TIME extends ABSTRACT {
    toSql() {
        return "TIME";
    }
}
class DATE extends ABSTRACT {
    constructor(length){
        super();
        const options = typeof length === "object" && length || {
            length
        };
        this.options = options;
        this._length = options.length || "";
    }
    toSql() {
        return "DATETIME";
    }
    validate(value) {
        if (!Validator.isDate(String(value))) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid date", value));
        }
        return true;
    }
    _sanitize(value, options) {
        if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {
            return new Date(value);
        }
        return value;
    }
    _isChanged(value, originalValue) {
        if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {
            return false;
        }
        if (!originalValue && !value && originalValue === value) {
            return false;
        }
        return true;
    }
    _applyTimezone(date, options) {
        if (options.timezone) {
            if (momentTz.tz.zone(options.timezone)) {
                return momentTz(date).tz(options.timezone);
            }
            return date = moment(date).utcOffset(options.timezone);
        }
        return momentTz(date);
    }
    _stringify(date, options) {
        if (!moment.isMoment(date)) {
            date = this._applyTimezone(date, options);
        }
        return date.format("YYYY-MM-DD HH:mm:ss.SSS Z");
    }
}
class DATEONLY extends ABSTRACT {
    toSql() {
        return "DATE";
    }
    _stringify(date) {
        return moment(date).format("YYYY-MM-DD");
    }
    _sanitize(value, options) {
        if ((!options || options && !options.raw) && !!value) {
            return moment(value).format("YYYY-MM-DD");
        }
        return value;
    }
    _isChanged(value, originalValue) {
        if (originalValue && !!value && originalValue === value) {
            return false;
        }
        if (!originalValue && !value && originalValue === value) {
            return false;
        }
        return true;
    }
}
class HSTORE extends ABSTRACT {
    validate(value) {
        if (!_.isPlainObject(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid hstore", value));
        }
        return true;
    }
}
class JSONTYPE extends ABSTRACT {
    validate() {
        return true;
    }
    _stringify(value) {
        return JSON.stringify(value);
    }
}
class JSONB extends JSONTYPE {
}
class NOW extends ABSTRACT {
}
class BLOB extends ABSTRACT {
    constructor(length){
        super();
        const options = typeof length === "object" && length || {
            length
        };
        this.options = options;
        this._length = options.length || "";
    }
    toSql() {
        switch(this._length.toLowerCase()){
            case "tiny":
                return "TINYBLOB";
            case "medium":
                return "MEDIUMBLOB";
            case "long":
                return "LONGBLOB";
            default:
                return this.key;
        }
    }
    validate(value) {
        if (typeof value !== "string" && !Buffer.isBuffer(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid blob", value));
        }
        return true;
    }
    _stringify(value) {
        if (!Buffer.isBuffer(value)) {
            if (Array.isArray(value)) {
                value = Buffer.from(value);
            } else {
                value = Buffer.from(value.toString());
            }
        }
        const hex = value.toString("hex");
        return this._hexify(hex);
    }
    _hexify(hex) {
        return `X'${hex}'`;
    }
    _bindParam(value, options) {
        if (!Buffer.isBuffer(value)) {
            if (Array.isArray(value)) {
                value = Buffer.from(value);
            } else {
                value = Buffer.from(value.toString());
            }
        }
        return options.bindParam(value);
    }
}
BLOB.prototype.escape = false;
class RANGE extends ABSTRACT {
    constructor(subtype){
        super();
        const options = _.isPlainObject(subtype) ? subtype : {
            subtype
        };
        if (!options.subtype) options.subtype = new INTEGER();
        if (typeof options.subtype === "function") {
            options.subtype = new options.subtype();
        }
        this._subtype = options.subtype.key;
        this.options = options;
    }
    validate(value) {
        if (!Array.isArray(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid range", value));
        }
        if (value.length !== 2) {
            throw new sequelizeErrors.ValidationError("A range must be an array with two elements");
        }
        return true;
    }
}
class UUID extends ABSTRACT {
    validate(value, options) {
        if (typeof value !== "string" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid uuid", value));
        }
        return true;
    }
}
class UUIDV1 extends ABSTRACT {
    validate(value, options) {
        if (typeof value !== "string" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid uuid", value));
        }
        return true;
    }
}
class UUIDV4 extends ABSTRACT {
    validate(value, options) {
        if (typeof value !== "string" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid uuidv4", value));
        }
        return true;
    }
}
class VIRTUAL extends ABSTRACT {
    constructor(ReturnType, fields){
        super();
        if (typeof ReturnType === "function") ReturnType = new ReturnType();
        this.returnType = ReturnType;
        this.fields = fields;
    }
}
class ENUM extends ABSTRACT {
    constructor(...args){
        super();
        const value = args[0];
        const options = typeof value === "object" && !Array.isArray(value) && value || {
            values: args.reduce((result, element)=>{
                return result.concat(Array.isArray(element) ? element : [
                    element
                ]);
            }, [])
        };
        this.values = options.values;
        this.options = options;
    }
    validate(value) {
        if (!this.values.includes(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid choice in %j", value, this.values));
        }
        return true;
    }
}
class ARRAY extends ABSTRACT {
    constructor(type){
        super();
        const options = _.isPlainObject(type) ? type : {
            type
        };
        this.options = options;
        this.type = typeof options.type === "function" ? new options.type() : options.type;
    }
    toSql() {
        return `${this.type.toSql()}[]`;
    }
    validate(value) {
        if (!Array.isArray(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid array", value));
        }
        return true;
    }
    static is(obj, type) {
        return obj instanceof ARRAY && obj.type instanceof type;
    }
}
class GEOMETRY extends ABSTRACT {
    constructor(type, srid){
        super();
        const options = _.isPlainObject(type) ? type : {
            type,
            srid
        };
        this.options = options;
        this.type = options.type;
        this.srid = options.srid;
    }
    _stringify(value, options) {
        return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
    }
    _bindParam(value, options) {
        return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
    }
}
GEOMETRY.prototype.escape = false;
class GEOGRAPHY extends ABSTRACT {
    constructor(type, srid){
        super();
        const options = _.isPlainObject(type) ? type : {
            type,
            srid
        };
        this.options = options;
        this.type = options.type;
        this.srid = options.srid;
    }
    _stringify(value, options) {
        return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
    }
    _bindParam(value, options) {
        return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;
    }
}
GEOGRAPHY.prototype.escape = false;
class CIDR extends ABSTRACT {
    validate(value) {
        if (typeof value !== "string" || !Validator.isIPRange(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid CIDR", value));
        }
        return true;
    }
}
class INET extends ABSTRACT {
    validate(value) {
        if (typeof value !== "string" || !Validator.isIP(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid INET", value));
        }
        return true;
    }
}
class MACADDR extends ABSTRACT {
    validate(value) {
        if (typeof value !== "string" || !Validator.isMACAddress(value)) {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid MACADDR", value));
        }
        return true;
    }
}
class TSVECTOR extends ABSTRACT {
    validate(value) {
        if (typeof value !== "string") {
            throw new sequelizeErrors.ValidationError(util.format("%j is not a valid string", value));
        }
        return true;
    }
}
const DataTypes = module.exports = {
    ABSTRACT,
    STRING,
    CHAR,
    TEXT,
    NUMBER,
    TINYINT,
    SMALLINT,
    MEDIUMINT,
    INTEGER,
    BIGINT,
    FLOAT,
    TIME,
    DATE,
    DATEONLY,
    BOOLEAN,
    NOW,
    BLOB,
    DECIMAL,
    NUMERIC: DECIMAL,
    UUID,
    UUIDV1,
    UUIDV4,
    HSTORE,
    JSON: JSONTYPE,
    JSONB,
    VIRTUAL,
    ARRAY,
    ENUM,
    RANGE,
    REAL,
    "DOUBLE PRECISION": DOUBLE,
    DOUBLE,
    GEOMETRY,
    GEOGRAPHY,
    CIDR,
    INET,
    MACADDR,
    CITEXT,
    TSVECTOR
};
_.each(DataTypes, (dataType, name)=>{
    if (!Object.prototype.hasOwnProperty.call(dataType, "key")) {
        dataType.types = {};
        dataType.key = dataType.prototype.key = name;
    }
});
const dialectMap = {};
dialectMap.postgres = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.mysql = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.mariadb = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mariadb/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.sqlite = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.mssql = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.db2 = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.snowflake = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/data-types.js [app-route] (ecmascript)")(DataTypes);
dialectMap.oracle = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/data-types.js [app-route] (ecmascript)")(DataTypes);
const dialectList = Object.values(dialectMap);
for (const dataTypes of dialectList){
    _.each(dataTypes, (DataType, key)=>{
        if (!DataType.key) {
            DataType.key = DataType.prototype.key = key;
        }
    });
}
for (const dataTypes of [
    DataTypes,
    ...dialectList
]){
    _.each(dataTypes, (DataType, key)=>{
        dataTypes[key] = classToInvokable(DataType);
    });
}
Object.assign(DataTypes, dialectMap); //# sourceMappingURL=data-types.js.map
}),
"[project]/node_modules/sequelize/lib/sql-string.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
const dataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
function arrayToList(array, timeZone, dialect, format2) {
    return array.reduce((sql, val, i)=>{
        if (i !== 0) {
            sql += ", ";
        }
        if (Array.isArray(val)) {
            sql += `(${arrayToList(val, timeZone, dialect, format2)})`;
        } else {
            sql += escape(val, timeZone, dialect, format2);
        }
        return sql;
    }, "");
}
exports.arrayToList = arrayToList;
function escape(val, timeZone, dialect, format2) {
    let prependN = false;
    if (val === void 0 || val === null) {
        return "NULL";
    }
    switch(typeof val){
        case "boolean":
            if ([
                "sqlite",
                "mssql",
                "oracle"
            ].includes(dialect)) {
                return +!!val;
            }
            return (!!val).toString();
        case "number":
        case "bigint":
            return val.toString();
        case "string":
            prependN = dialect === "mssql";
            break;
    }
    if (val instanceof Date) {
        val = dataTypes[dialect].DATE.prototype.stringify(val, {
            timezone: timeZone
        });
    }
    if (Buffer.isBuffer(val)) {
        if (dataTypes[dialect].BLOB) {
            return dataTypes[dialect].BLOB.prototype.stringify(val);
        }
        return dataTypes.BLOB.prototype.stringify(val);
    }
    if (Array.isArray(val)) {
        const partialEscape = (escVal)=>escape(escVal, timeZone, dialect, format2);
        if (dialect === "postgres" && !format2) {
            return dataTypes.ARRAY.prototype.stringify(val, {
                escape: partialEscape
            });
        }
        return arrayToList(val, timeZone, dialect, format2);
    }
    if (!val.replace) {
        throw new Error(`Invalid value ${logger.inspect(val)}`);
    }
    if ([
        "postgres",
        "sqlite",
        "mssql",
        "snowflake",
        "db2"
    ].includes(dialect)) {
        val = val.replace(/'/g, "''");
        if (dialect === "postgres") {
            val = val.replace(/\0/g, "\\0");
        }
    } else if (dialect === "oracle" && typeof val === "string") {
        if (val.startsWith("TO_TIMESTAMP_TZ") || val.startsWith("TO_DATE")) {
            const splitVal = val.split(/\(|\)/);
            if (splitVal.length !== 3 || splitVal[2] !== "") {
                throw new Error("Invalid SQL function call.");
            }
            const functionName = splitVal[0].trim();
            const insideParens = splitVal[1].trim();
            if (functionName !== "TO_TIMESTAMP_TZ" && functionName !== "TO_DATE") {
                throw new Error("Invalid SQL function call. Expected TO_TIMESTAMP_TZ or TO_DATE.");
            }
            const params = insideParens.split(",");
            if (params.length !== 2) {
                throw new Error("Unexpected input received.\nSequelize supports TO_TIMESTAMP_TZ or TO_DATE exclusively with a combination of value and format.");
            }
            const dateValue = params[0].trim().replace(/'/g, "");
            const formatValue = params[1].trim();
            if (functionName === "TO_TIMESTAMP_TZ") {
                const expectedFormat = "'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM'";
                if (formatValue !== expectedFormat) {
                    throw new Error(`Invalid format string for TO_TIMESTAMP_TZ. Expected format: ${expectedFormat}`);
                }
                const formattedDate = moment(dateValue).format("YYYY-MM-DD HH:mm:ss.SSS Z");
                if (formattedDate !== dateValue) {
                    throw new Error("Invalid date value for TO_TIMESTAMP_TZ. Expected format: 'YYYY-MM-DD HH:mm:ss.SSS Z'");
                }
            } else if (functionName === "TO_DATE") {
                const expectedFormat = "'YYYY/MM/DD'";
                if (formatValue !== expectedFormat) {
                    throw new Error(`Invalid format string for TO_DATE. Expected format: ${expectedFormat}`);
                }
                const formattedDate = moment(dateValue).format("YYYY-MM-DD");
                if (formattedDate !== dateValue) {
                    throw new Error("Invalid date value for TO_DATE. Expected format: 'YYYY-MM-DD'");
                }
            }
            return val;
        }
        val = val.replace(/'/g, "''");
    } else {
        val = val.replace(/[\0\n\r\b\t\\'"\x1a]/g, (s)=>{
            switch(s){
                case "\0":
                    return "\\0";
                case "\n":
                    return "\\n";
                case "\r":
                    return "\\r";
                case "\b":
                    return "\\b";
                case "	":
                    return "\\t";
                case "":
                    return "\\Z";
                default:
                    return `\\${s}`;
            }
        });
    }
    return `${(prependN ? "N'" : "'") + val}'`;
}
exports.escape = escape;
function format(sql, values, timeZone, dialect) {
    values = [].concat(values);
    if (typeof sql !== "string") {
        throw new Error(`Invalid SQL string provided: ${sql}`);
    }
    return sql.replace(/\?/g, (match)=>{
        if (!values.length) {
            return match;
        }
        return escape(values.shift(), timeZone, dialect, true);
    });
}
exports.format = format;
function formatNamedParameters(sql, values, timeZone, dialect) {
    return sql.replace(/:+(?!\d)(\w+)/g, (value, key)=>{
        if (dialect === "postgres" && value.slice(0, 2) === "::") {
            return value;
        }
        if (values[key] !== void 0) {
            return escape(values[key], timeZone, dialect, true);
        }
        throw new Error(`Named parameter "${value}" has no value in the given object.`);
    });
}
exports.formatNamedParameters = formatNamedParameters; //# sourceMappingURL=sql-string.js.map
}),
"[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    Op: ()=>Op,
    default: ()=>operators_default
});
const Op = {
    eq: Symbol.for("eq"),
    ne: Symbol.for("ne"),
    gte: Symbol.for("gte"),
    gt: Symbol.for("gt"),
    lte: Symbol.for("lte"),
    lt: Symbol.for("lt"),
    not: Symbol.for("not"),
    is: Symbol.for("is"),
    in: Symbol.for("in"),
    notIn: Symbol.for("notIn"),
    like: Symbol.for("like"),
    notLike: Symbol.for("notLike"),
    iLike: Symbol.for("iLike"),
    notILike: Symbol.for("notILike"),
    startsWith: Symbol.for("startsWith"),
    endsWith: Symbol.for("endsWith"),
    substring: Symbol.for("substring"),
    regexp: Symbol.for("regexp"),
    notRegexp: Symbol.for("notRegexp"),
    iRegexp: Symbol.for("iRegexp"),
    notIRegexp: Symbol.for("notIRegexp"),
    between: Symbol.for("between"),
    notBetween: Symbol.for("notBetween"),
    overlap: Symbol.for("overlap"),
    contains: Symbol.for("contains"),
    contained: Symbol.for("contained"),
    adjacent: Symbol.for("adjacent"),
    strictLeft: Symbol.for("strictLeft"),
    strictRight: Symbol.for("strictRight"),
    noExtendRight: Symbol.for("noExtendRight"),
    noExtendLeft: Symbol.for("noExtendLeft"),
    and: Symbol.for("and"),
    or: Symbol.for("or"),
    any: Symbol.for("any"),
    all: Symbol.for("all"),
    values: Symbol.for("values"),
    col: Symbol.for("col"),
    placeholder: Symbol.for("placeholder"),
    join: Symbol.for("join"),
    match: Symbol.for("match")
};
var operators_default = Op;
module.exports = Op; //# sourceMappingURL=operators.js.map
}),
"[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const SqlString = __turbopack_context__.r("[project]/node_modules/sequelize/lib/sql-string.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const baseIsNative = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsNative.js [app-route] (ecmascript)");
const uuidv1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)").v1;
const uuidv4 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)").v4;
const operators = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const operatorsSet = new Set(Object.values(operators));
let inflection = __turbopack_context__.r("[project]/node_modules/inflection/lib/inflection.js [app-route] (ecmascript)");
exports.classToInvokable = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/class-to-invokable.js [app-route] (ecmascript)").classToInvokable;
exports.joinSQLFragments = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/join-sql-fragments.js [app-route] (ecmascript)").joinSQLFragments;
function useInflection(_inflection) {
    inflection = _inflection;
}
exports.useInflection = useInflection;
function camelizeIf(str, condition) {
    let result = str;
    if (condition) {
        result = camelize(str);
    }
    return result;
}
exports.camelizeIf = camelizeIf;
function underscoredIf(str, condition) {
    let result = str;
    if (condition) {
        result = underscore(str);
    }
    return result;
}
exports.underscoredIf = underscoredIf;
function isPrimitive(val) {
    const type = typeof val;
    return [
        "string",
        "number",
        "boolean"
    ].includes(type);
}
exports.isPrimitive = isPrimitive;
function mergeDefaults(a, b) {
    return _.mergeWith(a, b, (objectValue, sourceValue)=>{
        if (!_.isPlainObject(objectValue) && objectValue !== void 0) {
            if (_.isFunction(objectValue) && baseIsNative(objectValue)) {
                return sourceValue || objectValue;
            }
            return objectValue;
        }
    });
}
exports.mergeDefaults = mergeDefaults;
function merge() {
    const result = {};
    for (const obj of arguments){
        _.forOwn(obj, (value, key)=>{
            if (value !== void 0) {
                if (!result[key]) {
                    result[key] = value;
                } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {
                    result[key] = merge(result[key], value);
                } else if (Array.isArray(value) && Array.isArray(result[key])) {
                    result[key] = value.concat(result[key]);
                } else {
                    result[key] = value;
                }
            }
        });
    }
    return result;
}
exports.merge = merge;
function spliceStr(str, index, count, add) {
    return str.slice(0, index) + add + str.slice(index + count);
}
exports.spliceStr = spliceStr;
function camelize(str) {
    return str.trim().replace(/[-_\s]+(.)?/g, (match, c)=>c.toUpperCase());
}
exports.camelize = camelize;
function underscore(str) {
    return inflection.underscore(str);
}
exports.underscore = underscore;
function singularize(str) {
    return inflection.singularize(str);
}
exports.singularize = singularize;
function pluralize(str) {
    return inflection.pluralize(str);
}
exports.pluralize = pluralize;
function format(arr, dialect) {
    const timeZone = null;
    return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);
}
exports.format = format;
function formatNamedParameters(sql, parameters, dialect) {
    const timeZone = null;
    return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);
}
exports.formatNamedParameters = formatNamedParameters;
function cloneDeep(obj, onlyPlain) {
    obj = obj || {};
    return _.cloneDeepWith(obj, (elem)=>{
        if (Array.isArray(elem) || _.isPlainObject(elem)) {
            return void 0;
        }
        if (onlyPlain || typeof elem === "object") {
            return elem;
        }
        if (elem && typeof elem.clone === "function") {
            return elem.clone();
        }
    });
}
exports.cloneDeep = cloneDeep;
function mapFinderOptions(options, Model) {
    if (options.attributes && Array.isArray(options.attributes)) {
        options.attributes = Model._injectDependentVirtualAttributes(options.attributes);
        options.attributes = options.attributes.filter((v)=>!Model._virtualAttributes.has(v));
    }
    mapOptionFieldNames(options, Model);
    return options;
}
exports.mapFinderOptions = mapFinderOptions;
function mapOptionFieldNames(options, Model) {
    if (Array.isArray(options.attributes)) {
        options.attributes = options.attributes.map((attr)=>{
            if (typeof attr !== "string") return attr;
            if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {
                return [
                    Model.rawAttributes[attr].field,
                    attr
                ];
            }
            return attr;
        });
    }
    if (options.where && _.isPlainObject(options.where)) {
        options.where = mapWhereFieldNames(options.where, Model);
    }
    return options;
}
exports.mapOptionFieldNames = mapOptionFieldNames;
function mapWhereFieldNames(attributes, Model) {
    if (attributes) {
        attributes = cloneDeep(attributes);
        getComplexKeys(attributes).forEach((attribute)=>{
            const rawAttribute = Model.rawAttributes[attribute];
            if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {
                attributes[rawAttribute.field] = attributes[attribute];
                delete attributes[attribute];
            }
            if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {
                attributes[attribute] = mapOptionFieldNames({
                    where: attributes[attribute]
                }, Model).where;
            }
            if (Array.isArray(attributes[attribute])) {
                attributes[attribute].forEach((where, index)=>{
                    if (_.isPlainObject(where)) {
                        attributes[attribute][index] = mapWhereFieldNames(where, Model);
                    }
                });
            }
        });
    }
    return attributes;
}
exports.mapWhereFieldNames = mapWhereFieldNames;
function mapValueFieldNames(dataValues, fields, Model) {
    const values = {};
    for (const attr of fields){
        if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {
            if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {
                values[Model.rawAttributes[attr].field] = dataValues[attr];
            } else {
                values[attr] = dataValues[attr];
            }
        }
    }
    return values;
}
exports.mapValueFieldNames = mapValueFieldNames;
function isColString(value) {
    return typeof value === "string" && value[0] === "$" && value[value.length - 1] === "$";
}
exports.isColString = isColString;
function canTreatArrayAsAnd(arr) {
    return arr.some((arg)=>_.isPlainObject(arg) || arg instanceof Where);
}
exports.canTreatArrayAsAnd = canTreatArrayAsAnd;
function combineTableNames(tableName1, tableName2) {
    return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;
}
exports.combineTableNames = combineTableNames;
function toDefaultValue(value, dialect) {
    if (typeof value === "function") {
        const tmp = value();
        if (tmp instanceof DataTypes.ABSTRACT) {
            return tmp.toSql();
        }
        return tmp;
    }
    if (value instanceof DataTypes.UUIDV1) {
        return uuidv1();
    }
    if (value instanceof DataTypes.UUIDV4) {
        return uuidv4();
    }
    if (value instanceof DataTypes.NOW) {
        return now(dialect);
    }
    if (Array.isArray(value)) {
        return value.slice();
    }
    if (_.isPlainObject(value)) {
        return __spreadValues({}, value);
    }
    return value;
}
exports.toDefaultValue = toDefaultValue;
function defaultValueSchemable(value) {
    if (value === void 0) {
        return false;
    }
    if (value instanceof DataTypes.NOW) {
        return false;
    }
    if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {
        return false;
    }
    return typeof value !== "function";
}
exports.defaultValueSchemable = defaultValueSchemable;
function removeNullValuesFromHash(hash, omitNull, options) {
    let result = hash;
    options = options || {};
    options.allowNull = options.allowNull || [];
    if (omitNull) {
        const _hash = {};
        _.forIn(hash, (val, key)=>{
            if (options.allowNull.includes(key) || key.endsWith("Id") || val !== null && val !== void 0) {
                _hash[key] = val;
            }
        });
        result = _hash;
    }
    return result;
}
exports.removeNullValuesFromHash = removeNullValuesFromHash;
const dialects = /* @__PURE__ */ new Set([
    "mariadb",
    "mysql",
    "postgres",
    "sqlite",
    "mssql",
    "db2",
    "oracle"
]);
function now(dialect) {
    const d = new Date();
    if (!dialects.has(dialect)) {
        d.setMilliseconds(0);
    }
    return d;
}
exports.now = now;
const TICK_CHAR = "`";
exports.TICK_CHAR = TICK_CHAR;
function addTicks(s, tickChar) {
    tickChar = tickChar || TICK_CHAR;
    return tickChar + removeTicks(s, tickChar) + tickChar;
}
exports.addTicks = addTicks;
function removeTicks(s, tickChar) {
    tickChar = tickChar || TICK_CHAR;
    return s.replace(new RegExp(tickChar, "g"), "");
}
exports.removeTicks = removeTicks;
function flattenObjectDeep(value) {
    if (!_.isPlainObject(value)) return value;
    const flattenedObj = {};
    function flattenObject(obj, subPath) {
        Object.keys(obj).forEach((key)=>{
            const pathToProperty = subPath ? `${subPath}.${key}` : key;
            if (typeof obj[key] === "object" && obj[key] !== null) {
                flattenObject(obj[key], pathToProperty);
            } else {
                flattenedObj[pathToProperty] = _.get(obj, key);
            }
        });
        return flattenedObj;
    }
    return flattenObject(value, void 0);
}
exports.flattenObjectDeep = flattenObjectDeep;
class SequelizeMethod {
}
exports.SequelizeMethod = SequelizeMethod;
class Fn extends SequelizeMethod {
    constructor(fn, args){
        super();
        this.fn = fn;
        this.args = args;
    }
    clone() {
        return new Fn(this.fn, this.args);
    }
}
exports.Fn = Fn;
class Col extends SequelizeMethod {
    constructor(col, ...args){
        super();
        if (args.length > 0) {
            col = args;
        }
        this.col = col;
    }
}
exports.Col = Col;
class Cast extends SequelizeMethod {
    constructor(val, type, json){
        super();
        this.val = val;
        this.type = (type || "").trim();
        this.json = json || false;
    }
}
exports.Cast = Cast;
class Literal extends SequelizeMethod {
    constructor(val){
        super();
        this.val = val;
    }
}
exports.Literal = Literal;
class Json extends SequelizeMethod {
    constructor(conditionsOrPath, value){
        super();
        if (_.isObject(conditionsOrPath)) {
            this.conditions = conditionsOrPath;
        } else {
            this.path = conditionsOrPath;
            if (value) {
                this.value = value;
            }
        }
    }
}
exports.Json = Json;
class Where extends SequelizeMethod {
    constructor(attribute, comparator, logic){
        super();
        if (logic === void 0) {
            logic = comparator;
            comparator = "=";
        }
        this.attribute = attribute;
        this.comparator = comparator;
        this.logic = logic;
    }
}
exports.Where = Where;
function getOperators(obj) {
    return Object.getOwnPropertySymbols(obj).filter((s)=>operatorsSet.has(s));
}
exports.getOperators = getOperators;
function getComplexKeys(obj) {
    return getOperators(obj).concat(Object.keys(obj));
}
exports.getComplexKeys = getComplexKeys;
function getComplexSize(obj) {
    return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;
}
exports.getComplexSize = getComplexSize;
function isWhereEmpty(obj) {
    return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;
}
exports.isWhereEmpty = isWhereEmpty;
function generateEnumName(tableName, columnName) {
    return `enum_${tableName}_${columnName}`;
}
exports.generateEnumName = generateEnumName;
function camelizeObjectKeys(obj) {
    const newObj = new Object();
    Object.keys(obj).forEach((key)=>{
        newObj[camelize(key)] = obj[key];
    });
    return newObj;
}
exports.camelizeObjectKeys = camelizeObjectKeys;
function defaults(object, ...sources) {
    object = Object(object);
    sources.forEach((source)=>{
        if (source) {
            source = Object(source);
            getComplexKeys(source).forEach((key)=>{
                const value = object[key];
                if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {
                    object[key] = source[key];
                }
            });
        }
    });
    return object;
}
exports.defaults = defaults;
function nameIndex(index, tableName) {
    if (tableName.tableName) tableName = tableName.tableName;
    if (!Object.prototype.hasOwnProperty.call(index, "name")) {
        const fields = index.fields.map((field)=>typeof field === "string" ? field : field.name || field.attribute);
        index.name = underscore(`${tableName}_${fields.join("_")}`);
    }
    return index;
}
exports.nameIndex = nameIndex;
function intersects(arr1, arr2) {
    return arr1.some((v)=>arr2.includes(v));
}
exports.intersects = intersects;
function safeStringifyJson(value) {
    return JSON.stringify(value, (key, value2)=>{
        if (typeof value2 === "bigint") {
            return String(value2);
        }
        return value2;
    });
}
exports.safeStringifyJson = safeStringifyJson; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/sequelize/lib/associations/helpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function checkNamingCollision(association) {
    if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {
        throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);
    }
}
exports.checkNamingCollision = checkNamingCollision;
function addForeignKeyConstraints(newAttribute, source, target, options, key) {
    if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {
        const primaryKeys = Object.keys(source.primaryKeys).map((primaryKeyAttribute)=>source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);
        if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {
            newAttribute.references = {
                model: source.getTableName(),
                key: key || primaryKeys[0]
            };
            newAttribute.onDelete = options.onDelete;
            newAttribute.onUpdate = options.onUpdate;
        }
    }
}
exports.addForeignKeyConstraints = addForeignKeyConstraints;
function mixinMethods(association, obj, methods, aliases) {
    aliases = aliases || {};
    for (const method of methods){
        if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {
            const realMethod = aliases[method] || method;
            obj[association.accessors[method]] = function() {
                return association[realMethod](this, ...Array.from(arguments));
            };
        }
    }
}
exports.mixinMethods = mixinMethods; //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { AssociationError } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
class Association {
    constructor(source, target, options = {}){
        this.source = source;
        this.target = target;
        this.options = options;
        this.scope = options.scope;
        this.isSelfAssociation = this.source === this.target;
        this.as = options.as;
        this.associationType = "";
        if (source.hasAlias(options.as)) {
            throw new AssociationError(`You have used the alias ${options.as} in two separate associations. Aliased associations must have unique aliases.`);
        }
    }
    toInstanceArray(input) {
        if (!Array.isArray(input)) {
            input = [
                input
            ];
        }
        return input.map((element)=>{
            if (element instanceof this.target) return element;
            const tmpInstance = {};
            tmpInstance[this.target.primaryKeyAttribute] = element;
            return this.target.build(tmpInstance, {
                isNewRecord: false
            });
        });
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.as;
    }
}
module.exports = Association; //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Helpers = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/helpers.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
class BelongsTo extends Association {
    constructor(source, target, options){
        super(source, target, options);
        this.associationType = "BelongsTo";
        this.isSingleAssociation = true;
        this.foreignKeyAttribute = {};
        if (this.as) {
            this.isAliased = true;
            this.options.name = {
                singular: this.as
            };
        } else {
            this.as = this.target.options.name.singular;
            this.options.name = this.target.options.name;
        }
        if (_.isObject(this.options.foreignKey)) {
            this.foreignKeyAttribute = this.options.foreignKey;
            this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
        } else if (this.options.foreignKey) {
            this.foreignKey = this.options.foreignKey;
        }
        if (!this.foreignKey) {
            this.foreignKey = Utils.camelize([
                this.as,
                this.target.primaryKeyAttribute
            ].join("_"));
        }
        this.identifier = this.foreignKey;
        if (this.source.rawAttributes[this.identifier]) {
            this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;
        }
        if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {
            throw new Error(`Unknown attribute "${this.options.targetKey}" passed as targetKey, define this attribute on model "${this.target.name}" first`);
        }
        this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;
        this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
        this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;
        this.targetIdentifier = this.targetKey;
        this.associationAccessor = this.as;
        this.options.useHooks = options.useHooks;
        const singular = _.upperFirst(this.options.name.singular);
        this.accessors = {
            get: `get${singular}`,
            set: `set${singular}`,
            create: `create${singular}`
        };
    }
    _injectAttributes() {
        const newAttributes = {
            [this.foreignKey]: __spreadValues({
                type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,
                allowNull: true
            }, this.foreignKeyAttribute)
        };
        if (this.options.constraints !== false) {
            const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
            this.options.onDelete = this.options.onDelete || (source.allowNull ? "SET NULL" : "NO ACTION");
            this.options.onUpdate = this.options.onUpdate || "CASCADE";
        }
        Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);
        Utils.mergeDefaults(this.source.rawAttributes, newAttributes);
        this.source.refreshAttributes();
        this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;
        Helpers.checkNamingCollision(this);
        return this;
    }
    mixin(obj) {
        const methods = [
            "get",
            "set",
            "create"
        ];
        Helpers.mixinMethods(this, obj, methods);
    }
    async get(instances, options) {
        const where = {};
        let Target = this.target;
        let instance;
        options = Utils.cloneDeep(options);
        if (Object.prototype.hasOwnProperty.call(options, "scope")) {
            if (!options.scope) {
                Target = Target.unscoped();
            } else {
                Target = Target.scope(options.scope);
            }
        }
        if (Object.prototype.hasOwnProperty.call(options, "schema")) {
            Target = Target.schema(options.schema, options.schemaDelimiter);
        }
        if (!Array.isArray(instances)) {
            instance = instances;
            instances = void 0;
        }
        if (instances) {
            where[this.targetKey] = {
                [Op.in]: instances.map((_instance)=>_instance.get(this.foreignKey))
            };
        } else {
            if (this.targetKeyIsPrimary && !options.where) {
                return Target.findByPk(instance.get(this.foreignKey), options);
            }
            where[this.targetKey] = instance.get(this.foreignKey);
            options.limit = null;
        }
        options.where = options.where ? {
            [Op.and]: [
                where,
                options.where
            ]
        } : where;
        if (instances) {
            const results = await Target.findAll(options);
            const result = {};
            for (const _instance of instances){
                result[_instance.get(this.foreignKey, {
                    raw: true
                })] = null;
            }
            for (const _instance of results){
                result[_instance.get(this.targetKey, {
                    raw: true
                })] = _instance;
            }
            return result;
        }
        return Target.findOne(options);
    }
    async set(sourceInstance, associatedInstance, options = {}) {
        let value = associatedInstance;
        if (associatedInstance instanceof this.target) {
            value = associatedInstance[this.targetKey];
        }
        sourceInstance.set(this.foreignKey, value);
        if (options.save === false) return;
        options = __spreadValues({
            fields: [
                this.foreignKey
            ],
            allowNull: [
                this.foreignKey
            ],
            association: true
        }, options);
        return await sourceInstance.save(options);
    }
    async create(sourceInstance, values, options) {
        values = values || {};
        options = options || {};
        const newAssociatedObject = await this.target.create(values, options);
        await sourceInstance[this.accessors.set](newAssociatedObject, options);
        return newAssociatedObject;
    }
    verifyAssociationAlias(alias) {
        if (typeof alias === "string") {
            return this.as === alias;
        }
        if (alias && alias.singular) {
            return this.as === alias.singular;
        }
        return !this.isAliased;
    }
}
module.exports = BelongsTo;
module.exports.BelongsTo = BelongsTo;
module.exports.default = BelongsTo; //# sourceMappingURL=belongs-to.js.map
}),
"[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Helpers = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/helpers.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
class HasMany extends Association {
    constructor(source, target, options){
        super(source, target, options);
        this.associationType = "HasMany";
        this.targetAssociation = null;
        this.sequelize = source.sequelize;
        this.isMultiAssociation = true;
        this.foreignKeyAttribute = {};
        if (this.options.through) {
            throw new Error("N:M associations are not supported with hasMany. Use belongsToMany instead");
        }
        if (this.isSelfAssociation) {
            this.targetAssociation = this;
        }
        if (this.as) {
            this.isAliased = true;
            if (_.isPlainObject(this.as)) {
                this.options.name = this.as;
                this.as = this.as.plural;
            } else {
                this.options.name = {
                    plural: this.as,
                    singular: Utils.singularize(this.as)
                };
            }
        } else {
            this.as = this.target.options.name.plural;
            this.options.name = this.target.options.name;
        }
        if (_.isObject(this.options.foreignKey)) {
            this.foreignKeyAttribute = this.options.foreignKey;
            this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
        } else if (this.options.foreignKey) {
            this.foreignKey = this.options.foreignKey;
        }
        if (!this.foreignKey) {
            this.foreignKey = Utils.camelize([
                this.source.options.name.singular,
                this.source.primaryKeyAttribute
            ].join("_"));
        }
        if (this.target.rawAttributes[this.foreignKey]) {
            this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
            this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
        }
        this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;
        if (this.source.rawAttributes[this.sourceKey]) {
            this.sourceKeyAttribute = this.sourceKey;
            this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
        } else {
            this.sourceKeyAttribute = this.source.primaryKeyAttribute;
            this.sourceKeyField = this.source.primaryKeyField;
        }
        const plural = _.upperFirst(this.options.name.plural);
        const singular = _.upperFirst(this.options.name.singular);
        this.associationAccessor = this.as;
        this.accessors = {
            get: `get${plural}`,
            set: `set${plural}`,
            addMultiple: `add${plural}`,
            add: `add${singular}`,
            create: `create${singular}`,
            remove: `remove${singular}`,
            removeMultiple: `remove${plural}`,
            hasSingle: `has${singular}`,
            hasAll: `has${plural}`,
            count: `count${plural}`
        };
    }
    _injectAttributes() {
        const newAttributes = {
            [this.foreignKey]: __spreadValues({
                type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,
                allowNull: true
            }, this.foreignKeyAttribute)
        };
        const constraintOptions = __spreadValues({}, this.options);
        if (this.options.constraints !== false) {
            const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
            constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? "SET NULL" : "CASCADE");
            constraintOptions.onUpdate = constraintOptions.onUpdate || "CASCADE";
        }
        Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);
        Utils.mergeDefaults(this.target.rawAttributes, newAttributes);
        this.target.refreshAttributes();
        this.source.refreshAttributes();
        this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
        this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
        this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
        Helpers.checkNamingCollision(this);
        return this;
    }
    mixin(obj) {
        const methods = [
            "get",
            "count",
            "hasSingle",
            "hasAll",
            "set",
            "add",
            "addMultiple",
            "remove",
            "removeMultiple",
            "create"
        ];
        const aliases = {
            hasSingle: "has",
            hasAll: "has",
            addMultiple: "add",
            removeMultiple: "remove"
        };
        Helpers.mixinMethods(this, obj, methods, aliases);
    }
    async get(instances, options = {}) {
        const where = {};
        let Model = this.target;
        let instance;
        let values;
        if (!Array.isArray(instances)) {
            instance = instances;
            instances = void 0;
        }
        options = __spreadValues({}, options);
        if (this.scope) {
            Object.assign(where, this.scope);
        }
        if (instances) {
            values = instances.map((_instance)=>_instance.get(this.sourceKey, {
                    raw: true
                }));
            if (options.limit && instances.length > 1) {
                options.groupedLimit = {
                    limit: options.limit,
                    on: this,
                    values
                };
                delete options.limit;
            } else {
                where[this.foreignKey] = {
                    [Op.in]: values
                };
                delete options.groupedLimit;
            }
        } else {
            where[this.foreignKey] = instance.get(this.sourceKey, {
                raw: true
            });
        }
        options.where = options.where ? {
            [Op.and]: [
                where,
                options.where
            ]
        } : where;
        if (Object.prototype.hasOwnProperty.call(options, "scope")) {
            if (!options.scope) {
                Model = Model.unscoped();
            } else {
                Model = Model.scope(options.scope);
            }
        }
        if (Object.prototype.hasOwnProperty.call(options, "schema")) {
            Model = Model.schema(options.schema, options.schemaDelimiter);
        }
        const results = await Model.findAll(options);
        if (instance) return results;
        const result = {};
        for (const _instance of instances){
            result[_instance.get(this.sourceKey, {
                raw: true
            })] = [];
        }
        for (const _instance of results){
            result[_instance.get(this.foreignKey, {
                raw: true
            })].push(_instance);
        }
        return result;
    }
    async count(instance, options) {
        options = Utils.cloneDeep(options);
        options.attributes = [
            [
                this.sequelize.fn("COUNT", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)),
                "count"
            ]
        ];
        options.raw = true;
        options.plain = true;
        const result = await this.get(instance, options);
        return parseInt(result.count, 10);
    }
    async has(sourceInstance, targetInstances, options) {
        const where = {};
        if (!Array.isArray(targetInstances)) {
            targetInstances = [
                targetInstances
            ];
        }
        options = __spreadProps(__spreadValues({}, options), {
            scope: false,
            attributes: [
                this.target.primaryKeyAttribute
            ],
            raw: true
        });
        where[Op.or] = targetInstances.map((instance)=>{
            if (instance instanceof this.target) {
                return instance.where();
            }
            return {
                [this.target.primaryKeyAttribute]: instance
            };
        });
        options.where = {
            [Op.and]: [
                where,
                options.where
            ]
        };
        const associatedObjects = await this.get(sourceInstance, options);
        return associatedObjects.length === targetInstances.length;
    }
    async set(sourceInstance, targetInstances, options) {
        if (targetInstances === null) {
            targetInstances = [];
        } else {
            targetInstances = this.toInstanceArray(targetInstances);
        }
        const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), {
            scope: false,
            raw: true
        }));
        const promises = [];
        const obsoleteAssociations = oldAssociations.filter((old)=>!targetInstances.find((obj)=>obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));
        const unassociatedObjects = targetInstances.filter((obj)=>!oldAssociations.find((old)=>obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));
        let updateWhere;
        let update;
        if (obsoleteAssociations.length > 0) {
            update = {};
            update[this.foreignKey] = null;
            updateWhere = {
                [this.target.primaryKeyAttribute]: obsoleteAssociations.map((associatedObject)=>associatedObject[this.target.primaryKeyAttribute])
            };
            promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {
                where: updateWhere
            })));
        }
        if (unassociatedObjects.length > 0) {
            updateWhere = {};
            update = {};
            update[this.foreignKey] = sourceInstance.get(this.sourceKey);
            Object.assign(update, this.scope);
            updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map((unassociatedObject)=>unassociatedObject[this.target.primaryKeyAttribute]);
            promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {
                where: updateWhere
            })));
        }
        await Promise.all(promises);
        return sourceInstance;
    }
    async add(sourceInstance, targetInstances, options = {}) {
        if (!targetInstances) return Promise.resolve();
        targetInstances = this.toInstanceArray(targetInstances);
        const update = __spreadValues({
            [this.foreignKey]: sourceInstance.get(this.sourceKey)
        }, this.scope);
        const where = {
            [this.target.primaryKeyAttribute]: targetInstances.map((unassociatedObject)=>unassociatedObject.get(this.target.primaryKeyAttribute))
        };
        await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {
            where
        }));
        return sourceInstance;
    }
    async remove(sourceInstance, targetInstances, options = {}) {
        const update = {
            [this.foreignKey]: null
        };
        targetInstances = this.toInstanceArray(targetInstances);
        const where = {
            [this.foreignKey]: sourceInstance.get(this.sourceKey),
            [this.target.primaryKeyAttribute]: targetInstances.map((targetInstance)=>targetInstance.get(this.target.primaryKeyAttribute))
        };
        await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {
            where
        }));
        return this;
    }
    async create(sourceInstance, values, options = {}) {
        if (Array.isArray(options)) {
            options = {
                fields: options
            };
        }
        if (values === void 0) {
            values = {};
        }
        if (this.scope) {
            for (const attribute of Object.keys(this.scope)){
                values[attribute] = this.scope[attribute];
                if (options.fields) options.fields.push(attribute);
            }
        }
        values[this.foreignKey] = sourceInstance.get(this.sourceKey);
        if (options.fields) options.fields.push(this.foreignKey);
        return await this.target.create(values, options);
    }
    verifyAssociationAlias(alias) {
        if (typeof alias === "string") {
            return this.as === alias;
        }
        if (alias && alias.plural) {
            return this.as === alias.plural;
        }
        return !this.isAliased;
    }
}
module.exports = HasMany;
module.exports.HasMany = HasMany;
module.exports.default = HasMany; //# sourceMappingURL=has-many.js.map
}),
"[project]/node_modules/sequelize/lib/associations/has-one.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Helpers = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/helpers.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
class HasOne extends Association {
    constructor(source, target, options){
        super(source, target, options);
        this.associationType = "HasOne";
        this.isSingleAssociation = true;
        this.foreignKeyAttribute = {};
        if (this.as) {
            this.isAliased = true;
            this.options.name = {
                singular: this.as
            };
        } else {
            this.as = this.target.options.name.singular;
            this.options.name = this.target.options.name;
        }
        if (_.isObject(this.options.foreignKey)) {
            this.foreignKeyAttribute = this.options.foreignKey;
            this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
        } else if (this.options.foreignKey) {
            this.foreignKey = this.options.foreignKey;
        }
        if (!this.foreignKey) {
            this.foreignKey = Utils.camelize([
                Utils.singularize(this.options.as || this.source.name),
                this.source.primaryKeyAttribute
            ].join("_"));
        }
        if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {
            throw new Error(`Unknown attribute "${this.options.sourceKey}" passed as sourceKey, define this attribute on model "${this.source.name}" first`);
        }
        this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;
        this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
        this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;
        this.associationAccessor = this.as;
        this.options.useHooks = options.useHooks;
        if (this.target.rawAttributes[this.foreignKey]) {
            this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
        }
        const singular = _.upperFirst(this.options.name.singular);
        this.accessors = {
            get: `get${singular}`,
            set: `set${singular}`,
            create: `create${singular}`
        };
    }
    _injectAttributes() {
        const newAttributes = {
            [this.foreignKey]: __spreadValues({
                type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,
                allowNull: true
            }, this.foreignKeyAttribute)
        };
        if (this.options.constraints !== false) {
            const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];
            this.options.onDelete = this.options.onDelete || (target.allowNull ? "SET NULL" : "CASCADE");
            this.options.onUpdate = this.options.onUpdate || "CASCADE";
        }
        Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);
        Utils.mergeDefaults(this.target.rawAttributes, newAttributes);
        this.target.refreshAttributes();
        this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;
        Helpers.checkNamingCollision(this);
        return this;
    }
    mixin(obj) {
        const methods = [
            "get",
            "set",
            "create"
        ];
        Helpers.mixinMethods(this, obj, methods);
    }
    async get(instances, options) {
        const where = {};
        let Target = this.target;
        let instance;
        options = Utils.cloneDeep(options);
        if (Object.prototype.hasOwnProperty.call(options, "scope")) {
            if (!options.scope) {
                Target = Target.unscoped();
            } else {
                Target = Target.scope(options.scope);
            }
        }
        if (Object.prototype.hasOwnProperty.call(options, "schema")) {
            Target = Target.schema(options.schema, options.schemaDelimiter);
        }
        if (!Array.isArray(instances)) {
            instance = instances;
            instances = void 0;
        }
        if (instances) {
            where[this.foreignKey] = {
                [Op.in]: instances.map((_instance)=>_instance.get(this.sourceKey))
            };
        } else {
            where[this.foreignKey] = instance.get(this.sourceKey);
        }
        if (this.scope) {
            Object.assign(where, this.scope);
        }
        options.where = options.where ? {
            [Op.and]: [
                where,
                options.where
            ]
        } : where;
        if (instances) {
            const results = await Target.findAll(options);
            const result = {};
            for (const _instance of instances){
                result[_instance.get(this.sourceKey, {
                    raw: true
                })] = null;
            }
            for (const _instance of results){
                result[_instance.get(this.foreignKey, {
                    raw: true
                })] = _instance;
            }
            return result;
        }
        return Target.findOne(options);
    }
    async set(sourceInstance, associatedInstance, options) {
        options = __spreadProps(__spreadValues({}, options), {
            scope: false
        });
        const oldInstance = await sourceInstance[this.accessors.get](options);
        const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every((attribute)=>oldInstance.get(attribute, {
                raw: true
            }) === (associatedInstance.get ? associatedInstance.get(attribute, {
                raw: true
            }) : associatedInstance));
        if (oldInstance && !alreadyAssociated) {
            oldInstance[this.foreignKey] = null;
            await oldInstance.save(__spreadProps(__spreadValues({}, options), {
                fields: [
                    this.foreignKey
                ],
                allowNull: [
                    this.foreignKey
                ],
                association: true
            }));
        }
        if (associatedInstance && !alreadyAssociated) {
            if (!(associatedInstance instanceof this.target)) {
                const tmpInstance = {};
                tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;
                associatedInstance = this.target.build(tmpInstance, {
                    isNewRecord: false
                });
            }
            Object.assign(associatedInstance, this.scope);
            associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));
            return associatedInstance.save(options);
        }
        return null;
    }
    async create(sourceInstance, values, options) {
        values = values || {};
        options = options || {};
        if (this.scope) {
            for (const attribute of Object.keys(this.scope)){
                values[attribute] = this.scope[attribute];
                if (options.fields) {
                    options.fields.push(attribute);
                }
            }
        }
        values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);
        if (options.fields) {
            options.fields.push(this.foreignKey);
        }
        return await this.target.create(values, options);
    }
    verifyAssociationAlias(alias) {
        if (typeof alias === "string") {
            return this.as === alias;
        }
        if (alias && alias.singular) {
            return this.as === alias.singular;
        }
        return !this.isAliased;
    }
}
module.exports = HasOne; //# sourceMappingURL=has-one.js.map
}),
"[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Helpers = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/helpers.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
const HasMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
const HasOne = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-one.js [app-route] (ecmascript)");
const AssociationError = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)").AssociationError;
const EmptyResultError = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)").EmptyResultError;
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
class BelongsToMany extends Association {
    constructor(source, target, options){
        super(source, target, options);
        if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {
            throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);
        }
        if (!this.options.through.model) {
            this.options.through = {
                model: options.through
            };
        }
        this.associationType = "BelongsToMany";
        this.targetAssociation = null;
        this.sequelize = source.sequelize;
        this.through = __spreadValues({}, this.options.through);
        this.isMultiAssociation = true;
        this.doubleLinked = false;
        if (!this.as && this.isSelfAssociation) {
            throw new AssociationError("'as' must be defined for many-to-many self-associations");
        }
        if (this.as) {
            this.isAliased = true;
            if (_.isPlainObject(this.as)) {
                this.options.name = this.as;
                this.as = this.as.plural;
            } else {
                this.options.name = {
                    plural: this.as,
                    singular: Utils.singularize(this.as)
                };
            }
        } else {
            this.as = this.target.options.name.plural;
            this.options.name = this.target.options.name;
        }
        this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);
        if (this.isSelfAssociation) {
            this.targetAssociation = this;
        }
        _.each(this.target.associations, (association)=>{
            if (association.associationType !== "BelongsToMany") return;
            if (association.target !== this.source) return;
            if (this.options.through.model === association.options.through.model) {
                this.paired = association;
                association.paired = this;
            }
        });
        this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;
        this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;
        if (this.options.targetKey) {
            this.targetKey = this.options.targetKey;
            this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
        } else {
            this.targetKeyDefault = true;
            this.targetKey = this.target.primaryKeyAttribute;
            this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;
        }
        this._createForeignAndOtherKeys();
        if (typeof this.through.model === "string") {
            if (!this.sequelize.isDefined(this.through.model)) {
                this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {
                    tableName: this.through.model,
                    indexes: [],
                    paranoid: this.through.paranoid ? this.through.paranoid : false,
                    validate: {}
                }));
            } else {
                this.through.model = this.sequelize.model(this.through.model);
            }
        }
        Object.assign(this.options, _.pick(this.through.model.options, [
            "timestamps",
            "createdAt",
            "updatedAt",
            "deletedAt",
            "paranoid"
        ]));
        if (this.paired) {
            let needInjectPaired = false;
            if (this.targetKeyDefault) {
                this.targetKey = this.paired.sourceKey;
                this.targetKeyField = this.paired.sourceKeyField;
                this._createForeignAndOtherKeys();
            }
            if (this.paired.targetKeyDefault) {
                if (this.paired.targetKey !== this.sourceKey) {
                    delete this.through.model.rawAttributes[this.paired.otherKey];
                    this.paired.targetKey = this.sourceKey;
                    this.paired.targetKeyField = this.sourceKeyField;
                    this.paired._createForeignAndOtherKeys();
                    needInjectPaired = true;
                }
            }
            if (this.otherKeyDefault) {
                this.otherKey = this.paired.foreignKey;
            }
            if (this.paired.otherKeyDefault) {
                if (this.paired.otherKey !== this.foreignKey) {
                    delete this.through.model.rawAttributes[this.paired.otherKey];
                    this.paired.otherKey = this.foreignKey;
                    needInjectPaired = true;
                }
            }
            if (needInjectPaired) {
                this.paired._injectAttributes();
            }
        }
        if (this.through) {
            this.throughModel = this.through.model;
        }
        this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;
        this.associationAccessor = this.as;
        const plural = _.upperFirst(this.options.name.plural);
        const singular = _.upperFirst(this.options.name.singular);
        this.accessors = {
            get: `get${plural}`,
            set: `set${plural}`,
            addMultiple: `add${plural}`,
            add: `add${singular}`,
            create: `create${singular}`,
            remove: `remove${singular}`,
            removeMultiple: `remove${plural}`,
            hasSingle: `has${singular}`,
            hasAll: `has${plural}`,
            count: `count${plural}`
        };
    }
    _createForeignAndOtherKeys() {
        if (_.isObject(this.options.foreignKey)) {
            this.foreignKeyAttribute = this.options.foreignKey;
            this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;
        } else {
            this.foreignKeyAttribute = {};
            this.foreignKey = this.options.foreignKey || Utils.camelize([
                this.source.options.name.singular,
                this.sourceKey
            ].join("_"));
        }
        if (_.isObject(this.options.otherKey)) {
            this.otherKeyAttribute = this.options.otherKey;
            this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;
        } else {
            if (!this.options.otherKey) {
                this.otherKeyDefault = true;
            }
            this.otherKeyAttribute = {};
            this.otherKey = this.options.otherKey || Utils.camelize([
                this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,
                this.targetKey
            ].join("_"));
        }
    }
    _injectAttributes() {
        this.identifier = this.foreignKey;
        this.foreignIdentifier = this.otherKey;
        _.each(this.through.model.rawAttributes, (attribute, attributeName)=>{
            if (attribute.primaryKey === true && attribute._autoGenerated === true) {
                if ([
                    this.foreignKey,
                    this.otherKey
                ].includes(attributeName)) {
                    attribute.primaryKey = false;
                } else {
                    delete this.through.model.rawAttributes[attributeName];
                }
                this.primaryKeyDeleted = true;
            }
        });
        const sourceKey = this.source.rawAttributes[this.sourceKey];
        const sourceKeyType = sourceKey.type;
        const sourceKeyField = this.sourceKeyField;
        const targetKey = this.target.rawAttributes[this.targetKey];
        const targetKeyType = targetKey.type;
        const targetKeyField = this.targetKeyField;
        const sourceAttribute = __spreadValues({
            type: sourceKeyType
        }, this.foreignKeyAttribute);
        const targetAttribute = __spreadValues({
            type: targetKeyType
        }, this.otherKeyAttribute);
        if (this.primaryKeyDeleted === true) {
            targetAttribute.primaryKey = sourceAttribute.primaryKey = true;
        } else if (this.through.unique !== false) {
            let uniqueKey;
            if (typeof this.options.uniqueKey === "string" && this.options.uniqueKey !== "") {
                uniqueKey = this.options.uniqueKey;
            } else {
                uniqueKey = [
                    this.through.model.tableName,
                    this.foreignKey,
                    this.otherKey,
                    "unique"
                ].join("_");
            }
            targetAttribute.unique = sourceAttribute.unique = uniqueKey;
        }
        if (!this.through.model.rawAttributes[this.foreignKey]) {
            this.through.model.rawAttributes[this.foreignKey] = {
                _autoGenerated: true
            };
        }
        if (!this.through.model.rawAttributes[this.otherKey]) {
            this.through.model.rawAttributes[this.otherKey] = {
                _autoGenerated: true
            };
        }
        if (this.options.constraints !== false) {
            sourceAttribute.references = {
                model: this.source.getTableName(),
                key: sourceKeyField
            };
            sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;
            sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;
            if (!sourceAttribute.onDelete) sourceAttribute.onDelete = "CASCADE";
            if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = "CASCADE";
            targetAttribute.references = {
                model: this.target.getTableName(),
                key: targetKeyField
            };
            targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;
            targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;
            if (!targetAttribute.onDelete) targetAttribute.onDelete = "CASCADE";
            if (!targetAttribute.onUpdate) targetAttribute.onUpdate = "CASCADE";
        }
        Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);
        Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);
        this.through.model.refreshAttributes();
        this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;
        this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;
        if (this.options.sequelize.options.dialect === "db2" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {
            this.source.rawAttributes[this.sourceKey].unique = true;
        }
        if (this.paired && !this.paired.foreignIdentifierField) {
            this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;
        }
        this.toSource = new BelongsTo(this.through.model, this.source, {
            foreignKey: this.foreignKey
        });
        this.manyFromSource = new HasMany(this.source, this.through.model, {
            foreignKey: this.foreignKey
        });
        this.oneFromSource = new HasOne(this.source, this.through.model, {
            foreignKey: this.foreignKey,
            sourceKey: this.sourceKey,
            as: this.through.model.name
        });
        this.toTarget = new BelongsTo(this.through.model, this.target, {
            foreignKey: this.otherKey
        });
        this.manyFromTarget = new HasMany(this.target, this.through.model, {
            foreignKey: this.otherKey
        });
        this.oneFromTarget = new HasOne(this.target, this.through.model, {
            foreignKey: this.otherKey,
            sourceKey: this.targetKey,
            as: this.through.model.name
        });
        if (this.paired && this.paired.otherKeyDefault) {
            this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {
                foreignKey: this.paired.otherKey
            });
            this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {
                foreignKey: this.paired.otherKey,
                sourceKey: this.paired.targetKey,
                as: this.paired.through.model.name
            });
        }
        Helpers.checkNamingCollision(this);
        return this;
    }
    mixin(obj) {
        const methods = [
            "get",
            "count",
            "hasSingle",
            "hasAll",
            "set",
            "add",
            "addMultiple",
            "remove",
            "removeMultiple",
            "create"
        ];
        const aliases = {
            hasSingle: "has",
            hasAll: "has",
            addMultiple: "add",
            removeMultiple: "remove"
        };
        Helpers.mixinMethods(this, obj, methods, aliases);
    }
    async get(instance, options) {
        options = Utils.cloneDeep(options) || {};
        const through = this.through;
        let scopeWhere;
        let throughWhere;
        if (this.scope) {
            scopeWhere = __spreadValues({}, this.scope);
        }
        options.where = {
            [Op.and]: [
                scopeWhere,
                options.where
            ]
        };
        if (Object(through.model) === through.model) {
            throughWhere = {};
            throughWhere[this.foreignKey] = instance.get(this.sourceKey);
            if (through.scope) {
                Object.assign(throughWhere, through.scope);
            }
            if (options.through && options.through.where) {
                throughWhere = {
                    [Op.and]: [
                        throughWhere,
                        options.through.where
                    ]
                };
            }
            options.include = options.include || [];
            options.include.push({
                association: this.oneFromTarget,
                attributes: options.joinTableAttributes,
                required: true,
                paranoid: _.get(options.through, "paranoid", true),
                where: throughWhere
            });
        }
        let model = this.target;
        if (Object.prototype.hasOwnProperty.call(options, "scope")) {
            if (!options.scope) {
                model = model.unscoped();
            } else {
                model = model.scope(options.scope);
            }
        }
        if (Object.prototype.hasOwnProperty.call(options, "schema")) {
            model = model.schema(options.schema, options.schemaDelimiter);
        }
        return model.findAll(options);
    }
    async count(instance, options) {
        const sequelize = this.target.sequelize;
        options = Utils.cloneDeep(options);
        options.attributes = [
            [
                sequelize.fn("COUNT", sequelize.col([
                    this.target.name,
                    this.targetKeyField
                ].join("."))),
                "count"
            ]
        ];
        options.joinTableAttributes = [];
        options.raw = true;
        options.plain = true;
        const result = await this.get(instance, options);
        return parseInt(result.count, 10);
    }
    async has(sourceInstance, instances, options) {
        if (!Array.isArray(instances)) {
            instances = [
                instances
            ];
        }
        options = __spreadProps(__spreadValues({
            raw: true
        }, options), {
            scope: false,
            attributes: [
                this.targetKey
            ],
            joinTableAttributes: []
        });
        const instancePrimaryKeys = instances.map((instance)=>{
            if (instance instanceof this.target) {
                return instance.where();
            }
            return {
                [this.targetKey]: instance
            };
        });
        options.where = {
            [Op.and]: [
                {
                    [Op.or]: instancePrimaryKeys
                },
                options.where
            ]
        };
        const associatedObjects = await this.get(sourceInstance, options);
        return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b)=>_.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;
    }
    async set(sourceInstance, newAssociatedObjects, options) {
        options = options || {};
        const sourceKey = this.sourceKey;
        const targetKey = this.targetKey;
        const identifier = this.identifier;
        const foreignIdentifier = this.foreignIdentifier;
        if (newAssociatedObjects === null) {
            newAssociatedObjects = [];
        } else {
            newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);
        }
        const where = __spreadValues({
            [identifier]: sourceInstance.get(sourceKey)
        }, this.through.scope);
        const updateAssociations = (currentRows)=>{
            const obsoleteAssociations = [];
            const promises = [];
            const defaultAttributes = options.through || {};
            const unassociatedObjects = newAssociatedObjects.filter((obj)=>!currentRows.some((currentRow)=>currentRow[foreignIdentifier] === obj.get(targetKey)));
            for (const currentRow of currentRows){
                const newObj = newAssociatedObjects.find((obj)=>currentRow[foreignIdentifier] === obj.get(targetKey));
                if (!newObj) {
                    obsoleteAssociations.push(currentRow);
                } else {
                    let throughAttributes = newObj[this.through.model.name];
                    if (throughAttributes instanceof this.through.model) {
                        throughAttributes = {};
                    }
                    const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);
                    if (Object.keys(attributes).length) {
                        promises.push(this.through.model.update(attributes, Object.assign(options, {
                            where: {
                                [identifier]: sourceInstance.get(sourceKey),
                                [foreignIdentifier]: newObj.get(targetKey)
                            }
                        })));
                    }
                }
            }
            if (obsoleteAssociations.length > 0) {
                promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {
                    where: __spreadValues({
                        [identifier]: sourceInstance.get(sourceKey),
                        [foreignIdentifier]: obsoleteAssociations.map((obsoleteAssociation)=>obsoleteAssociation[foreignIdentifier])
                    }, this.through.scope)
                })));
            }
            if (unassociatedObjects.length > 0) {
                const bulk = unassociatedObjects.map((unassociatedObject)=>{
                    return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {
                        [identifier]: sourceInstance.get(sourceKey),
                        [foreignIdentifier]: unassociatedObject.get(targetKey)
                    }), this.through.scope);
                });
                promises.push(this.through.model.bulkCreate(bulk, __spreadValues({
                    validate: true
                }, options)));
            }
            return Promise.all(promises);
        };
        try {
            const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), {
                where,
                raw: true
            }));
            return await updateAssociations(currentRows);
        } catch (error) {
            if (error instanceof EmptyResultError) return updateAssociations([]);
            throw error;
        }
    }
    async add(sourceInstance, newInstances, options) {
        if (!newInstances) return Promise.resolve();
        options = __spreadValues({}, options);
        const association = this;
        const sourceKey = association.sourceKey;
        const targetKey = association.targetKey;
        const identifier = association.identifier;
        const foreignIdentifier = association.foreignIdentifier;
        const defaultAttributes = options.through || {};
        newInstances = association.toInstanceArray(newInstances);
        const where = __spreadValues({
            [identifier]: sourceInstance.get(sourceKey),
            [foreignIdentifier]: newInstances.map((newInstance)=>newInstance.get(targetKey))
        }, association.through.scope);
        const updateAssociations = (currentRows)=>{
            const promises = [];
            const unassociatedObjects = [];
            const changedAssociations = [];
            for (const obj of newInstances){
                const existingAssociation = currentRows && currentRows.find((current)=>current[foreignIdentifier] === obj.get(targetKey));
                if (!existingAssociation) {
                    unassociatedObjects.push(obj);
                } else {
                    const throughAttributes = obj[association.through.model.name];
                    const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);
                    if (Object.keys(attributes).some((attribute)=>attributes[attribute] !== existingAssociation[attribute])) {
                        changedAssociations.push(obj);
                    }
                }
            }
            if (unassociatedObjects.length > 0) {
                const bulk = unassociatedObjects.map((unassociatedObject)=>{
                    const throughAttributes = unassociatedObject[association.through.model.name];
                    const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);
                    attributes[identifier] = sourceInstance.get(sourceKey);
                    attributes[foreignIdentifier] = unassociatedObject.get(targetKey);
                    Object.assign(attributes, association.through.scope);
                    return attributes;
                });
                promises.push(association.through.model.bulkCreate(bulk, __spreadValues({
                    validate: true
                }, options)));
            }
            for (const assoc of changedAssociations){
                let throughAttributes = assoc[association.through.model.name];
                const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);
                if (throughAttributes instanceof association.through.model) {
                    throughAttributes = {};
                }
                promises.push(association.through.model.update(attributes, Object.assign(options, {
                    where: {
                        [identifier]: sourceInstance.get(sourceKey),
                        [foreignIdentifier]: assoc.get(targetKey)
                    }
                })));
            }
            return Promise.all(promises);
        };
        try {
            const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), {
                where,
                raw: true
            }));
            const [associations] = await updateAssociations(currentRows);
            return associations;
        } catch (error) {
            if (error instanceof EmptyResultError) return updateAssociations();
            throw error;
        }
    }
    remove(sourceInstance, oldAssociatedObjects, options) {
        const association = this;
        options = options || {};
        oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);
        const where = {
            [association.identifier]: sourceInstance.get(association.sourceKey),
            [association.foreignIdentifier]: oldAssociatedObjects.map((newInstance)=>newInstance.get(association.targetKey))
        };
        return association.through.model.destroy(__spreadProps(__spreadValues({}, options), {
            where
        }));
    }
    async create(sourceInstance, values, options) {
        const association = this;
        options = options || {};
        values = values || {};
        if (Array.isArray(options)) {
            options = {
                fields: options
            };
        }
        if (association.scope) {
            Object.assign(values, association.scope);
            if (options.fields) {
                options.fields = options.fields.concat(Object.keys(association.scope));
            }
        }
        const newAssociatedObject = await association.target.create(values, options);
        await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [
            "fields"
        ]));
        return newAssociatedObject;
    }
    verifyAssociationAlias(alias) {
        if (typeof alias === "string") {
            return this.as === alias;
        }
        if (alias && alias.plural) {
            return this.as === alias.plural;
        }
        return !this.isAliased;
    }
}
module.exports = BelongsToMany;
module.exports.BelongsToMany = BelongsToMany;
module.exports.default = BelongsToMany; //# sourceMappingURL=belongs-to-many.js.map
}),
"[project]/node_modules/sequelize/lib/instance-validator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const sequelizeError = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
const validator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/validator-extras.js [app-route] (ecmascript)").validator;
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
class InstanceValidator {
    constructor(modelInstance, options){
        options = __spreadValues({
            hooks: true
        }, options);
        if (options.fields && !options.skip) {
            options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
        } else {
            options.skip = options.skip || [];
        }
        this.options = options;
        this.modelInstance = modelInstance;
        this.validator = validator;
        this.errors = [];
        this.inProgress = false;
    }
    async _validate() {
        if (this.inProgress) throw new Error("Validations already in progress.");
        this.inProgress = true;
        await Promise.all([
            this._perAttributeValidators(),
            this._customValidators()
        ]);
        if (this.errors.length) {
            throw new sequelizeError.ValidationError(null, this.errors);
        }
    }
    async validate() {
        return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());
    }
    async _validateAndRunHooks() {
        const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
        await runHooks("beforeValidate", this.modelInstance, this.options);
        try {
            await this._validate();
        } catch (error) {
            const newError = await runHooks("validationFailed", this.modelInstance, this.options, error);
            throw newError || error;
        }
        await runHooks("afterValidate", this.modelInstance, this.options);
        return this.modelInstance;
    }
    async _perAttributeValidators() {
        const validators = [];
        _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field)=>{
            if (this.options.skip.includes(field)) {
                return;
            }
            const value = this.modelInstance.dataValues[field];
            if (value instanceof Utils.SequelizeMethod) {
                return;
            }
            if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
                this._validateSchema(rawAttribute, field, value);
            }
            if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {
                validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));
            }
        });
        return await Promise.all(validators);
    }
    async _customValidators() {
        const validators = [];
        _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType)=>{
            if (this.options.skip.includes(validatorType)) {
                return;
            }
            const valprom = this._invokeCustomValidator(validator2, validatorType).catch(()=>{});
            validators.push(valprom);
        });
        return await Promise.all(validators);
    }
    async _singleAttrValidate(value, field, allowNull) {
        if ((value === null || value === void 0) && !allowNull) {
            return;
        }
        const validators = [];
        _.forIn(this.modelInstance.validators[field], (test, validatorType)=>{
            if ([
                "isUrl",
                "isURL",
                "isEmail"
            ].includes(validatorType)) {
                if (typeof test === "object" && test !== null && test.msg) {
                    test = {
                        msg: test.msg
                    };
                } else if (test === true) {
                    test = {};
                }
            }
            if (typeof test === "function") {
                validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));
                return;
            }
            if (value === null || value === void 0) {
                return;
            }
            const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);
            validatorPromise.catch(()=>{});
            validators.push(validatorPromise);
        });
        return Promise.all(validators.map((validator2)=>validator2.catch((rejection)=>{
                const isBuiltIn = !!rejection.validatorName;
                this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
            })));
    }
    async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {
        let isAsync = false;
        const validatorArity = validator2.length;
        let asyncArity = 1;
        let errorKey = validatorType;
        let invokeArgs;
        if (optAttrDefined) {
            asyncArity = 2;
            invokeArgs = optValue;
            errorKey = optField;
        }
        if (validatorArity === asyncArity) {
            isAsync = true;
        }
        if (isAsync) {
            try {
                if (optAttrDefined) {
                    return await promisify(validator2.bind(this.modelInstance, invokeArgs))();
                }
                return await promisify(validator2.bind(this.modelInstance))();
            } catch (e) {
                return this._pushError(false, errorKey, e, optValue, validatorType);
            }
        }
        try {
            return await validator2.call(this.modelInstance, invokeArgs);
        } catch (e) {
            return this._pushError(false, errorKey, e, optValue, validatorType);
        }
    }
    async _invokeBuiltinValidator(value, test, validatorType, field) {
        const valueString = String(value);
        if (typeof validator[validatorType] !== "function") {
            throw new Error(`Invalid validator function: ${validatorType}`);
        }
        const validatorArgs = this._extractValidatorArgs(test, validatorType, field);
        if (!validator[validatorType](valueString, ...validatorArgs)) {
            throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {
                validatorName: validatorType,
                validatorArgs
            });
        }
    }
    _extractValidatorArgs(test, validatorType, field) {
        let validatorArgs = test.args || test;
        const isLocalizedValidator = typeof validatorArgs !== "string" && [
            "isAlpha",
            "isAlphanumeric",
            "isMobilePhone"
        ].includes(validatorType);
        if (!Array.isArray(validatorArgs)) {
            if (validatorType === "isImmutable") {
                validatorArgs = [
                    validatorArgs,
                    field,
                    this.modelInstance
                ];
            } else if (isLocalizedValidator || validatorType === "isIP") {
                validatorArgs = [];
            } else {
                validatorArgs = [
                    validatorArgs
                ];
            }
        } else {
            validatorArgs = validatorArgs.slice(0);
        }
        return validatorArgs;
    }
    _validateSchema(rawAttribute, field, value) {
        if (rawAttribute.allowNull === false && (value === null || value === void 0)) {
            const association = Object.values(this.modelInstance.constructor.associations).find((association2)=>association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);
            if (!association || !this.modelInstance.get(association.associationAccessor)) {
                const validators = this.modelInstance.validators[field];
                const errMsg = _.get(validators, "notNull.msg", `${this.modelInstance.constructor.name}.${field} cannot be null`);
                this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, "notNull Violation", field, value, this.modelInstance, "is_null"));
            }
        }
        if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {
            if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {
                this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, "string violation", field, value, this.modelInstance, "not_a_string"));
            }
        }
    }
    _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {
        const message = rawError.message || rawError || "Validation error";
        const error = new sequelizeError.ValidationErrorItem(message, "Validation error", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);
        error[InstanceValidator.RAW_KEY_NAME] = rawError;
        this.errors.push(error);
    }
}
InstanceValidator.RAW_KEY_NAME = "original";
module.exports = InstanceValidator;
module.exports.InstanceValidator = InstanceValidator;
module.exports.default = InstanceValidator; //# sourceMappingURL=instance-validator.js.map
}),
"[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const QueryTypes = module.exports = {
    SELECT: "SELECT",
    INSERT: "INSERT",
    UPDATE: "UPDATE",
    BULKUPDATE: "BULKUPDATE",
    BULKDELETE: "BULKDELETE",
    DELETE: "DELETE",
    UPSERT: "UPSERT",
    VERSION: "VERSION",
    SHOWTABLES: "SHOWTABLES",
    SHOWINDEXES: "SHOWINDEXES",
    DESCRIBE: "DESCRIBE",
    RAW: "RAW",
    FOREIGNKEYS: "FOREIGNKEYS",
    SHOWCONSTRAINTS: "SHOWCONSTRAINTS"
}; //# sourceMappingURL=query-types.js.map
}),
"[project]/node_modules/sequelize/lib/hooks.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("hooks");
const hookTypes = {
    beforeValidate: {
        params: 2
    },
    afterValidate: {
        params: 2
    },
    validationFailed: {
        params: 3
    },
    beforeCreate: {
        params: 2
    },
    afterCreate: {
        params: 2
    },
    beforeDestroy: {
        params: 2
    },
    afterDestroy: {
        params: 2
    },
    beforeRestore: {
        params: 2
    },
    afterRestore: {
        params: 2
    },
    beforeUpdate: {
        params: 2
    },
    afterUpdate: {
        params: 2
    },
    beforeSave: {
        params: 2,
        proxies: [
            "beforeUpdate",
            "beforeCreate"
        ]
    },
    afterSave: {
        params: 2,
        proxies: [
            "afterUpdate",
            "afterCreate"
        ]
    },
    beforeUpsert: {
        params: 2
    },
    afterUpsert: {
        params: 2
    },
    beforeBulkCreate: {
        params: 2
    },
    afterBulkCreate: {
        params: 2
    },
    beforeBulkDestroy: {
        params: 1
    },
    afterBulkDestroy: {
        params: 1
    },
    beforeBulkRestore: {
        params: 1
    },
    afterBulkRestore: {
        params: 1
    },
    beforeBulkUpdate: {
        params: 1
    },
    afterBulkUpdate: {
        params: 1
    },
    beforeFind: {
        params: 1
    },
    beforeFindAfterExpandIncludeAll: {
        params: 1
    },
    beforeFindAfterOptions: {
        params: 1
    },
    afterFind: {
        params: 2
    },
    beforeCount: {
        params: 1
    },
    beforeDefine: {
        params: 2,
        sync: true,
        noModel: true
    },
    afterDefine: {
        params: 1,
        sync: true,
        noModel: true
    },
    beforeInit: {
        params: 2,
        sync: true,
        noModel: true
    },
    afterInit: {
        params: 1,
        sync: true,
        noModel: true
    },
    beforeAssociate: {
        params: 2,
        sync: true
    },
    afterAssociate: {
        params: 2,
        sync: true
    },
    beforeConnect: {
        params: 1,
        noModel: true
    },
    afterConnect: {
        params: 2,
        noModel: true
    },
    beforeDisconnect: {
        params: 1,
        noModel: true
    },
    afterDisconnect: {
        params: 1,
        noModel: true
    },
    beforePoolAcquire: {
        params: 1,
        noModel: true
    },
    afterPoolAcquire: {
        params: 2,
        noModel: true
    },
    beforeSync: {
        params: 1
    },
    afterSync: {
        params: 1
    },
    beforeBulkSync: {
        params: 1
    },
    afterBulkSync: {
        params: 1
    },
    beforeQuery: {
        params: 2
    },
    afterQuery: {
        params: 2
    }
};
exports.hooks = hookTypes;
const getProxiedHooks = (hookType)=>hookTypes[hookType].proxies ? hookTypes[hookType].proxies.concat(hookType) : [
        hookType
    ];
function getHooks(hooked, hookType) {
    return (hooked.options.hooks || {})[hookType] || [];
}
const Hooks = {
    _setupHooks (hooks) {
        this.options.hooks = {};
        _.map(hooks || {}, (hooksArray, hookName)=>{
            if (!Array.isArray(hooksArray)) hooksArray = [
                hooksArray
            ];
            hooksArray.forEach((hookFn)=>this.addHook(hookName, hookFn));
        });
    },
    async runHooks (hooks, ...hookArgs) {
        if (!hooks) throw new Error("runHooks requires at least 1 argument");
        let hookType;
        if (typeof hooks === "string") {
            hookType = hooks;
            hooks = getHooks(this, hookType);
            if (this.sequelize) {
                hooks = hooks.concat(getHooks(this.sequelize, hookType));
            }
        }
        if (!Array.isArray(hooks)) {
            hooks = [
                hooks
            ];
        }
        if (hookTypes[hookType] && hookTypes[hookType].sync) {
            for (let hook of hooks){
                if (typeof hook === "object") {
                    hook = hook.fn;
                }
                debug(`running hook(sync) ${hookType}`);
                hook.apply(this, hookArgs);
            }
            return;
        }
        for (let hook of hooks){
            if (typeof hook === "object") {
                hook = hook.fn;
            }
            debug(`running hook ${hookType}`);
            await hook.apply(this, hookArgs);
        }
    },
    addHook (hookType, name, fn) {
        if (typeof name === "function") {
            fn = name;
            name = null;
        }
        debug(`adding hook ${hookType}`);
        hookType = getProxiedHooks(hookType);
        hookType.forEach((type)=>{
            const hooks = getHooks(this, type);
            hooks.push(name ? {
                name,
                fn
            } : fn);
            this.options.hooks[type] = hooks;
        });
        return this;
    },
    removeHook (hookType, name) {
        const isReference = typeof name === "function" ? true : false;
        if (!this.hasHook(hookType)) {
            return this;
        }
        debug(`removing hook ${hookType}`);
        hookType = getProxiedHooks(hookType);
        for (const type of hookType){
            this.options.hooks[type] = this.options.hooks[type].filter((hook)=>{
                if (isReference && typeof hook === "function") {
                    return hook !== name;
                }
                if (!isReference && typeof hook === "object") {
                    return hook.name !== name;
                }
                return true;
            });
        }
        return this;
    },
    hasHook (hookType) {
        return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;
    }
};
Hooks.hasHooks = Hooks.hasHook;
function applyTo(target, isModel = false) {
    _.mixin(target, Hooks);
    for (const hook of Object.keys(hookTypes)){
        if (isModel && hookTypes[hook].noModel) {
            continue;
        }
        target[hook] = function(name, callback) {
            return this.addHook(hook, name, callback);
        };
    }
}
exports.applyTo = applyTo; //# sourceMappingURL=hooks.js.map
}),
"[project]/node_modules/sequelize/lib/associations/mixin.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const HasOne = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-one.js [app-route] (ecmascript)");
const HasMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
const BelongsToMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)");
const BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
function isModel(model, sequelize) {
    return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;
}
const Mixin = {
    hasMany (target, options = {}) {
        if (!isModel(target, this.sequelize)) {
            throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);
        }
        const source = this;
        options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
        options.useHooks = options.hooks;
        Object.assign(options, _.omit(source.options, [
            "hooks"
        ]));
        if (options.useHooks) {
            this.runHooks("beforeAssociate", {
                source,
                target,
                type: HasMany
            }, options);
        }
        const association = new HasMany(source, target, options);
        source.associations[association.associationAccessor] = association;
        association._injectAttributes();
        association.mixin(source.prototype);
        if (options.useHooks) {
            this.runHooks("afterAssociate", {
                source,
                target,
                type: HasMany,
                association
            }, options);
        }
        return association;
    },
    belongsToMany (target, options = {}) {
        if (!isModel(target, this.sequelize)) {
            throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);
        }
        const source = this;
        options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
        options.useHooks = options.hooks;
        options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;
        Object.assign(options, _.omit(source.options, [
            "hooks",
            "timestamps",
            "scopes",
            "defaultScope"
        ]));
        if (options.useHooks) {
            this.runHooks("beforeAssociate", {
                source,
                target,
                type: BelongsToMany
            }, options);
        }
        const association = new BelongsToMany(source, target, options);
        source.associations[association.associationAccessor] = association;
        association._injectAttributes();
        association.mixin(source.prototype);
        if (options.useHooks) {
            this.runHooks("afterAssociate", {
                source,
                target,
                type: BelongsToMany,
                association
            }, options);
        }
        return association;
    },
    getAssociations (target) {
        return Object.values(this.associations).filter((association)=>association.target.name === target.name);
    },
    getAssociationForAlias (target, alias) {
        return this.getAssociations(target).find((association)=>association.verifyAssociationAlias(alias)) || null;
    }
};
function singleLinked(Type) {
    return function(target, options = {}) {
        const source = this;
        if (!isModel(target, source.sequelize)) {
            throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);
        }
        options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);
        options.useHooks = options.hooks;
        if (options.useHooks) {
            source.runHooks("beforeAssociate", {
                source,
                target,
                type: Type
            }, options);
        }
        const association = new Type(source, target, Object.assign(options, source.options));
        source.associations[association.associationAccessor] = association;
        association._injectAttributes();
        association.mixin(source.prototype);
        if (options.useHooks) {
            source.runHooks("afterAssociate", {
                source,
                target,
                type: Type,
                association
            }, options);
        }
        return association;
    };
}
Mixin.hasOne = singleLinked(HasOne);
Mixin.belongsTo = singleLinked(BelongsTo);
module.exports = Mixin;
module.exports.Mixin = Mixin;
module.exports.default = Mixin; //# sourceMappingURL=mixin.js.map
}),
"[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    noBoolOperatorAliases: ()=>noBoolOperatorAliases,
    noDoubleNestedGroup: ()=>noDoubleNestedGroup,
    noStringOperators: ()=>noStringOperators,
    noTrueLogging: ()=>noTrueLogging,
    unsupportedEngine: ()=>unsupportedEngine
});
var import_util = __toModule(__turbopack_context__.r("[externals]/util [external] (util, cjs)"));
const noop = ()=>{};
const noTrueLogging = (0, import_util.deprecate)(noop, "The logging-option should be either a function or false. Default: console.log", "SEQUELIZE0002");
const noStringOperators = (0, import_util.deprecate)(noop, "String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators", "SEQUELIZE0003");
const noBoolOperatorAliases = (0, import_util.deprecate)(noop, "A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.", "SEQUELIZE0004");
const noDoubleNestedGroup = (0, import_util.deprecate)(noop, "Passing a double nested nested array to `group` is unsupported and will be removed in v6.", "SEQUELIZE0005");
const unsupportedEngine = (0, import_util.deprecate)(noop, "This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md", "SEQUELIZE0006"); //# sourceMappingURL=deprecations.js.map
}),
"[project]/node_modules/sequelize/lib/model.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Dottie = __turbopack_context__.r("[project]/node_modules/dottie/dottie.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
const BelongsToMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)");
const InstanceValidator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/instance-validator.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const HasMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const Hooks = __turbopack_context__.r("[project]/node_modules/sequelize/lib/hooks.js [app-route] (ecmascript)");
const associationsMixin = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/mixin.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const { noDoubleNestedGroup } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)");
const validQueryKeywords = /* @__PURE__ */ new Set([
    "where",
    "attributes",
    "paranoid",
    "include",
    "order",
    "limit",
    "offset",
    "transaction",
    "lock",
    "raw",
    "logging",
    "benchmark",
    "having",
    "searchPath",
    "rejectOnEmpty",
    "plain",
    "scope",
    "group",
    "through",
    "defaults",
    "distinct",
    "primary",
    "exception",
    "type",
    "hooks",
    "force",
    "name"
]);
const nonCascadingOptions = [
    "include",
    "attributes",
    "originalAttributes",
    "order",
    "where",
    "limit",
    "offset",
    "plain",
    "group",
    "having"
];
class Model {
    static get queryInterface() {
        return this.sequelize.getQueryInterface();
    }
    static get queryGenerator() {
        return this.queryInterface.queryGenerator;
    }
    get sequelize() {
        return this.constructor.sequelize;
    }
    constructor(values = {}, options = {}){
        if (!this.constructor._overwrittenAttributesChecked) {
            this.constructor._overwrittenAttributesChecked = true;
            setTimeout(()=>{
                const overwrittenAttributes = [];
                for (const key of Object.keys(this.constructor._attributeManipulation)){
                    if (Object.prototype.hasOwnProperty.call(this, key)) {
                        overwrittenAttributes.push(key);
                    }
                }
                if (overwrittenAttributes.length > 0) {
                    logger.warn(`Model ${JSON.stringify(this.constructor.name)} is declaring public class fields for attribute(s): ${overwrittenAttributes.map((attr)=>JSON.stringify(attr)).join(", ")}.
These class fields are shadowing Sequelize's attribute getters & setters.
See https://sequelize.org/main/manual/model-basics.html#caveat-with-public-class-fields`);
                }
            }, 0);
        }
        options = __spreadValues({
            isNewRecord: true,
            _schema: this.constructor._schema,
            _schemaDelimiter: this.constructor._schemaDelimiter
        }, options);
        if (options.attributes) {
            options.attributes = options.attributes.map((attribute)=>Array.isArray(attribute) ? attribute[1] : attribute);
        }
        if (!options.includeValidated) {
            this.constructor._conformIncludes(options, this.constructor);
            if (options.include) {
                this.constructor._expandIncludeAll(options);
                this.constructor._validateIncludedElements(options);
            }
        }
        this.dataValues = {};
        this._previousDataValues = {};
        this.uniqno = 1;
        this._changed = /* @__PURE__ */ new Set();
        this._options = options;
        this.isNewRecord = options.isNewRecord;
        this._initValues(values, options);
    }
    _initValues(values, options) {
        let defaults;
        let key;
        values = __spreadValues({}, values);
        if (options.isNewRecord) {
            defaults = {};
            if (this.constructor._hasDefaultValues) {
                defaults = _.mapValues(this.constructor._defaultValues, (valueFn)=>{
                    const value = valueFn();
                    return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);
                });
            }
            if (this.constructor.primaryKeyAttributes.length) {
                this.constructor.primaryKeyAttributes.forEach((primaryKeyAttribute)=>{
                    if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {
                        defaults[primaryKeyAttribute] = null;
                    }
                });
            }
            if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {
                this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);
                delete defaults[this.constructor._timestampAttributes.createdAt];
            }
            if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {
                this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);
                delete defaults[this.constructor._timestampAttributes.updatedAt];
            }
            if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {
                this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);
                delete defaults[this.constructor._timestampAttributes.deletedAt];
            }
            for(key in defaults){
                if (values[key] === void 0) {
                    this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), {
                        raw: true
                    });
                    delete values[key];
                }
            }
        }
        this.set(values, options);
    }
    static _paranoidClause(model, options = {}) {
        if (options.include) {
            for (const include of options.include){
                this._paranoidClause(include.model, include);
            }
        }
        if (_.get(options, "groupedLimit.on.options.paranoid")) {
            const throughModel = _.get(options, "groupedLimit.on.through.model");
            if (throughModel) {
                options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);
            }
        }
        if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {
            return options;
        }
        const deletedAtCol = model._timestampAttributes.deletedAt;
        const deletedAtAttribute = model.rawAttributes[deletedAtCol];
        const deletedAtObject = {};
        let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
        deletedAtDefaultValue = deletedAtDefaultValue || {
            [Op.eq]: null
        };
        deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
        if (Utils.isWhereEmpty(options.where)) {
            options.where = deletedAtObject;
        } else {
            options.where = {
                [Op.and]: [
                    deletedAtObject,
                    options.where
                ]
            };
        }
        return options;
    }
    static _addDefaultAttributes() {
        const tail = {};
        let head = {};
        if (!_.some(this.rawAttributes, "primaryKey")) {
            if ("id" in this.rawAttributes) {
                throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);
            }
            head = {
                id: {
                    type: new DataTypes.INTEGER(),
                    allowNull: false,
                    primaryKey: true,
                    autoIncrement: true,
                    _autoGenerated: true
                }
            };
        }
        if (this._timestampAttributes.createdAt) {
            tail[this._timestampAttributes.createdAt] = {
                type: DataTypes.DATE,
                allowNull: false,
                _autoGenerated: true
            };
        }
        if (this._timestampAttributes.updatedAt) {
            tail[this._timestampAttributes.updatedAt] = {
                type: DataTypes.DATE,
                allowNull: false,
                _autoGenerated: true
            };
        }
        if (this._timestampAttributes.deletedAt) {
            tail[this._timestampAttributes.deletedAt] = {
                type: DataTypes.DATE,
                _autoGenerated: true
            };
        }
        if (this._versionAttribute) {
            tail[this._versionAttribute] = {
                type: DataTypes.INTEGER,
                allowNull: false,
                defaultValue: 0,
                _autoGenerated: true
            };
        }
        const newRawAttributes = __spreadValues(__spreadValues({}, head), this.rawAttributes);
        _.each(tail, (value, attr)=>{
            if (newRawAttributes[attr] === void 0) {
                newRawAttributes[attr] = value;
            }
        });
        this.rawAttributes = newRawAttributes;
        if (!Object.keys(this.primaryKeys).length) {
            this.primaryKeys.id = this.rawAttributes.id;
        }
    }
    static getAttributes() {
        return this.rawAttributes;
    }
    static _findAutoIncrementAttribute() {
        this.autoIncrementAttribute = null;
        for(const name in this.rawAttributes){
            if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {
                const definition = this.rawAttributes[name];
                if (definition && definition.autoIncrement) {
                    if (this.autoIncrementAttribute) {
                        throw new Error("Invalid Instance definition. Only one autoincrement field allowed.");
                    }
                    this.autoIncrementAttribute = name;
                }
            }
        }
    }
    static _conformIncludes(options, self) {
        if (!options.include) return;
        if (!Array.isArray(options.include)) {
            options.include = [
                options.include
            ];
        } else if (!options.include.length) {
            delete options.include;
            return;
        }
        options.include = options.include.map((include)=>this._conformInclude(include, self));
    }
    static _transformStringAssociation(include, self) {
        if (self && typeof include === "string") {
            if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {
                throw new Error(`Association with alias "${include}" does not exist on ${self.name}`);
            }
            return self.associations[include];
        }
        return include;
    }
    static _conformInclude(include, self) {
        if (include) {
            let model;
            if (include._pseudo) return include;
            include = this._transformStringAssociation(include, self);
            if (include instanceof Association) {
                if (self && include.target.name === self.name) {
                    model = include.source;
                } else {
                    model = include.target;
                }
                return {
                    model,
                    association: include,
                    as: include.as
                };
            }
            if (include.prototype && include.prototype instanceof Model) {
                return {
                    model: include
                };
            }
            if (_.isPlainObject(include)) {
                if (include.association) {
                    include.association = this._transformStringAssociation(include.association, self);
                    if (self && include.association.target.name === self.name) {
                        model = include.association.source;
                    } else {
                        model = include.association.target;
                    }
                    if (!include.model) include.model = model;
                    if (!include.as) include.as = include.association.as;
                    this._conformIncludes(include, model);
                    return include;
                }
                if (include.model) {
                    this._conformIncludes(include, include.model);
                    return include;
                }
                if (include.all) {
                    this._conformIncludes(include);
                    return include;
                }
            }
        }
        throw new Error("Include unexpected. Element has to be either a Model, an Association or an object.");
    }
    static _expandIncludeAllElement(includes, include) {
        let all = include.all;
        delete include.all;
        if (all !== true) {
            if (!Array.isArray(all)) {
                all = [
                    all
                ];
            }
            const validTypes = {
                BelongsTo: true,
                HasOne: true,
                HasMany: true,
                One: [
                    "BelongsTo",
                    "HasOne"
                ],
                Has: [
                    "HasOne",
                    "HasMany"
                ],
                Many: [
                    "HasMany"
                ]
            };
            for(let i = 0; i < all.length; i++){
                const type = all[i];
                if (type === "All") {
                    all = true;
                    break;
                }
                const types = validTypes[type];
                if (!types) {
                    throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);
                }
                if (types !== true) {
                    all.splice(i, 1);
                    i--;
                    for(let j = 0; j < types.length; j++){
                        if (!all.includes(types[j])) {
                            all.unshift(types[j]);
                            i++;
                        }
                    }
                }
            }
        }
        const nested = include.nested;
        if (nested) {
            delete include.nested;
            if (!include.include) {
                include.include = [];
            } else if (!Array.isArray(include.include)) {
                include.include = [
                    include.include
                ];
            }
        }
        const used = [];
        (function addAllIncludes(parent, includes2) {
            _.forEach(parent.associations, (association)=>{
                if (all !== true && !all.includes(association.associationType)) {
                    return;
                }
                const model = association.target;
                const as = association.options.as;
                const predicate = {
                    model
                };
                if (as) {
                    predicate.as = as;
                }
                if (_.some(includes2, predicate)) {
                    return;
                }
                if (nested && used.includes(model)) {
                    return;
                }
                used.push(parent);
                const thisInclude = Utils.cloneDeep(include);
                thisInclude.model = model;
                if (as) {
                    thisInclude.as = as;
                }
                includes2.push(thisInclude);
                if (nested) {
                    addAllIncludes(model, thisInclude.include);
                    if (thisInclude.include.length === 0) delete thisInclude.include;
                }
            });
            used.pop();
        })(this, includes);
    }
    static _validateIncludedElements(options, tableNames) {
        if (!options.model) options.model = this;
        tableNames = tableNames || {};
        options.includeNames = [];
        options.includeMap = {};
        options.hasSingleAssociation = false;
        options.hasMultiAssociation = false;
        if (!options.parent) {
            options.topModel = options.model;
            options.topLimit = options.limit;
        }
        options.include = options.include.map((include)=>{
            include = this._conformInclude(include);
            include.parent = options;
            include.topLimit = options.topLimit;
            this._validateIncludedElement.call(options.model, include, tableNames, options);
            if (include.duplicating === void 0) {
                include.duplicating = include.association.isMultiAssociation;
            }
            include.hasDuplicating = include.hasDuplicating || include.duplicating;
            include.hasRequired = include.hasRequired || include.required;
            options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;
            options.hasRequired = options.hasRequired || include.required;
            options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;
            return include;
        });
        for (const include of options.include){
            include.hasParentWhere = options.hasParentWhere || !!options.where;
            include.hasParentRequired = options.hasParentRequired || !!options.required;
            if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {
                if (include.duplicating) {
                    include.subQuery = include.subQuery || false;
                    include.subQueryFilter = include.hasRequired;
                } else {
                    include.subQuery = include.hasRequired;
                    include.subQueryFilter = false;
                }
            } else {
                include.subQuery = include.subQuery || false;
                if (include.duplicating) {
                    include.subQueryFilter = include.subQuery;
                } else {
                    include.subQueryFilter = false;
                    include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;
                }
            }
            options.includeMap[include.as] = include;
            options.includeNames.push(include.as);
            if (options.topModel === options.model && options.subQuery === void 0 && options.topLimit) {
                if (include.subQuery) {
                    options.subQuery = include.subQuery;
                } else if (include.hasDuplicating) {
                    options.subQuery = true;
                }
            }
            options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;
            options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;
            if (include.association.isMultiAssociation || include.hasMultiAssociation) {
                options.hasMultiAssociation = true;
            }
            if (include.association.isSingleAssociation || include.hasSingleAssociation) {
                options.hasSingleAssociation = true;
            }
        }
        if (options.topModel === options.model && options.subQuery === void 0) {
            options.subQuery = false;
        }
        return options;
    }
    static _validateIncludedElement(include, tableNames, options) {
        tableNames[include.model.getTableName()] = true;
        if (include.attributes && !options.raw) {
            include.model._expandAttributes(include);
            include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);
            include = Utils.mapFinderOptions(include, include.model);
            if (include.attributes.length) {
                _.each(include.model.primaryKeys, (attr, key)=>{
                    if (!include.attributes.some((includeAttr)=>{
                        if (attr.field !== key) {
                            return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;
                        }
                        return includeAttr === key;
                    })) {
                        include.attributes.unshift(key);
                    }
                });
            }
        } else {
            include = Utils.mapFinderOptions(include, include.model);
        }
        if (include._pseudo) {
            if (!include.attributes) {
                include.attributes = Object.keys(include.model.tableAttributes);
            }
            return Utils.mapFinderOptions(include, include.model);
        }
        const association = include.association || this._getIncludedAssociation(include.model, include.as);
        include.association = association;
        include.as = association.as;
        if (include.association.through && Object(include.association.through.model) === include.association.through.model) {
            if (!include.include) include.include = [];
            const through = include.association.through;
            include.through = _.defaults(include.through || {}, {
                model: through.model,
                as: through.model.name,
                association: {
                    isSingleAssociation: true
                },
                _pseudo: true,
                parent: include
            });
            if (through.scope) {
                include.through.where = include.through.where ? {
                    [Op.and]: [
                        include.through.where,
                        through.scope
                    ]
                } : through.scope;
            }
            include.include.push(include.through);
            tableNames[through.tableName] = true;
        }
        let model;
        if (include.model.scoped === true) {
            model = include.model;
        } else {
            model = include.association.target.name === include.model.name ? include.association.target : include.association.source;
        }
        model._injectScope(include);
        if (!include.attributes) {
            include.attributes = Object.keys(include.model.tableAttributes);
        }
        include = Utils.mapFinderOptions(include, include.model);
        if (include.required === void 0) {
            include.required = !!include.where;
        }
        if (include.association.scope) {
            include.where = include.where ? {
                [Op.and]: [
                    include.where,
                    include.association.scope
                ]
            } : include.association.scope;
        }
        if (include.limit && include.separate === void 0) {
            include.separate = true;
        }
        if (include.separate === true) {
            if (!(include.association instanceof HasMany)) {
                throw new Error("Only HasMany associations support include.separate");
            }
            include.duplicating = false;
            if (options.attributes && options.attributes.length && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)) {
                options.attributes.push(association.sourceKey);
            }
            if (include.attributes && include.attributes.length && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)) {
                include.attributes.push(association.foreignKey);
            }
        }
        if (Object.prototype.hasOwnProperty.call(include, "include")) {
            this._validateIncludedElements.call(include.model, include, tableNames);
        }
        return include;
    }
    static _getIncludedAssociation(targetModel, targetAlias) {
        const associations = this.getAssociations(targetModel);
        let association = null;
        if (associations.length === 0) {
            throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);
        }
        if (associations.length === 1) {
            association = this.getAssociationForAlias(targetModel, targetAlias);
            if (association) {
                return association;
            }
            if (targetAlias) {
                const existingAliases = this.getAssociations(targetModel).map((association2)=>association2.as);
                throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(", ")}).`);
            }
            throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You must use the 'as' keyword to specify the alias within your include statement.`);
        }
        association = this.getAssociationForAlias(targetModel, targetAlias);
        if (!association) {
            throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include.`);
        }
        return association;
    }
    static _expandIncludeAll(options) {
        const includes = options.include;
        if (!includes) {
            return;
        }
        for(let index = 0; index < includes.length; index++){
            const include = includes[index];
            if (include.all) {
                includes.splice(index, 1);
                index--;
                this._expandIncludeAllElement(includes, include);
            }
        }
        includes.forEach((include)=>{
            this._expandIncludeAll.call(include.model, include);
        });
    }
    static _conformIndex(index) {
        if (!index.fields) {
            throw new Error('Missing "fields" property for index definition');
        }
        index = _.defaults(index, {
            type: "",
            parser: null
        });
        if (index.type && index.type.toLowerCase() === "unique") {
            index.unique = true;
            delete index.type;
        }
        return index;
    }
    static _uniqIncludes(options) {
        if (!options.include) return;
        options.include = _(options.include).groupBy((include)=>`${include.model && include.model.name}-${include.as}`).map((includes)=>this._assignOptions(...includes)).value();
    }
    static _baseMerge(...args) {
        _.assignWith(...args);
        this._conformIncludes(args[0], this);
        this._uniqIncludes(args[0]);
        return args[0];
    }
    static _mergeFunction(objValue, srcValue, key) {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
            return _.union(objValue, srcValue);
        }
        if ([
            "where",
            "having"
        ].includes(key)) {
            if (this.options && this.options.whereMergeStrategy === "and") {
                return combineWheresWithAnd(objValue, srcValue);
            }
            if (srcValue instanceof Utils.SequelizeMethod) {
                srcValue = {
                    [Op.and]: srcValue
                };
            }
            if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
                return Object.assign(objValue, srcValue);
            }
        } else if (key === "attributes" && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {
            return _.assignWith(objValue, srcValue, (objValue2, srcValue2)=>{
                if (Array.isArray(objValue2) && Array.isArray(srcValue2)) {
                    return _.union(objValue2, srcValue2);
                }
            });
        }
        if (srcValue) {
            return Utils.cloneDeep(srcValue, true);
        }
        return srcValue === void 0 ? objValue : srcValue;
    }
    static _assignOptions(...args) {
        return this._baseMerge(...args, this._mergeFunction.bind(this));
    }
    static _defaultsOptions(target, opts) {
        return this._baseMerge(target, opts, (srcValue, objValue, key)=>{
            return this._mergeFunction(objValue, srcValue, key);
        });
    }
    static init(attributes, options = {}) {
        if (!options.sequelize) {
            throw new Error("No Sequelize instance passed");
        }
        this.sequelize = options.sequelize;
        const globalOptions = this.sequelize.options;
        options = Utils.merge(_.cloneDeep(globalOptions.define), options);
        if (!options.modelName) {
            options.modelName = this.name;
        }
        options = Utils.merge({
            name: {
                plural: Utils.pluralize(options.modelName),
                singular: Utils.singularize(options.modelName)
            },
            indexes: [],
            omitNull: globalOptions.omitNull,
            schema: globalOptions.schema
        }, options);
        this.sequelize.runHooks("beforeDefine", attributes, options);
        if (options.modelName !== this.name) {
            Object.defineProperty(this, "name", {
                value: options.modelName
            });
        }
        delete options.modelName;
        this.options = __spreadValues({
            timestamps: true,
            validate: {},
            freezeTableName: false,
            underscored: false,
            paranoid: false,
            rejectOnEmpty: false,
            whereCollection: null,
            schema: null,
            schemaDelimiter: "",
            defaultScope: {},
            scopes: {},
            indexes: [],
            whereMergeStrategy: "overwrite"
        }, options);
        if (this.sequelize.isDefined(this.name)) {
            this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));
        }
        this.associations = {};
        this._setupHooks(options.hooks);
        this.underscored = this.options.underscored;
        if (!this.options.tableName) {
            this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);
        } else {
            this.tableName = this.options.tableName;
        }
        this._schema = this.options.schema;
        this._schemaDelimiter = this.options.schemaDelimiter;
        _.each(options.validate, (validator, validatorType)=>{
            if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {
                throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);
            }
            if (typeof validator !== "function") {
                throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);
            }
        });
        if (!_.includes([
            "and",
            "overwrite"
        ], this.options && this.options.whereMergeStrategy)) {
            throw new Error(`Invalid value ${this.options && this.options.whereMergeStrategy} for whereMergeStrategy. Allowed values are 'and' and 'overwrite'.`);
        }
        this.rawAttributes = _.mapValues(attributes, (attribute, name)=>{
            attribute = this.sequelize.normalizeAttribute(attribute);
            if (attribute.type === void 0) {
                throw new Error(`Unrecognized datatype for attribute "${this.name}.${name}"`);
            }
            if (attribute.allowNull !== false && _.get(attribute, "validate.notNull")) {
                throw new Error(`Invalid definition for "${this.name}.${name}", "notNull" validator is only allowed with "allowNull:false"`);
            }
            if (_.get(attribute, "references.model.prototype") instanceof Model) {
                attribute.references.model = attribute.references.model.getTableName();
            }
            return attribute;
        });
        const tableName = this.getTableName();
        this._indexes = this.options.indexes.map((index)=>Utils.nameIndex(this._conformIndex(index), tableName));
        this.primaryKeys = {};
        this._readOnlyAttributes = /* @__PURE__ */ new Set();
        this._timestampAttributes = {};
        if (this.options.timestamps) {
            for (const key of [
                "createdAt",
                "updatedAt",
                "deletedAt"
            ]){
                if (![
                    "undefined",
                    "string",
                    "boolean"
                ].includes(typeof this.options[key])) {
                    throw new Error(`Value for "${key}" option must be a string or a boolean, got ${typeof this.options[key]}`);
                }
                if (this.options[key] === "") {
                    throw new Error(`Value for "${key}" option cannot be an empty string`);
                }
            }
            if (this.options.createdAt !== false) {
                this._timestampAttributes.createdAt = typeof this.options.createdAt === "string" ? this.options.createdAt : "createdAt";
                this._readOnlyAttributes.add(this._timestampAttributes.createdAt);
            }
            if (this.options.updatedAt !== false) {
                this._timestampAttributes.updatedAt = typeof this.options.updatedAt === "string" ? this.options.updatedAt : "updatedAt";
                this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);
            }
            if (this.options.paranoid && this.options.deletedAt !== false) {
                this._timestampAttributes.deletedAt = typeof this.options.deletedAt === "string" ? this.options.deletedAt : "deletedAt";
                this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);
            }
        }
        if (this.options.version) {
            this._versionAttribute = typeof this.options.version === "string" ? this.options.version : "version";
            this._readOnlyAttributes.add(this._versionAttribute);
        }
        this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;
        this._addDefaultAttributes();
        this.refreshAttributes();
        this._findAutoIncrementAttribute();
        this._scope = this.options.defaultScope;
        this._scopeNames = [
            "defaultScope"
        ];
        this.sequelize.modelManager.addModel(this);
        this.sequelize.runHooks("afterDefine", this);
        return this;
    }
    static refreshAttributes() {
        const attributeManipulation = {};
        this.prototype._customGetters = {};
        this.prototype._customSetters = {};
        [
            "get",
            "set"
        ].forEach((type)=>{
            const opt = `${type}terMethods`;
            const funcs = __spreadValues({}, this.options[opt]);
            const _custom = type === "get" ? this.prototype._customGetters : this.prototype._customSetters;
            _.each(funcs, (method, attribute)=>{
                _custom[attribute] = method;
                if (type === "get") {
                    funcs[attribute] = function() {
                        return this.get(attribute);
                    };
                }
                if (type === "set") {
                    funcs[attribute] = function(value) {
                        return this.set(attribute, value);
                    };
                }
            });
            _.each(this.rawAttributes, (options, attribute)=>{
                if (Object.prototype.hasOwnProperty.call(options, type)) {
                    _custom[attribute] = options[type];
                }
                if (type === "get") {
                    funcs[attribute] = function() {
                        return this.get(attribute);
                    };
                }
                if (type === "set") {
                    funcs[attribute] = function(value) {
                        return this.set(attribute, value);
                    };
                }
            });
            _.each(funcs, (fct, name)=>{
                if (!attributeManipulation[name]) {
                    attributeManipulation[name] = {
                        configurable: true
                    };
                }
                attributeManipulation[name][type] = fct;
            });
        });
        this._dataTypeChanges = {};
        this._dataTypeSanitizers = {};
        this._hasBooleanAttributes = false;
        this._hasDateAttributes = false;
        this._jsonAttributes = /* @__PURE__ */ new Set();
        this._virtualAttributes = /* @__PURE__ */ new Set();
        this._defaultValues = {};
        this.prototype.validators = {};
        this.fieldRawAttributesMap = {};
        this.primaryKeys = {};
        this.uniqueKeys = {};
        _.each(this.rawAttributes, (definition, name)=>{
            definition.type = this.sequelize.normalizeDataType(definition.type);
            definition.Model = this;
            definition.fieldName = name;
            definition._modelAttribute = true;
            if (definition.field === void 0) {
                definition.field = Utils.underscoredIf(name, this.underscored);
            }
            if (definition.primaryKey === true) {
                this.primaryKeys[name] = definition;
            }
            this.fieldRawAttributesMap[definition.field] = definition;
            if (definition.type._sanitize) {
                this._dataTypeSanitizers[name] = definition.type._sanitize;
            }
            if (definition.type._isChanged) {
                this._dataTypeChanges[name] = definition.type._isChanged;
            }
            if (definition.type instanceof DataTypes.BOOLEAN) {
                this._hasBooleanAttributes = true;
            } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {
                this._hasDateAttributes = true;
            } else if (definition.type instanceof DataTypes.JSON) {
                this._jsonAttributes.add(name);
            } else if (definition.type instanceof DataTypes.VIRTUAL) {
                this._virtualAttributes.add(name);
            }
            if (Object.prototype.hasOwnProperty.call(definition, "defaultValue")) {
                this._defaultValues[name] = ()=>Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);
            }
            if (Object.prototype.hasOwnProperty.call(definition, "unique") && definition.unique) {
                let idxName;
                if (typeof definition.unique === "object" && Object.prototype.hasOwnProperty.call(definition.unique, "name")) {
                    idxName = definition.unique.name;
                } else if (typeof definition.unique === "string") {
                    idxName = definition.unique;
                } else {
                    idxName = `${this.tableName}_${name}_unique`;
                }
                const idx = this.uniqueKeys[idxName] || {
                    fields: []
                };
                idx.fields.push(definition.field);
                idx.msg = idx.msg || definition.unique.msg || null;
                idx.name = idxName || false;
                idx.column = name;
                idx.customIndex = definition.unique !== true;
                this.uniqueKeys[idxName] = idx;
            }
            if (Object.prototype.hasOwnProperty.call(definition, "validate")) {
                this.prototype.validators[name] = definition.validate;
            }
            if (definition.index === true && definition.type instanceof DataTypes.JSONB) {
                this._indexes.push(Utils.nameIndex(this._conformIndex({
                    fields: [
                        definition.field || name
                    ],
                    using: "gin"
                }), this.getTableName()));
                delete definition.index;
            }
        });
        this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key)=>{
            if (key !== value.fieldName) {
                map[key] = value.fieldName;
            }
            return map;
        }, {});
        this._hasJsonAttributes = !!this._jsonAttributes.size;
        this._hasVirtualAttributes = !!this._virtualAttributes.size;
        this._hasDefaultValues = !_.isEmpty(this._defaultValues);
        this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key)=>this._virtualAttributes.has(key));
        this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;
        this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;
        for (const key of Object.keys(attributeManipulation)){
            if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {
                this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);
                continue;
            }
            Object.defineProperty(this.prototype, key, attributeManipulation[key]);
        }
        this.prototype.rawAttributes = this.rawAttributes;
        this.prototype._isAttribute = (key)=>Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);
        this.primaryKeyAttributes = Object.keys(this.primaryKeys);
        this.primaryKeyAttribute = this.primaryKeyAttributes[0];
        if (this.primaryKeyAttribute) {
            this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;
        }
        this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;
        this._isPrimaryKey = (key)=>this.primaryKeyAttributes.includes(key);
        this._attributeManipulation = attributeManipulation;
    }
    static removeAttribute(attribute) {
        delete this.rawAttributes[attribute];
        this.refreshAttributes();
    }
    static async sync(options) {
        options = __spreadValues(__spreadValues({}, this.options), options);
        options.hooks = options.hooks === void 0 ? true : !!options.hooks;
        const attributes = this.tableAttributes;
        const rawAttributes = this.fieldRawAttributesMap;
        if (options.hooks) {
            await this.runHooks("beforeSync", options);
        }
        const tableName = this.getTableName(options);
        let tableExists;
        if (options.force) {
            await this.drop(options);
            tableExists = false;
        } else {
            tableExists = await this.queryInterface.tableExists(tableName, options);
        }
        if (!tableExists) {
            await this.queryInterface.createTable(tableName, attributes, options, this);
        } else {
            await this.queryInterface.ensureEnums(tableName, attributes, options, this);
        }
        if (tableExists && options.alter) {
            const tableInfos = await Promise.all([
                this.queryInterface.describeTable(tableName, options),
                this.queryInterface.getForeignKeyReferencesForTable(tableName, options)
            ]);
            const columns = tableInfos[0];
            const foreignKeyReferences = tableInfos[1];
            const removedConstraints = {};
            for(const columnName in attributes){
                if (!Object.prototype.hasOwnProperty.call(attributes, columnName)) continue;
                if (!columns[columnName] && !columns[attributes[columnName].field]) {
                    await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);
                }
            }
            if (options.alter === true || typeof options.alter === "object" && options.alter.drop !== false) {
                for(const columnName in columns){
                    if (!Object.prototype.hasOwnProperty.call(columns, columnName)) continue;
                    const currentAttribute = rawAttributes[columnName];
                    if (!currentAttribute) {
                        await this.queryInterface.removeColumn(tableName, columnName, options);
                        continue;
                    }
                    if (currentAttribute.primaryKey) continue;
                    const references = currentAttribute.references;
                    if (currentAttribute.references) {
                        const database = this.sequelize.config.database;
                        const schema = this.sequelize.config.schema;
                        for (const foreignKeyReference of foreignKeyReferences){
                            const constraintName = foreignKeyReference.constraintName;
                            if (!!constraintName && foreignKeyReference.tableCatalog === database && (schema ? foreignKeyReference.tableSchema === schema : true) && foreignKeyReference.referencedTableName === references.model && foreignKeyReference.referencedColumnName === references.key && (schema ? foreignKeyReference.referencedTableSchema === schema : true) && !removedConstraints[constraintName]) {
                                await this.queryInterface.removeConstraint(tableName, constraintName, options);
                                removedConstraints[constraintName] = true;
                            }
                        }
                    }
                    await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);
                }
            }
        }
        const existingIndexes = await this.queryInterface.showIndex(tableName, options);
        const missingIndexes = this._indexes.filter((item1)=>!existingIndexes.some((item2)=>item1.name === item2.name)).sort((index1, index2)=>{
            if (this.sequelize.options.dialect === "postgres") {
                if (index1.concurrently === true) return 1;
                if (index2.concurrently === true) return -1;
            }
            return 0;
        });
        for (const index of missingIndexes){
            await this.queryInterface.addIndex(tableName, __spreadValues(__spreadValues({}, options), index));
        }
        if (options.hooks) {
            await this.runHooks("afterSync", options);
        }
        return this;
    }
    static async drop(options) {
        return await this.queryInterface.dropTable(this.getTableName(options), options);
    }
    static async dropSchema(schema) {
        return await this.queryInterface.dropSchema(schema);
    }
    static schema(schema, options) {
        const clone = class extends this {
        };
        Object.defineProperty(clone, "name", {
            value: this.name
        });
        clone._schema = schema;
        if (options) {
            if (typeof options === "string") {
                clone._schemaDelimiter = options;
            } else if (options.schemaDelimiter) {
                clone._schemaDelimiter = options.schemaDelimiter;
            }
        }
        return clone;
    }
    static getTableName() {
        return this.queryGenerator.addSchema(this);
    }
    static unscoped() {
        return this.scope();
    }
    static addScope(name, scope, options) {
        options = __spreadValues({
            override: false
        }, options);
        if ((name === "defaultScope" && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {
            throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);
        }
        if (name === "defaultScope") {
            this.options.defaultScope = this._scope = scope;
        } else {
            this.options.scopes[name] = scope;
        }
    }
    static scope(option) {
        const self = class extends this {
        };
        let scope;
        let scopeName;
        Object.defineProperty(self, "name", {
            value: this.name
        });
        self._scope = {};
        self._scopeNames = [];
        self.scoped = true;
        if (!option) {
            return self;
        }
        const options = _.flatten(arguments);
        for (const option2 of options){
            scope = null;
            scopeName = null;
            if (_.isPlainObject(option2)) {
                if (option2.method) {
                    if (Array.isArray(option2.method) && !!self.options.scopes[option2.method[0]]) {
                        scopeName = option2.method[0];
                        scope = self.options.scopes[scopeName].apply(self, option2.method.slice(1));
                    } else if (self.options.scopes[option2.method]) {
                        scopeName = option2.method;
                        scope = self.options.scopes[scopeName].apply(self);
                    }
                } else {
                    scope = option2;
                }
            } else if (option2 === "defaultScope" && _.isPlainObject(self.options.defaultScope)) {
                scope = self.options.defaultScope;
            } else {
                scopeName = option2;
                scope = self.options.scopes[scopeName];
                if (typeof scope === "function") {
                    scope = scope();
                }
            }
            if (scope) {
                this._conformIncludes(scope, this);
                this._assignOptions(self._scope, Utils.cloneDeep(scope));
                self._scopeNames.push(scopeName ? scopeName : "defaultScope");
            } else {
                throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);
            }
        }
        return self;
    }
    static async findAll(options) {
        if (options !== void 0 && !_.isPlainObject(options)) {
            throw new sequelizeErrors.QueryError("The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value");
        }
        if (options !== void 0 && options.attributes) {
            if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {
                throw new sequelizeErrors.QueryError("The attributes option must be an array of column names or an object");
            }
        }
        this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));
        const tableNames = {};
        tableNames[this.getTableName(options)] = true;
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        _.defaults(options, {
            hooks: true
        });
        options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, "rejectOnEmpty") ? options.rejectOnEmpty : this.options.rejectOnEmpty;
        this._injectScope(options);
        if (options.hooks) {
            await this.runHooks("beforeFind", options);
        }
        this._conformIncludes(options, this);
        this._expandAttributes(options);
        this._expandIncludeAll(options);
        if (options.hooks) {
            await this.runHooks("beforeFindAfterExpandIncludeAll", options);
        }
        options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
        if (options.include) {
            options.hasJoin = true;
            this._validateIncludedElements(options, tableNames);
            if (options.attributes && !options.raw && this.primaryKeyAttribute && !options.attributes.includes(this.primaryKeyAttribute) && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)) {
                options.attributes = [
                    this.primaryKeyAttribute
                ].concat(options.attributes);
            }
        }
        if (!options.attributes) {
            options.attributes = Object.keys(this.rawAttributes);
            options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);
        }
        this.options.whereCollection = options.where || null;
        Utils.mapFinderOptions(options, this);
        options = this._paranoidClause(this, options);
        if (options.hooks) {
            await this.runHooks("beforeFindAfterOptions", options);
        }
        const selectOptions = __spreadProps(__spreadValues({}, options), {
            tableNames: Object.keys(tableNames)
        });
        const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);
        if (options.hooks) {
            await this.runHooks("afterFind", results, options);
        }
        if (_.isEmpty(results) && options.rejectOnEmpty) {
            if (typeof options.rejectOnEmpty === "function") {
                throw new options.rejectOnEmpty();
            }
            if (typeof options.rejectOnEmpty === "object") {
                throw options.rejectOnEmpty;
            }
            throw new sequelizeErrors.EmptyResultError();
        }
        return await Model._findSeparate(results, options);
    }
    static warnOnInvalidOptions(options, validColumnNames) {
        if (!_.isPlainObject(options)) {
            return;
        }
        const unrecognizedOptions = Object.keys(options).filter((k)=>!validQueryKeywords.has(k));
        const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);
        if (!options.where && unexpectedModelAttributes.length > 0) {
            logger.warn(`Model attributes (${unexpectedModelAttributes.join(", ")}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);
        }
    }
    static _injectDependentVirtualAttributes(attributes) {
        if (!this._hasVirtualAttributes) return attributes;
        if (!attributes || !Array.isArray(attributes)) return attributes;
        for (const attribute of attributes){
            if (this._virtualAttributes.has(attribute) && this.rawAttributes[attribute].type.fields) {
                attributes = attributes.concat(this.rawAttributes[attribute].type.fields);
            }
        }
        attributes = _.uniq(attributes);
        return attributes;
    }
    static async _findSeparate(results, options) {
        if (!options.include || options.raw || !results) return results;
        const original = results;
        if (options.plain) results = [
            results
        ];
        if (!results.length) return original;
        await Promise.all(options.include.map(async (include)=>{
            if (!include.separate) {
                return await Model._findSeparate(results.reduce((memo, result)=>{
                    let associations = result.get(include.association.as);
                    if (!associations) return memo;
                    if (!Array.isArray(associations)) associations = [
                        associations
                    ];
                    for(let i = 0, len = associations.length; i !== len; ++i){
                        memo.push(associations[i]);
                    }
                    return memo;
                }, []), __spreadProps(__spreadValues({}, _.omit(options, "include", "attributes", "order", "where", "limit", "offset", "plain", "scope")), {
                    include: include.include || []
                }));
            }
            const map = await include.association.get(results, __spreadValues(__spreadValues({}, _.omit(options, nonCascadingOptions)), _.omit(include, [
                "parent",
                "association",
                "as",
                "originalAttributes"
            ])));
            for (const result of results){
                result.set(include.association.as, map[result.get(include.association.sourceKey)], {
                    raw: true
                });
            }
        }));
        return original;
    }
    static async findByPk(param, options) {
        if ([
            null,
            void 0
        ].includes(param)) {
            return null;
        }
        options = Utils.cloneDeep(options) || {};
        if (typeof param === "number" || typeof param === "bigint" || typeof param === "string" || Buffer.isBuffer(param)) {
            options.where = {
                [this.primaryKeyAttribute]: param
            };
        } else {
            throw new Error(`Argument passed to findByPk is invalid: ${param}`);
        }
        return await this.findOne(options);
    }
    static async findOne(options) {
        if (options !== void 0 && !_.isPlainObject(options)) {
            throw new Error("The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value");
        }
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        if (options.limit === void 0) {
            const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter((c)=>c.fields.length === 1).map("column").value();
            if (!options.where || !_.some(options.where, (value, key)=>(key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) && (Utils.isPrimitive(value) || Buffer.isBuffer(value)))) {
                options.limit = 1;
            }
        }
        return await this.findAll(_.defaults(options, {
            plain: true
        }));
    }
    static async aggregate(attribute, aggregateFunction, options) {
        options = Utils.cloneDeep(options);
        const prevAttributes = options.attributes;
        this._injectScope(options);
        options.attributes = prevAttributes;
        this._conformIncludes(options, this);
        if (options.include) {
            this._expandIncludeAll(options);
            this._validateIncludedElements(options);
        }
        const attrOptions = this.rawAttributes[attribute];
        const field = attrOptions && attrOptions.field || attribute;
        let aggregateColumn = this.sequelize.col(field);
        if (options.distinct) {
            aggregateColumn = this.sequelize.fn("DISTINCT", aggregateColumn);
        }
        let { group } = options;
        if (Array.isArray(group) && Array.isArray(group[0])) {
            noDoubleNestedGroup();
            group = _.flatten(group);
        }
        options.attributes = _.unionBy(options.attributes, group, [
            [
                this.sequelize.fn(aggregateFunction, aggregateColumn),
                aggregateFunction
            ]
        ], (a)=>Array.isArray(a) ? a[1] : a);
        if (!options.dataType) {
            if (attrOptions) {
                options.dataType = attrOptions.type;
            } else {
                options.dataType = new DataTypes.FLOAT();
            }
        } else {
            options.dataType = this.sequelize.normalizeDataType(options.dataType);
        }
        Utils.mapOptionFieldNames(options, this);
        options = this._paranoidClause(this, options);
        const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);
        return value;
    }
    static async count(options) {
        options = Utils.cloneDeep(options);
        options = _.defaults(options, {
            hooks: true
        });
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        options.raw = true;
        if (options.hooks) {
            await this.runHooks("beforeCount", options);
        }
        let col = options.col || "*";
        if (options.include) {
            col = `${this.name}.${options.col || this.primaryKeyField}`;
        }
        if (options.distinct && col === "*") {
            col = this.primaryKeyField;
        }
        options.plain = !options.group;
        options.dataType = new DataTypes.INTEGER();
        options.includeIgnoreAttributes = false;
        options.limit = null;
        options.offset = null;
        options.order = null;
        const result = await this.aggregate(col, "count", options);
        if (Array.isArray(result)) {
            return result.map((item)=>__spreadProps(__spreadValues({}, item), {
                    count: Number(item.count)
                }));
        }
        return result;
    }
    static async findAndCountAll(options) {
        if (options !== void 0 && !_.isPlainObject(options)) {
            throw new Error("The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value");
        }
        const countOptions = Utils.cloneDeep(options);
        if (countOptions.attributes) {
            countOptions.attributes = void 0;
        }
        const [count, rows] = await Promise.all([
            this.count(countOptions),
            this.findAll(options)
        ]);
        return {
            count,
            rows: count === 0 ? [] : rows
        };
    }
    static async max(field, options) {
        return await this.aggregate(field, "max", options);
    }
    static async min(field, options) {
        return await this.aggregate(field, "min", options);
    }
    static async sum(field, options) {
        return await this.aggregate(field, "sum", options);
    }
    static build(values, options) {
        if (Array.isArray(values)) {
            return this.bulkBuild(values, options);
        }
        return new this(values, options);
    }
    static bulkBuild(valueSets, options) {
        options = __spreadValues({
            isNewRecord: true
        }, options);
        if (!options.includeValidated) {
            this._conformIncludes(options, this);
            if (options.include) {
                this._expandIncludeAll(options);
                this._validateIncludedElements(options);
            }
        }
        if (options.attributes) {
            options.attributes = options.attributes.map((attribute)=>Array.isArray(attribute) ? attribute[1] : attribute);
        }
        return valueSets.map((values)=>this.build(values, options));
    }
    static async create(values, options) {
        options = Utils.cloneDeep(options || {});
        return await this.build(values, {
            isNewRecord: true,
            attributes: options.fields,
            include: options.include,
            raw: options.raw,
            silent: options.silent
        }).save(options);
    }
    static async findOrBuild(options) {
        if (!options || !options.where || arguments.length > 1) {
            throw new Error("Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");
        }
        let values;
        let instance = await this.findOne(options);
        if (instance === null) {
            values = __spreadValues({}, options.defaults);
            if (_.isPlainObject(options.where)) {
                values = Utils.defaults(values, options.where);
            }
            instance = this.build(values, options);
            return [
                instance,
                true
            ];
        }
        return [
            instance,
            false
        ];
    }
    static async findOrCreate(options) {
        if (!options || !options.where || arguments.length > 1) {
            throw new Error("Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");
        }
        options = __spreadValues({}, options);
        if (options.defaults) {
            const defaults = Object.keys(options.defaults);
            const unknownDefaults = defaults.filter((name)=>!this.rawAttributes[name]);
            if (unknownDefaults.length) {
                logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);
            }
        }
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        const internalTransaction = !options.transaction;
        let values;
        let transaction;
        try {
            const t = await this.sequelize.transaction(options);
            transaction = t;
            options.transaction = t;
            const found = await this.findOne(Utils.defaults({
                transaction
            }, options));
            if (found !== null) {
                return [
                    found,
                    false
                ];
            }
            values = __spreadValues({}, options.defaults);
            if (_.isPlainObject(options.where)) {
                values = Utils.defaults(values, options.where);
            }
            options.exception = true;
            options.returning = true;
            try {
                const created = await this.create(values, options);
                if (created.get(this.primaryKeyAttribute, {
                    raw: true
                }) === null) {
                    throw new sequelizeErrors.UniqueConstraintError();
                }
                return [
                    created,
                    true
                ];
            } catch (err) {
                if (!(err instanceof sequelizeErrors.UniqueConstraintError)) throw err;
                const flattenedWhere = Utils.flattenObjectDeep(options.where);
                const flattenedWhereKeys = Object.keys(flattenedWhere).map((name)=>_.last(name.split(".")));
                const whereFields = flattenedWhereKeys.map((name)=>_.get(this.rawAttributes, `${name}.field`, name));
                const defaultFields = options.defaults && Object.keys(options.defaults).filter((name)=>this.rawAttributes[name]).map((name)=>this.rawAttributes[name].field || name);
                const errFieldKeys = Object.keys(err.fields);
                const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);
                if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {
                    throw err;
                }
                if (errFieldsWhereIntersects) {
                    _.each(err.fields, (value, key)=>{
                        const name = this.fieldRawAttributesMap[key].fieldName;
                        if (value.toString() !== options.where[name].toString()) {
                            throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);
                        }
                    });
                }
                const otherCreated = await this.findOne(Utils.defaults({
                    transaction: internalTransaction ? null : transaction
                }, options));
                if (otherCreated === null) throw err;
                return [
                    otherCreated,
                    false
                ];
            }
        } finally{
            if (internalTransaction && transaction) {
                await transaction.commit();
            }
        }
    }
    static async findCreateFind(options) {
        if (!options || !options.where) {
            throw new Error("Missing where attribute in the options parameter passed to findCreateFind.");
        }
        let values = __spreadValues({}, options.defaults);
        if (_.isPlainObject(options.where)) {
            values = Utils.defaults(values, options.where);
        }
        const found = await this.findOne(options);
        if (found) return [
            found,
            false
        ];
        try {
            const createOptions = __spreadValues({}, options);
            if (this.sequelize.options.dialect === "postgres" && options.transaction) {
                createOptions.ignoreDuplicates = true;
            }
            const created = await this.create(values, createOptions);
            return [
                created,
                true
            ];
        } catch (err) {
            if (!(err instanceof sequelizeErrors.UniqueConstraintError || err instanceof sequelizeErrors.EmptyResultError)) {
                throw err;
            }
            const foundAgain = await this.findOne(options);
            return [
                foundAgain,
                false
            ];
        }
    }
    static async upsert(values, options) {
        options = __spreadValues({
            hooks: true,
            returning: true,
            validate: true
        }, Utils.cloneDeep(options));
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        const createdAtAttr = this._timestampAttributes.createdAt;
        const updatedAtAttr = this._timestampAttributes.updatedAt;
        const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;
        const instance = this.build(values);
        options.model = this;
        options.instance = instance;
        const changed = Array.from(instance._changed);
        if (!options.fields) {
            options.fields = changed;
        }
        if (options.validate) {
            await instance.validate(options);
        }
        const updatedDataValues = _.pick(instance.dataValues, changed);
        const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);
        const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);
        const now = Utils.now(this.sequelize.options.dialect);
        if (createdAtAttr && !insertValues[createdAtAttr]) {
            const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;
            insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;
        }
        if (updatedAtAttr && !insertValues[updatedAtAttr]) {
            const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
            insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;
        }
        if (this.sequelize.options.dialect === "db2") {
            this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(insertValues, this.rawAttributes, this.uniqno);
        }
        if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {
            delete insertValues[this.primaryKeyField];
            delete updateValues[this.primaryKeyField];
        }
        if (options.hooks) {
            await this.runHooks("beforeUpsert", values, options);
        }
        const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);
        const [record] = result;
        record.isNewRecord = false;
        if (options.hooks) {
            await this.runHooks("afterUpsert", result, options);
            return result;
        }
        return result;
    }
    static async bulkCreate(records, options = {}) {
        if (!records.length) {
            return [];
        }
        const dialect = this.sequelize.options.dialect;
        const now = Utils.now(this.sequelize.options.dialect);
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        options.model = this;
        if (!options.includeValidated) {
            this._conformIncludes(options, this);
            if (options.include) {
                this._expandIncludeAll(options);
                this._validateIncludedElements(options);
            }
        }
        const instances = records.map((values)=>this.build(values, {
                isNewRecord: true,
                include: options.include
            }));
        const recursiveBulkCreate = async (instances2, options2)=>{
            options2 = __spreadValues({
                validate: false,
                hooks: true,
                individualHooks: false,
                ignoreDuplicates: false
            }, options2);
            if (options2.returning === void 0) {
                if (options2.association) {
                    options2.returning = false;
                } else {
                    options2.returning = true;
                }
            }
            if (options2.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.onConflictDoNothing) {
                throw new Error(`${dialect} does not support the ignoreDuplicates option.`);
            }
            if (options2.updateOnDuplicate && dialect !== "mysql" && dialect !== "mariadb" && dialect !== "sqlite" && dialect !== "postgres") {
                throw new Error(`${dialect} does not support the updateOnDuplicate option.`);
            }
            const model = options2.model;
            options2.fields = options2.fields || Object.keys(model.rawAttributes);
            const createdAtAttr = model._timestampAttributes.createdAt;
            const updatedAtAttr = model._timestampAttributes.updatedAt;
            if (options2.updateOnDuplicate !== void 0) {
                if (Array.isArray(options2.updateOnDuplicate) && options2.updateOnDuplicate.length) {
                    options2.updateOnDuplicate = _.intersection(_.without(Object.keys(model.tableAttributes), createdAtAttr), options2.updateOnDuplicate);
                } else {
                    throw new Error("updateOnDuplicate option only supports non-empty array.");
                }
            }
            if (options2.hooks) {
                await model.runHooks("beforeBulkCreate", instances2, options2);
            }
            if (options2.validate) {
                const errors = [];
                const validateOptions = __spreadValues({}, options2);
                validateOptions.hooks = options2.individualHooks;
                await Promise.all(instances2.map(async (instance)=>{
                    try {
                        await instance.validate(validateOptions);
                    } catch (err) {
                        errors.push(new sequelizeErrors.BulkRecordError(err, instance));
                    }
                }));
                delete options2.skip;
                if (errors.length) {
                    throw new sequelizeErrors.AggregateError(errors);
                }
            }
            if (options2.individualHooks) {
                await Promise.all(instances2.map(async (instance)=>{
                    const individualOptions = __spreadProps(__spreadValues({}, options2), {
                        validate: false,
                        hooks: true
                    });
                    delete individualOptions.fields;
                    delete individualOptions.individualHooks;
                    delete individualOptions.ignoreDuplicates;
                    await instance.save(individualOptions);
                }));
            } else {
                if (options2.include && options2.include.length) {
                    await Promise.all(options2.include.filter((include)=>include.association instanceof BelongsTo).map(async (include)=>{
                        const associationInstances = [];
                        const associationInstanceIndexToInstanceMap = [];
                        for (const instance of instances2){
                            const associationInstance = instance.get(include.as);
                            if (associationInstance) {
                                associationInstances.push(associationInstance);
                                associationInstanceIndexToInstanceMap.push(instance);
                            }
                        }
                        if (!associationInstances.length) {
                            return;
                        }
                        const includeOptions = _(Utils.cloneDeep(include)).omit([
                            "association"
                        ]).defaults({
                            transaction: options2.transaction,
                            logging: options2.logging
                        }).value();
                        const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
                        for(const idx in createdAssociationInstances){
                            const associationInstance = createdAssociationInstances[idx];
                            const instance = associationInstanceIndexToInstanceMap[idx];
                            await include.association.set(instance, associationInstance, {
                                save: false,
                                logging: options2.logging
                            });
                        }
                    }));
                }
                records = instances2.map((instance)=>{
                    const values = instance.dataValues;
                    if (createdAtAttr && !values[createdAtAttr]) {
                        values[createdAtAttr] = now;
                        if (!options2.fields.includes(createdAtAttr)) {
                            options2.fields.push(createdAtAttr);
                        }
                    }
                    if (updatedAtAttr && !values[updatedAtAttr]) {
                        values[updatedAtAttr] = now;
                        if (!options2.fields.includes(updatedAtAttr)) {
                            options2.fields.push(updatedAtAttr);
                        }
                    }
                    const out = Utils.mapValueFieldNames(values, options2.fields, model);
                    for (const key of model._virtualAttributes){
                        delete out[key];
                    }
                    return out;
                });
                const fieldMappedAttributes = {};
                for(const attr in model.tableAttributes){
                    fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];
                }
                if (options2.updateOnDuplicate) {
                    options2.updateOnDuplicate = options2.updateOnDuplicate.map((attr)=>model.rawAttributes[attr].field || attr);
                    if (options2.conflictAttributes) {
                        options2.upsertKeys = options2.conflictAttributes.map((attrName)=>model.rawAttributes[attrName].field || attrName);
                    } else {
                        const upsertKeys = [];
                        for (const i of model._indexes){
                            if (i.unique && !i.where) {
                                upsertKeys.push(...i.fields);
                            }
                        }
                        const firstUniqueKey = Object.values(model.uniqueKeys).find((c)=>c.fields.length > 0);
                        if (firstUniqueKey && firstUniqueKey.fields) {
                            upsertKeys.push(...firstUniqueKey.fields);
                        }
                        options2.upsertKeys = upsertKeys.length > 0 ? upsertKeys : Object.values(model.primaryKeys).map((x)=>x.field);
                    }
                }
                if (options2.returning && Array.isArray(options2.returning)) {
                    options2.returning = options2.returning.map((attr)=>_.get(model.rawAttributes[attr], "field", attr));
                }
                const results = await model.queryInterface.bulkInsert(model.getTableName(options2), records, options2, fieldMappedAttributes);
                if (Array.isArray(results)) {
                    results.forEach((result, i)=>{
                        const instance = instances2[i];
                        for(const key in result){
                            if (!instance || key === model.primaryKeyAttribute && instance.get(model.primaryKeyAttribute) && [
                                "mysql",
                                "mariadb",
                                "sqlite"
                            ].includes(dialect)) {
                                continue;
                            }
                            if (Object.prototype.hasOwnProperty.call(result, key)) {
                                const record = result[key];
                                const attr = _.find(model.rawAttributes, (attribute)=>attribute.fieldName === key || attribute.field === key);
                                instance.dataValues[attr && attr.fieldName || key] = record;
                            }
                        }
                    });
                }
            }
            if (options2.include && options2.include.length) {
                await Promise.all(options2.include.filter((include)=>!(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include)=>{
                    const associationInstances = [];
                    const associationInstanceIndexToInstanceMap = [];
                    for (const instance of instances2){
                        let associated = instance.get(include.as);
                        if (!Array.isArray(associated)) associated = [
                            associated
                        ];
                        for (const associationInstance of associated){
                            if (associationInstance) {
                                if (!(include.association instanceof BelongsToMany)) {
                                    associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, {
                                        raw: true
                                    }), {
                                        raw: true
                                    });
                                    Object.assign(associationInstance, include.association.scope);
                                }
                                associationInstances.push(associationInstance);
                                associationInstanceIndexToInstanceMap.push(instance);
                            }
                        }
                    }
                    if (!associationInstances.length) {
                        return;
                    }
                    const includeOptions = _(Utils.cloneDeep(include)).omit([
                        "association"
                    ]).defaults({
                        transaction: options2.transaction,
                        logging: options2.logging
                    }).value();
                    const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);
                    if (include.association instanceof BelongsToMany) {
                        const valueSets = [];
                        for(const idx in createdAssociationInstances){
                            const associationInstance = createdAssociationInstances[idx];
                            const instance = associationInstanceIndexToInstanceMap[idx];
                            const values = __spreadValues({
                                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, {
                                    raw: true
                                }),
                                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, {
                                    raw: true
                                })
                            }, include.association.through.scope);
                            if (associationInstance[include.association.through.model.name]) {
                                for (const attr of Object.keys(include.association.through.model.rawAttributes)){
                                    if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof associationInstance[include.association.through.model.name][attr] === "undefined") {
                                        continue;
                                    }
                                    values[attr] = associationInstance[include.association.through.model.name][attr];
                                }
                            }
                            valueSets.push(values);
                        }
                        const throughOptions = _(Utils.cloneDeep(include)).omit([
                            "association",
                            "attributes"
                        ]).defaults({
                            transaction: options2.transaction,
                            logging: options2.logging
                        }).value();
                        throughOptions.model = include.association.throughModel;
                        const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);
                        await recursiveBulkCreate(throughInstances, throughOptions);
                    }
                }));
            }
            instances2.forEach((instance)=>{
                for(const attr in model.rawAttributes){
                    if (model.rawAttributes[attr].field && instance.dataValues[model.rawAttributes[attr].field] !== void 0 && model.rawAttributes[attr].field !== attr) {
                        instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];
                        delete instance.dataValues[model.rawAttributes[attr].field];
                    }
                    instance._previousDataValues[attr] = instance.dataValues[attr];
                    instance.changed(attr, false);
                }
                instance.isNewRecord = false;
            });
            if (options2.hooks) {
                await model.runHooks("afterBulkCreate", instances2, options2);
            }
            return instances2;
        };
        return await recursiveBulkCreate(instances, options);
    }
    static async truncate(options) {
        options = Utils.cloneDeep(options) || {};
        options.truncate = true;
        return await this.destroy(options);
    }
    static async destroy(options) {
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        this._injectScope(options);
        if (!options || !(options.where || options.truncate)) {
            throw new Error("Missing where or truncate attribute in the options parameter of model.destroy.");
        }
        if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {
            throw new Error("Expected plain object, array or sequelize method in the options.where parameter of model.destroy.");
        }
        options = _.defaults(options, {
            hooks: true,
            individualHooks: false,
            force: false,
            cascade: false,
            restartIdentity: false
        });
        options.type = QueryTypes.BULKDELETE;
        Utils.mapOptionFieldNames(options, this);
        options.model = this;
        if (options.hooks) {
            await this.runHooks("beforeBulkDestroy", options);
        }
        let instances;
        if (options.individualHooks) {
            instances = await this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark
            });
            await Promise.all(instances.map((instance)=>this.runHooks("beforeDestroy", instance, options)));
        }
        let result;
        if (this._timestampAttributes.deletedAt && !options.force) {
            options.type = QueryTypes.BULKUPDATE;
            const attrValueHash = {};
            const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];
            const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;
            const where = {
                [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null
            };
            attrValueHash[field] = Utils.now(this.sequelize.options.dialect);
            result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);
        } else {
            result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);
        }
        if (options.individualHooks) {
            await Promise.all(instances.map((instance)=>this.runHooks("afterDestroy", instance, options)));
        }
        if (options.hooks) {
            await this.runHooks("afterBulkDestroy", options);
        }
        return result;
    }
    static async restore(options) {
        if (!this._timestampAttributes.deletedAt) throw new Error("Model is not paranoid");
        options = __spreadValues({
            hooks: true,
            individualHooks: false
        }, options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        options.type = QueryTypes.RAW;
        options.model = this;
        Utils.mapOptionFieldNames(options, this);
        if (options.hooks) {
            await this.runHooks("beforeBulkRestore", options);
        }
        let instances;
        if (options.individualHooks) {
            instances = await this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark,
                paranoid: false
            });
            await Promise.all(instances.map((instance)=>this.runHooks("beforeRestore", instance, options)));
        }
        const attrValueHash = {};
        const deletedAtCol = this._timestampAttributes.deletedAt;
        const deletedAtAttribute = this.rawAttributes[deletedAtCol];
        const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
        attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;
        options.omitNull = false;
        const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);
        if (options.individualHooks) {
            await Promise.all(instances.map((instance)=>this.runHooks("afterRestore", instance, options)));
        }
        if (options.hooks) {
            await this.runHooks("afterBulkRestore", options);
        }
        return result;
    }
    static async update(values, options) {
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        this._injectScope(options);
        this._optionsMustContainWhere(options);
        options = this._paranoidClause(this, _.defaults(options, {
            validate: true,
            hooks: true,
            individualHooks: false,
            returning: false,
            force: false,
            sideEffects: true
        }));
        options.type = QueryTypes.BULKUPDATE;
        values = _.omitBy(values, (value)=>value === void 0);
        if (options.fields && options.fields instanceof Array) {
            for (const key of Object.keys(values)){
                if (!options.fields.includes(key)) {
                    delete values[key];
                }
            }
        } else {
            const updatedAtAttr = this._timestampAttributes.updatedAt;
            options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));
            if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {
                options.fields.push(updatedAtAttr);
            }
        }
        if (this._timestampAttributes.updatedAt && !options.silent) {
            values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);
        }
        options.model = this;
        let valuesUse;
        if (options.validate) {
            const build = this.build(values);
            build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], {
                raw: true
            });
            if (options.sideEffects) {
                Object.assign(values, _.pick(build.get(), build.changed()));
                options.fields = _.union(options.fields, Object.keys(values));
            }
            options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));
            const attributes = await build.validate(options);
            options.skip = void 0;
            if (attributes && attributes.dataValues) {
                values = _.pick(attributes.dataValues, Object.keys(values));
            }
        }
        if (options.hooks) {
            options.attributes = values;
            await this.runHooks("beforeBulkUpdate", options);
            values = options.attributes;
            delete options.attributes;
        }
        valuesUse = values;
        let instances;
        let updateDoneRowByRow = false;
        if (options.individualHooks) {
            instances = await this.findAll({
                where: options.where,
                transaction: options.transaction,
                logging: options.logging,
                benchmark: options.benchmark,
                paranoid: options.paranoid
            });
            if (instances.length) {
                let changedValues;
                let different = false;
                instances = await Promise.all(instances.map(async (instance)=>{
                    Object.assign(instance.dataValues, values);
                    _.forIn(valuesUse, (newValue, attr)=>{
                        if (newValue !== instance._previousDataValues[attr]) {
                            instance.setDataValue(attr, newValue);
                        }
                    });
                    await this.runHooks("beforeUpdate", instance, options);
                    if (!different) {
                        const thisChangedValues = {};
                        _.forIn(instance.dataValues, (newValue, attr)=>{
                            if (newValue !== instance._previousDataValues[attr]) {
                                thisChangedValues[attr] = newValue;
                            }
                        });
                        if (!changedValues) {
                            changedValues = thisChangedValues;
                        } else {
                            different = !_.isEqual(changedValues, thisChangedValues);
                        }
                    }
                    return instance;
                }));
                if (!different) {
                    const keys = Object.keys(changedValues);
                    if (keys.length) {
                        valuesUse = changedValues;
                        options.fields = _.union(options.fields, keys);
                    }
                } else {
                    instances = await Promise.all(instances.map(async (instance)=>{
                        const individualOptions = __spreadProps(__spreadValues({}, options), {
                            hooks: false,
                            validate: false
                        });
                        delete individualOptions.individualHooks;
                        return instance.save(individualOptions);
                    }));
                    updateDoneRowByRow = true;
                }
            }
        }
        let result;
        if (updateDoneRowByRow) {
            result = [
                instances.length,
                instances
            ];
        } else if (_.isEmpty(valuesUse) || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {
            result = [
                0
            ];
        } else {
            valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);
            options = Utils.mapOptionFieldNames(options, this);
            options.hasTrigger = this.options ? this.options.hasTrigger : false;
            const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);
            if (options.returning) {
                result = [
                    affectedRows.length,
                    affectedRows
                ];
                instances = affectedRows;
            } else {
                result = [
                    affectedRows
                ];
            }
        }
        if (options.individualHooks) {
            await Promise.all(instances.map((instance)=>this.runHooks("afterUpdate", instance, options)));
            result[1] = instances;
        }
        if (options.hooks) {
            options.attributes = values;
            await this.runHooks("afterBulkUpdate", options);
            delete options.attributes;
        }
        return result;
    }
    static async describe(schema, options) {
        return await this.queryInterface.describeTable(this.tableName, __spreadValues({
            schema: schema || this._schema || void 0
        }, options));
    }
    static _getDefaultTimestamp(attr) {
        if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {
            return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);
        }
        return void 0;
    }
    static _expandAttributes(options) {
        if (!_.isPlainObject(options.attributes)) {
            return;
        }
        let attributes = Object.keys(this.rawAttributes);
        if (options.attributes.exclude) {
            attributes = attributes.filter((elem)=>!options.attributes.exclude.includes(elem));
        }
        if (options.attributes.include) {
            attributes = attributes.concat(options.attributes.include);
        }
        options.attributes = attributes;
    }
    static _injectScope(options) {
        const scope = Utils.cloneDeep(this._scope);
        this._defaultsOptions(options, scope);
    }
    static [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.name;
    }
    static hasAlias(alias) {
        return Object.prototype.hasOwnProperty.call(this.associations, alias);
    }
    static async increment(fields, options) {
        options = options || {};
        if (typeof fields === "string") fields = [
            fields
        ];
        if (Array.isArray(fields)) {
            fields = fields.map((f)=>{
                if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {
                    return this.rawAttributes[f].field;
                }
                return f;
            });
        } else if (fields && typeof fields === "object") {
            fields = Object.keys(fields).reduce((rawFields, f)=>{
                if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {
                    rawFields[this.rawAttributes[f].field] = fields[f];
                } else {
                    rawFields[f] = fields[f];
                }
                return rawFields;
            }, {});
        }
        this._injectScope(options);
        this._optionsMustContainWhere(options);
        options = Utils.defaults({}, options, {
            by: 1,
            where: {},
            increment: true
        });
        const isSubtraction = !options.increment;
        Utils.mapOptionFieldNames(options, this);
        const where = __spreadValues({}, options.where);
        let incrementAmountsByField = {};
        if (Array.isArray(fields)) {
            incrementAmountsByField = {};
            for (const field of fields){
                incrementAmountsByField[field] = options.by;
            }
        } else {
            incrementAmountsByField = fields;
        }
        if (this._versionAttribute) {
            incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;
        }
        const extraAttributesToBeUpdated = {};
        const updatedAtAttr = this._timestampAttributes.updatedAt;
        if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {
            const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;
            extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);
        }
        const tableName = this.getTableName(options);
        let affectedRows;
        if (isSubtraction) {
            affectedRows = await this.queryInterface.decrement(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);
        } else {
            affectedRows = await this.queryInterface.increment(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);
        }
        if (options.returning) {
            return [
                affectedRows,
                affectedRows.length
            ];
        }
        return [
            affectedRows
        ];
    }
    static async decrement(fields, options) {
        return this.increment(fields, __spreadProps(__spreadValues({
            by: 1
        }, options), {
            increment: false
        }));
    }
    static _optionsMustContainWhere(options) {
        assert(options && options.where, "Missing where attribute in the options parameter");
        assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod, "Expected plain object, array or sequelize method in the options.where parameter");
    }
    where(checkVersion) {
        const where = this.constructor.primaryKeyAttributes.reduce((result, attribute)=>{
            result[attribute] = this.get(attribute, {
                raw: true
            });
            return result;
        }, {});
        if (_.size(where) === 0) {
            return this.constructor.options.whereCollection;
        }
        const versionAttr = this.constructor._versionAttribute;
        if (checkVersion && versionAttr) {
            where[versionAttr] = this.get(versionAttr, {
                raw: true
            });
        }
        return Utils.mapWhereFieldNames(where, this.constructor);
    }
    toString() {
        return `[object SequelizeInstance:${this.constructor.name}]`;
    }
    getDataValue(key) {
        return this.dataValues[key];
    }
    setDataValue(key, value) {
        const originalValue = this._previousDataValues[key];
        if (!_.isEqual(value, originalValue)) {
            this.changed(key, true);
        }
        this.dataValues[key] = value;
    }
    get(key, options) {
        if (options === void 0 && typeof key === "object") {
            options = key;
            key = void 0;
        }
        options = options || {};
        if (key) {
            if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {
                return this._customGetters[key].call(this, key, options);
            }
            if (options.plain && this._options.include && this._options.includeNames.includes(key)) {
                if (Array.isArray(this.dataValues[key])) {
                    return this.dataValues[key].map((instance)=>instance.get(options));
                }
                if (this.dataValues[key] instanceof Model) {
                    return this.dataValues[key].get(options);
                }
                return this.dataValues[key];
            }
            return this.dataValues[key];
        }
        if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {
            const values = {};
            let _key;
            if (this._hasCustomGetters) {
                for(_key in this._customGetters){
                    if (this._options.attributes && !this._options.attributes.includes(_key)) {
                        continue;
                    }
                    if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {
                        values[_key] = this.get(_key, options);
                    }
                }
            }
            for(_key in this.dataValues){
                if (!Object.prototype.hasOwnProperty.call(values, _key) && Object.prototype.hasOwnProperty.call(this.dataValues, _key)) {
                    values[_key] = this.get(_key, options);
                }
            }
            return values;
        }
        return this.dataValues;
    }
    set(key, value, options) {
        let values;
        let originalValue;
        if (typeof key === "object" && key !== null) {
            values = key;
            options = value || {};
            if (options.reset) {
                this.dataValues = {};
                for(const key2 in values){
                    this.changed(key2, false);
                }
            }
            if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {
                if (Object.keys(this.dataValues).length) {
                    Object.assign(this.dataValues, values);
                } else {
                    this.dataValues = values;
                }
                this._previousDataValues = __spreadValues({}, this.dataValues);
            } else {
                if (options.attributes) {
                    const setKeys = (data)=>{
                        for (const k of data){
                            if (values[k] === void 0) {
                                continue;
                            }
                            this.set(k, values[k], options);
                        }
                    };
                    setKeys(options.attributes);
                    if (this.constructor._hasVirtualAttributes) {
                        setKeys(this.constructor._virtualAttributes);
                    }
                    if (this._options.includeNames) {
                        setKeys(this._options.includeNames);
                    }
                } else {
                    for(const key2 in values){
                        this.set(key2, values[key2], options);
                    }
                }
                if (options.raw) {
                    this._previousDataValues = __spreadValues({}, this.dataValues);
                }
            }
            return this;
        }
        if (!options) options = {};
        if (!options.raw) {
            originalValue = this.dataValues[key];
        }
        if (!options.raw && this._customSetters[key]) {
            this._customSetters[key].call(this, value, key);
            const newValue = this.dataValues[key];
            if (!_.isEqual(newValue, originalValue)) {
                this._previousDataValues[key] = originalValue;
                this.changed(key, true);
            }
        } else {
            if (this._options && this._options.include && this._options.includeNames.includes(key)) {
                this._setInclude(key, value, options);
                return this;
            }
            if (!options.raw) {
                if (!this._isAttribute(key)) {
                    if (key.includes(".") && this.constructor._jsonAttributes.has(key.split(".")[0])) {
                        const previousNestedValue = Dottie.get(this.dataValues, key);
                        if (!_.isEqual(previousNestedValue, value)) {
                            Dottie.set(this.dataValues, key, value);
                            this.changed(key.split(".")[0], true);
                        }
                    }
                    return this;
                }
                if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {
                    return this;
                }
                if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {
                    return this;
                }
            }
            if (!(value instanceof Utils.SequelizeMethod) && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)) {
                value = this.constructor._dataTypeSanitizers[key].call(this, value, options);
            }
            if (!options.raw && (value instanceof Utils.SequelizeMethod || !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))) {
                this._previousDataValues[key] = originalValue;
                this.changed(key, true);
            }
            this.dataValues[key] = value;
        }
        return this;
    }
    setAttributes(updates) {
        return this.set(updates);
    }
    changed(key, value) {
        if (key === void 0) {
            if (this._changed.size > 0) {
                return Array.from(this._changed);
            }
            return false;
        }
        if (value === true) {
            this._changed.add(key);
            return this;
        }
        if (value === false) {
            this._changed.delete(key);
            return this;
        }
        return this._changed.has(key);
    }
    previous(key) {
        if (key) {
            return this._previousDataValues[key];
        }
        return _.pickBy(this._previousDataValues, (value, key2)=>this.changed(key2));
    }
    _setInclude(key, value, options) {
        if (!Array.isArray(value)) value = [
            value
        ];
        if (value[0] instanceof Model) {
            value = value.map((instance)=>instance.dataValues);
        }
        const include = this._options.includeMap[key];
        const association = include.association;
        const accessor = key;
        const primaryKeyAttribute = include.model.primaryKeyAttribute;
        const childOptions = {
            isNewRecord: this.isNewRecord,
            include: include.include,
            includeNames: include.includeNames,
            includeMap: include.includeMap,
            includeValidated: true,
            raw: options.raw,
            attributes: include.originalAttributes
        };
        let isEmpty;
        if (include.originalAttributes === void 0 || include.originalAttributes.length) {
            if (association.isSingleAssociation) {
                if (Array.isArray(value)) {
                    value = value[0];
                }
                isEmpty = value && value[primaryKeyAttribute] === null || value === null;
                this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);
            } else {
                isEmpty = value[0] && value[0][primaryKeyAttribute] === null;
                this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);
            }
        }
    }
    async save(options) {
        if (arguments.length > 1) {
            throw new Error("The second argument was removed in favor of the options object.");
        }
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        options = _.defaults(options, {
            hooks: true,
            validate: true
        });
        if (!options.fields) {
            if (this.isNewRecord) {
                options.fields = Object.keys(this.constructor.rawAttributes);
            } else {
                options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));
            }
            options.defaultFields = options.fields;
        }
        if (options.returning === void 0) {
            if (options.association) {
                options.returning = false;
            } else if (this.isNewRecord) {
                options.returning = true;
            }
        }
        const primaryKeyName = this.constructor.primaryKeyAttribute;
        const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];
        const createdAtAttr = this.constructor._timestampAttributes.createdAt;
        const versionAttr = this.constructor._versionAttribute;
        const hook = this.isNewRecord ? "Create" : "Update";
        const wasNewRecord = this.isNewRecord;
        const now = Utils.now(this.sequelize.options.dialect);
        let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;
        if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {
            options.fields.push(updatedAtAttr);
        }
        if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {
            options.fields.push(versionAttr);
        }
        if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, {
            raw: true
        }))) {
            _.remove(options.fields, (val)=>val === updatedAtAttr);
            updatedAtAttr = false;
        }
        if (this.isNewRecord === true) {
            if (createdAtAttr && !options.fields.includes(createdAtAttr)) {
                options.fields.push(createdAtAttr);
            }
            if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {
                options.fields.unshift(primaryKeyName);
            }
        }
        if (this.isNewRecord === false) {
            if (primaryKeyName && this.get(primaryKeyName, {
                raw: true
            }) === void 0) {
                throw new Error("You attempted to save an instance with no primary key, this is not allowed since it would result in a global update");
            }
        }
        if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {
            this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;
        }
        if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {
            this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;
        }
        if (this.sequelize.options.dialect === "db2" && this.isNewRecord) {
            this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(this.dataValues, this.constructor.rawAttributes, this.uniqno);
        }
        if (options.validate) {
            await this.validate(options);
        }
        if (options.hooks) {
            const beforeHookValues = _.pick(this.dataValues, options.fields);
            let ignoreChanged = _.difference(this.changed(), options.fields);
            let hookChanged;
            let afterHookValues;
            if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {
                ignoreChanged = _.without(ignoreChanged, updatedAtAttr);
            }
            await this.constructor.runHooks(`before${hook}`, this, options);
            if (options.defaultFields && !this.isNewRecord) {
                afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));
                hookChanged = [];
                for (const key of Object.keys(afterHookValues)){
                    if (afterHookValues[key] !== beforeHookValues[key]) {
                        hookChanged.push(key);
                    }
                }
                options.fields = _.uniq(options.fields.concat(hookChanged));
            }
            if (hookChanged) {
                if (options.validate) {
                    options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);
                    await this.validate(options);
                    delete options.skip;
                }
            }
        }
        if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {
            await Promise.all(this._options.include.filter((include)=>include.association instanceof BelongsTo).map(async (include)=>{
                const instance = this.get(include.as);
                if (!instance) return;
                const includeOptions = _(Utils.cloneDeep(include)).omit([
                    "association"
                ]).defaults({
                    transaction: options.transaction,
                    logging: options.logging,
                    parentRecord: this
                }).value();
                await instance.save(includeOptions);
                await this[include.association.accessors.set](instance, {
                    save: false,
                    logging: options.logging
                });
            }));
        }
        const realFields = options.fields.filter((field)=>!this.constructor._virtualAttributes.has(field));
        if (!realFields.length) return this;
        if (!this.changed() && !this.isNewRecord) return this;
        const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], "field") || versionAttr;
        const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);
        let query = null;
        let args = [];
        let where;
        if (this.isNewRecord) {
            query = "insert";
            args = [
                this,
                this.constructor.getTableName(options),
                values,
                options
            ];
        } else {
            where = this.where(true);
            if (versionAttr) {
                values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;
            }
            query = "update";
            args = [
                this,
                this.constructor.getTableName(options),
                values,
                where,
                options
            ];
        }
        const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);
        if (versionAttr) {
            if (rowsUpdated < 1) {
                throw new sequelizeErrors.OptimisticLockError({
                    modelName: this.constructor.name,
                    values,
                    where
                });
            } else {
                result.dataValues[versionAttr] = values[versionFieldName];
            }
        }
        for (const attr of Object.keys(this.constructor.rawAttributes)){
            if (this.constructor.rawAttributes[attr].field && values[this.constructor.rawAttributes[attr].field] !== void 0 && this.constructor.rawAttributes[attr].field !== attr) {
                values[attr] = values[this.constructor.rawAttributes[attr].field];
                delete values[this.constructor.rawAttributes[attr].field];
            }
        }
        Object.assign(values, result.dataValues);
        Object.assign(result.dataValues, values);
        if (wasNewRecord && this._options.include && this._options.include.length) {
            await Promise.all(this._options.include.filter((include)=>!(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include)=>{
                let instances = this.get(include.as);
                if (!instances) return;
                if (!Array.isArray(instances)) instances = [
                    instances
                ];
                const includeOptions = _(Utils.cloneDeep(include)).omit([
                    "association"
                ]).defaults({
                    transaction: options.transaction,
                    logging: options.logging,
                    parentRecord: this
                }).value();
                await Promise.all(instances.map(async (instance)=>{
                    if (include.association instanceof BelongsToMany) {
                        await instance.save(includeOptions);
                        const values0 = __spreadValues({
                            [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, {
                                raw: true
                            }),
                            [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, {
                                raw: true
                            })
                        }, include.association.through.scope);
                        if (instance[include.association.through.model.name]) {
                            for (const attr of Object.keys(include.association.through.model.rawAttributes)){
                                if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof instance[include.association.through.model.name][attr] === "undefined") {
                                    continue;
                                }
                                values0[attr] = instance[include.association.through.model.name][attr];
                            }
                        }
                        await include.association.throughModel.create(values0, includeOptions);
                    } else {
                        instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, {
                            raw: true
                        }), {
                            raw: true
                        });
                        Object.assign(instance, include.association.scope);
                        await instance.save(includeOptions);
                    }
                }));
            }));
        }
        if (options.hooks) {
            await this.constructor.runHooks(`after${hook}`, result, options);
        }
        for (const field of options.fields){
            result._previousDataValues[field] = result.dataValues[field];
            this.changed(field, false);
        }
        this.isNewRecord = false;
        return result;
    }
    async reload(options) {
        options = Utils.defaults({
            where: this.where()
        }, options, {
            include: this._options.include || void 0
        });
        const reloaded = await this.constructor.findOne(options);
        if (!reloaded) {
            throw new sequelizeErrors.InstanceError("Instance could not be reloaded because it does not exist anymore (find call returned null)");
        }
        this._options = reloaded._options;
        this.set(reloaded.dataValues, {
            raw: true,
            reset: !options.attributes
        });
        return this;
    }
    async validate(options) {
        return new InstanceValidator(this, options).validate();
    }
    async update(values, options) {
        values = _.omitBy(values, (value)=>value === void 0);
        const changedBefore = this.changed() || [];
        options = options || {};
        if (Array.isArray(options)) options = {
            fields: options
        };
        options = Utils.cloneDeep(options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        const setOptions = Utils.cloneDeep(options);
        setOptions.attributes = options.fields;
        this.set(values, setOptions);
        const sideEffects = _.without(this.changed(), ...changedBefore);
        const fields = _.union(Object.keys(values), sideEffects);
        if (!options.fields) {
            options.fields = _.intersection(fields, this.changed());
            options.defaultFields = options.fields;
        }
        return await this.save(options);
    }
    async destroy(options) {
        options = __spreadValues({
            hooks: true,
            force: false
        }, options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        if (options.hooks) {
            await this.constructor.runHooks("beforeDestroy", this, options);
        }
        const where = this.where(true);
        let result;
        if (this.constructor._timestampAttributes.deletedAt && options.force === false) {
            const attributeName = this.constructor._timestampAttributes.deletedAt;
            const attribute = this.constructor.rawAttributes[attributeName];
            const defaultValue = Object.prototype.hasOwnProperty.call(attribute, "defaultValue") ? attribute.defaultValue : null;
            const currentValue = this.getDataValue(attributeName);
            const undefinedOrNull = currentValue == null && defaultValue == null;
            if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {
                this.setDataValue(attributeName, new Date());
            }
            result = await this.save(__spreadProps(__spreadValues({}, options), {
                hooks: false
            }));
        } else {
            result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, __spreadValues({
                type: QueryTypes.DELETE,
                limit: null
            }, options));
        }
        if (options.hooks) {
            await this.constructor.runHooks("afterDestroy", this, options);
        }
        return result;
    }
    isSoftDeleted() {
        if (!this.constructor._timestampAttributes.deletedAt) {
            throw new Error("Model is not paranoid");
        }
        const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];
        const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
        const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;
        const isSet = deletedAt !== defaultValue;
        return isSet;
    }
    async restore(options) {
        if (!this.constructor._timestampAttributes.deletedAt) throw new Error("Model is not paranoid");
        options = __spreadValues({
            hooks: true,
            force: false
        }, options);
        if (options.transaction === void 0 && this.sequelize.constructor._cls) {
            const t = this.sequelize.constructor._cls.get("transaction");
            if (t) {
                options.transaction = t;
            }
        }
        if (options.hooks) {
            await this.constructor.runHooks("beforeRestore", this, options);
        }
        const deletedAtCol = this.constructor._timestampAttributes.deletedAt;
        const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];
        const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, "defaultValue") ? deletedAtAttribute.defaultValue : null;
        this.setDataValue(deletedAtCol, deletedAtDefaultValue);
        const result = await this.save(__spreadProps(__spreadValues({}, options), {
            hooks: false,
            omitNull: false
        }));
        if (options.hooks) {
            await this.constructor.runHooks("afterRestore", this, options);
            return result;
        }
        return result;
    }
    async increment(fields, options) {
        const identifier = this.where();
        options = Utils.cloneDeep(options);
        options.where = __spreadValues(__spreadValues({}, options.where), identifier);
        options.instance = this;
        await this.constructor.increment(fields, options);
        return this;
    }
    async decrement(fields, options) {
        return this.increment(fields, __spreadProps(__spreadValues({
            by: 1
        }, options), {
            increment: false
        }));
    }
    equals(other) {
        if (!other || !other.constructor) {
            return false;
        }
        if (!(other instanceof this.constructor)) {
            return false;
        }
        return this.constructor.primaryKeyAttributes.every((attribute)=>this.get(attribute, {
                raw: true
            }) === other.get(attribute, {
                raw: true
            }));
    }
    equalsOneOf(others) {
        return others.some((other)=>this.equals(other));
    }
    setValidators(attribute, validators) {
        this.validators[attribute] = validators;
    }
    toJSON() {
        return _.cloneDeep(this.get({
            plain: true
        }));
    }
    static hasMany(target, options) {}
    static belongsToMany(target, options) {}
    static hasOne(target, options) {}
    static belongsTo(target, options) {}
}
function unpackAnd(where) {
    if (!_.isObject(where)) {
        return where;
    }
    const keys = Utils.getComplexKeys(where);
    if (keys.length === 0) {
        return;
    }
    if (keys.length !== 1 || keys[0] !== Op.and) {
        return where;
    }
    const andParts = where[Op.and];
    return andParts;
}
function combineWheresWithAnd(whereA, whereB) {
    const unpackedA = unpackAnd(whereA);
    if (unpackedA === void 0) {
        return whereB;
    }
    const unpackedB = unpackAnd(whereB);
    if (unpackedB === void 0) {
        return whereA;
    }
    return {
        [Op.and]: _.flatten([
            unpackedA,
            unpackedB
        ])
    };
}
Object.assign(Model, associationsMixin);
Hooks.applyTo(Model, true);
module.exports = Model; //# sourceMappingURL=model.js.map
}),
"[project]/node_modules/sequelize/lib/deferrable.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { classToInvokable } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
class ABSTRACT {
    static toString(...args) {
        return new this().toString(...args);
    }
    toString(...args) {
        return this.toSql(...args);
    }
    toSql() {
        throw new Error("toSql implementation missing");
    }
}
class INITIALLY_DEFERRED extends ABSTRACT {
    toSql() {
        return "DEFERRABLE INITIALLY DEFERRED";
    }
}
class INITIALLY_IMMEDIATE extends ABSTRACT {
    toSql() {
        return "DEFERRABLE INITIALLY IMMEDIATE";
    }
}
class NOT extends ABSTRACT {
    toSql() {
        return "NOT DEFERRABLE";
    }
}
class SET_DEFERRED extends ABSTRACT {
    constructor(constraints){
        super();
        this.constraints = constraints;
    }
    toSql(queryGenerator) {
        return queryGenerator.setDeferredQuery(this.constraints);
    }
}
class SET_IMMEDIATE extends ABSTRACT {
    constructor(constraints){
        super();
        this.constraints = constraints;
    }
    toSql(queryGenerator) {
        return queryGenerator.setImmediateQuery(this.constraints);
    }
}
const Deferrable = {
    INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),
    INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),
    NOT: classToInvokable(NOT),
    SET_DEFERRED: classToInvokable(SET_DEFERRED),
    SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)
};
module.exports = Deferrable; //# sourceMappingURL=deferrable.js.map
}),
"[project]/node_modules/sequelize/lib/model-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Toposort = __turbopack_context__.r("[project]/node_modules/toposort-class/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
class ModelManager {
    constructor(sequelize){
        this.models = [];
        this.sequelize = sequelize;
    }
    addModel(model) {
        this.models.push(model);
        this.sequelize.models[model.name] = model;
        return model;
    }
    removeModel(modelToRemove) {
        this.models = this.models.filter((model)=>model.name !== modelToRemove.name);
        delete this.sequelize.models[modelToRemove.name];
    }
    getModel(against, options) {
        options = _.defaults(options || {}, {
            attribute: "name"
        });
        return this.models.find((model)=>model[options.attribute] === against);
    }
    findModel(callback) {
        return this.models.find(callback);
    }
    get all() {
        return this.models;
    }
    getModelsTopoSortedByForeignKey() {
        const models = /* @__PURE__ */ new Map();
        const sorter = new Toposort();
        for (const model of this.models){
            let deps = [];
            let tableName = model.getTableName();
            if (_.isObject(tableName)) {
                tableName = `${tableName.schema}.${tableName.tableName}`;
            }
            models.set(tableName, model);
            for(const attrName in model.rawAttributes){
                if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {
                    const attribute = model.rawAttributes[attrName];
                    if (attribute.references) {
                        let dep = attribute.references.model;
                        if (_.isObject(dep)) {
                            dep = `${dep.schema}.${dep.tableName}`;
                        }
                        deps.push(dep);
                    }
                }
            }
            deps = deps.filter((dep)=>tableName !== dep);
            sorter.add(tableName, deps);
        }
        let sorted;
        try {
            sorted = sorter.sort();
        } catch (e) {
            if (!e.message.startsWith("Cyclic dependency found.")) {
                throw e;
            }
            return null;
        }
        return sorted.map((modelName)=>{
            return models.get(modelName);
        }).filter(Boolean);
    }
    forEachModel(iterator, options) {
        const sortedModels = this.getModelsTopoSortedByForeignKey();
        if (sortedModels == null) {
            throw new Error("Cyclic dependency found.");
        }
        options = _.defaults(options || {}, {
            reverse: true
        });
        if (options.reverse) {
            sortedModels.reverse();
        }
        for (const model of sortedModels){
            iterator(model);
        }
    }
}
module.exports = ModelManager;
module.exports.ModelManager = ModelManager;
module.exports.default = ModelManager; //# sourceMappingURL=model-manager.js.map
}),
"[project]/node_modules/sequelize/lib/transaction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
class Transaction {
    constructor(sequelize, options){
        this.sequelize = sequelize;
        this.savepoints = [];
        this._afterCommitHooks = [];
        const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;
        this.options = __spreadValues({
            type: sequelize.options.transactionType,
            isolationLevel: sequelize.options.isolationLevel,
            readOnly: false
        }, options);
        this.parent = this.options.transaction;
        if (this.parent) {
            this.id = this.parent.id;
            this.parent.savepoints.push(this);
            this.name = `${this.id}-sp-${this.parent.savepoints.length}`;
        } else {
            this.id = this.name = generateTransactionId();
        }
        delete this.options.transaction;
    }
    async commit() {
        if (this.finished) {
            throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);
        }
        try {
            await this.sequelize.getQueryInterface().commitTransaction(this, this.options);
            this.cleanup();
        } catch (e) {
            console.warn(`Committing transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);
            await this.forceCleanup();
            throw e;
        } finally{
            this.finished = "commit";
            for (const hook of this._afterCommitHooks){
                await hook.apply(this, [
                    this
                ]);
            }
        }
    }
    async rollback() {
        if (this.finished) {
            throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);
        }
        if (!this.connection) {
            throw new Error("Transaction cannot be rolled back because it never started");
        }
        try {
            await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);
            this.cleanup();
        } catch (e) {
            console.warn(`Rolling back transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);
            await this.forceCleanup();
            throw e;
        }
    }
    async prepareEnvironment(useCLS = true) {
        let connectionPromise;
        if (this.parent) {
            connectionPromise = Promise.resolve(this.parent.connection);
        } else {
            const acquireOptions = {
                uuid: this.id
            };
            if (this.options.readOnly) {
                acquireOptions.type = "SELECT";
            }
            connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);
        }
        let result;
        const connection = await connectionPromise;
        this.connection = connection;
        this.connection.uuid = this.id;
        try {
            await this.begin();
            result = await this.setDeferrable();
        } catch (setupErr) {
            try {
                result = await this.rollback();
            } finally{
                throw setupErr;
            }
        }
        if (useCLS && this.sequelize.constructor._cls) {
            this.sequelize.constructor._cls.set("transaction", this);
        }
        return result;
    }
    async setDeferrable() {
        if (this.options.deferrable) {
            return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);
        }
    }
    async begin() {
        const queryInterface = this.sequelize.getQueryInterface();
        if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {
            await queryInterface.startTransaction(this, this.options);
            return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);
        }
        await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);
        return queryInterface.startTransaction(this, this.options);
    }
    cleanup() {
        if (this.parent || this.connection.uuid === void 0) {
            return;
        }
        this._clearCls();
        this.sequelize.connectionManager.releaseConnection(this.connection);
        this.connection.uuid = void 0;
    }
    async forceCleanup() {
        if (this.parent || this.connection.uuid === void 0) {
            return;
        }
        this._clearCls();
        await this.sequelize.connectionManager.destroyConnection(this.connection);
        this.connection.uuid = void 0;
    }
    _clearCls() {
        const cls = this.sequelize.constructor._cls;
        if (cls) {
            if (cls.get("transaction") === this) {
                cls.set("transaction", null);
            }
        }
    }
    afterCommit(fn) {
        if (!fn || typeof fn !== "function") {
            throw new Error('"fn" must be a function');
        }
        this._afterCommitHooks.push(fn);
    }
    static get TYPES() {
        return {
            DEFERRED: "DEFERRED",
            IMMEDIATE: "IMMEDIATE",
            EXCLUSIVE: "EXCLUSIVE"
        };
    }
    static get ISOLATION_LEVELS() {
        return {
            READ_UNCOMMITTED: "READ UNCOMMITTED",
            READ_COMMITTED: "READ COMMITTED",
            REPEATABLE_READ: "REPEATABLE READ",
            SERIALIZABLE: "SERIALIZABLE"
        };
    }
    static get LOCK() {
        return {
            UPDATE: "UPDATE",
            SHARE: "SHARE",
            KEY_SHARE: "KEY SHARE",
            NO_KEY_UPDATE: "NO KEY UPDATE"
        };
    }
    get LOCK() {
        return Transaction.LOCK;
    }
}
module.exports = Transaction;
module.exports.Transaction = Transaction;
module.exports.default = Transaction; //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/sequelize/lib/table-hints.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const TableHints = module.exports = {
    NOLOCK: "NOLOCK",
    READUNCOMMITTED: "READUNCOMMITTED",
    UPDLOCK: "UPDLOCK",
    REPEATABLEREAD: "REPEATABLEREAD",
    SERIALIZABLE: "SERIALIZABLE",
    READCOMMITTED: "READCOMMITTED",
    TABLOCK: "TABLOCK",
    TABLOCKX: "TABLOCKX",
    PAGLOCK: "PAGLOCK",
    ROWLOCK: "ROWLOCK",
    NOWAIT: "NOWAIT",
    READPAST: "READPAST",
    XLOCK: "XLOCK",
    SNAPSHOT: "SNAPSHOT",
    NOEXPAND: "NOEXPAND"
}; //# sourceMappingURL=table-hints.js.map
}),
"[project]/node_modules/sequelize/lib/index-hints.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const IndexHints = module.exports = {
    USE: "USE",
    FORCE: "FORCE",
    IGNORE: "IGNORE"
}; //# sourceMappingURL=index-hints.js.map
}),
"[project]/node_modules/sequelize/lib/associations/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
Association.BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
Association.HasOne = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-one.js [app-route] (ecmascript)");
Association.HasMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
Association.BelongsToMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)");
module.exports = Association;
module.exports.default = Association;
module.exports.Association = Association; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const Transaction = __turbopack_context__.r("[project]/node_modules/sequelize/lib/transaction.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
class QueryInterface {
    constructor(sequelize, queryGenerator){
        this.sequelize = sequelize;
        this.queryGenerator = queryGenerator;
    }
    async createDatabase(database, options) {
        options = options || {};
        const sql = this.queryGenerator.createDatabaseQuery(database, options);
        return await this.sequelize.query(sql, options);
    }
    async dropDatabase(database, options) {
        options = options || {};
        const sql = this.queryGenerator.dropDatabaseQuery(database);
        return await this.sequelize.query(sql, options);
    }
    async createSchema(schema, options) {
        options = options || {};
        const sql = this.queryGenerator.createSchema(schema);
        return await this.sequelize.query(sql, options);
    }
    async dropSchema(schema, options) {
        options = options || {};
        const sql = this.queryGenerator.dropSchema(schema);
        return await this.sequelize.query(sql, options);
    }
    async dropAllSchemas(options) {
        options = options || {};
        if (!this.queryGenerator._dialect.supports.schemas) {
            return this.sequelize.drop(options);
        }
        const schemas = await this.showAllSchemas(options);
        return Promise.all(schemas.map((schemaName)=>this.dropSchema(schemaName, options)));
    }
    async showAllSchemas(options) {
        options = __spreadProps(__spreadValues({}, options), {
            raw: true,
            type: this.sequelize.QueryTypes.SELECT
        });
        const showSchemasSql = this.queryGenerator.showSchemasQuery(options);
        const schemaNames = await this.sequelize.query(showSchemasSql, options);
        return _.flatten(schemaNames.map((value)=>value.schema_name ? value.schema_name : value));
    }
    async databaseVersion(options) {
        return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.VERSION
        }));
    }
    async createTable(tableName, attributes, options, model) {
        let sql = "";
        options = __spreadValues({}, options);
        if (options && options.uniqueKeys) {
            _.forOwn(options.uniqueKeys, (uniqueKey)=>{
                if (uniqueKey.customIndex === void 0) {
                    uniqueKey.customIndex = true;
                }
            });
        }
        if (model) {
            options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;
        }
        attributes = _.mapValues(attributes, (attribute)=>this.sequelize.normalizeAttribute(attribute));
        await this.ensureEnums(tableName, attributes, options, model);
        if (!tableName.schema && (options.schema || !!model && model._schema)) {
            tableName = this.queryGenerator.addSchema({
                tableName,
                _schema: !!model && model._schema || options.schema
            });
        }
        attributes = this.queryGenerator.attributesToSQL(attributes, {
            table: tableName,
            context: "createTable",
            withoutForeignKeyConstraints: options.withoutForeignKeyConstraints
        });
        sql = this.queryGenerator.createTableQuery(tableName, attributes, options);
        return await this.sequelize.query(sql, options);
    }
    async tableExists(tableName, options) {
        const sql = this.queryGenerator.tableExistsQuery(tableName);
        const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.SHOWTABLES
        }));
        return out.length === 1;
    }
    async dropTable(tableName, options) {
        options = __spreadValues({}, options);
        options.cascade = options.cascade || options.force || false;
        const sql = this.queryGenerator.dropTableQuery(tableName, options);
        await this.sequelize.query(sql, options);
    }
    async _dropAllTables(tableNames, skip, options) {
        for (const tableName of tableNames){
            if (!skip.includes(tableName.tableName || tableName)) {
                await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), {
                    cascade: true
                }));
            }
        }
    }
    async dropAllTables(options) {
        options = options || {};
        const skip = options.skip || [];
        const tableNames = await this.showAllTables(options);
        const foreignKeys = await this.getForeignKeysForTables(tableNames, options);
        for (const tableName of tableNames){
            let normalizedTableName = tableName;
            if (_.isObject(tableName)) {
                normalizedTableName = `${tableName.schema}.${tableName.tableName}`;
            }
            for (const foreignKey of foreignKeys[normalizedTableName]){
                await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));
            }
        }
        await this._dropAllTables(tableNames, skip, options);
    }
    async renameTable(before, after, options) {
        options = options || {};
        const sql = this.queryGenerator.renameTableQuery(before, after);
        return await this.sequelize.query(sql, options);
    }
    async showAllTables(options) {
        options = __spreadProps(__spreadValues({}, options), {
            raw: true,
            type: QueryTypes.SHOWTABLES
        });
        const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);
        const tableNames = await this.sequelize.query(showTablesSql, options);
        return _.flatten(tableNames);
    }
    async describeTable(tableName, options) {
        let schema = null;
        let schemaDelimiter = null;
        if (typeof options === "string") {
            schema = options;
        } else if (typeof options === "object" && options !== null) {
            schema = options.schema || null;
            schemaDelimiter = options.schemaDelimiter || null;
        }
        if (typeof tableName === "object" && tableName !== null) {
            schema = tableName.schema;
            tableName = tableName.tableName;
        }
        const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
        options = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.DESCRIBE
        });
        try {
            const data = await this.sequelize.query(sql, options);
            if (_.isEmpty(data)) {
                throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
            }
            return data;
        } catch (e) {
            if (e.original && e.original.code === "ER_NO_SUCH_TABLE") {
                throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
            }
            throw e;
        }
    }
    async addColumn(table, key, attribute, options) {
        if (!table || !key || !attribute) {
            throw new Error("addColumn takes at least 3 arguments (table, attribute name, attribute definition)");
        }
        options = options || {};
        attribute = this.sequelize.normalizeAttribute(attribute);
        return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);
    }
    async removeColumn(tableName, attributeName, options) {
        return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);
    }
    normalizeAttribute(dataTypeOrOptions) {
        let attribute;
        if (Object.values(DataTypes).includes(dataTypeOrOptions)) {
            attribute = {
                type: dataTypeOrOptions,
                allowNull: true
            };
        } else {
            attribute = dataTypeOrOptions;
        }
        return this.sequelize.normalizeAttribute(attribute);
    }
    quoteIdentifier(identifier2, force) {
        return this.queryGenerator.quoteIdentifier(identifier2, force);
    }
    quoteIdentifiers(identifiers) {
        return this.queryGenerator.quoteIdentifiers(identifiers);
    }
    async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
        options = options || {};
        const query = this.queryGenerator.attributesToSQL({
            [attributeName]: this.normalizeAttribute(dataTypeOrOptions)
        }, {
            context: "changeColumn",
            table: tableName
        });
        const sql = this.queryGenerator.changeColumnQuery(tableName, query);
        return this.sequelize.query(sql, options);
    }
    async assertTableHasColumn(tableName, columnName, options) {
        const description = await this.describeTable(tableName, options);
        if (description[columnName]) {
            return description;
        }
        throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);
    }
    async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
        options = options || {};
        const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];
        const _options = {};
        _options[attrNameAfter] = {
            attribute: attrNameAfter,
            type: data.type,
            allowNull: data.allowNull,
            defaultValue: data.defaultValue
        };
        if (data.defaultValue === null && !data.allowNull) {
            delete _options[attrNameAfter].defaultValue;
        }
        const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));
        return await this.sequelize.query(sql, options);
    }
    async addIndex(tableName, attributes, options, rawTablename) {
        if (!Array.isArray(attributes)) {
            rawTablename = options;
            options = attributes;
            attributes = options.fields;
        }
        if (!rawTablename) {
            rawTablename = tableName;
        }
        options = Utils.cloneDeep(options);
        options.fields = attributes;
        const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);
        return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            supportsSearchPath: false
        }));
    }
    async showIndex(tableName, options) {
        const sql = this.queryGenerator.showIndexesQuery(tableName, options);
        return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.SHOWINDEXES
        }));
    }
    async getForeignKeysForTables(tableNames, options) {
        if (tableNames.length === 0) {
            return {};
        }
        options = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.FOREIGNKEYS
        });
        const results = await Promise.all(tableNames.map((tableName)=>this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));
        const result = {};
        tableNames.forEach((tableName, i)=>{
            if (_.isObject(tableName)) {
                tableName = `${tableName.schema}.${tableName.tableName}`;
            }
            result[tableName] = Array.isArray(results[i]) ? results[i].map((r)=>r.constraint_name) : [
                results[i] && results[i].constraint_name
            ];
            result[tableName] = result[tableName].filter(_.identity);
        });
        return result;
    }
    async getForeignKeyReferencesForTable(tableName, options) {
        const queryOptions = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.FOREIGNKEYS
        });
        const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);
        return this.sequelize.query(query, queryOptions);
    }
    async removeIndex(tableName, indexNameOrAttributes, options) {
        options = options || {};
        const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);
        return await this.sequelize.query(sql, options);
    }
    async addConstraint(tableName, options) {
        if (!options.fields) {
            throw new Error("Fields must be specified through options.fields");
        }
        if (!options.type) {
            throw new Error("Constraint type must be specified through options.type");
        }
        options = Utils.cloneDeep(options);
        const sql = this.queryGenerator.addConstraintQuery(tableName, options);
        return await this.sequelize.query(sql, options);
    }
    async showConstraint(tableName, constraintName, options) {
        const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);
        return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.SHOWCONSTRAINTS
        }));
    }
    async removeConstraint(tableName, constraintName, options) {
        return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);
    }
    async insert(instance, tableName, values, options) {
        options = Utils.cloneDeep(options);
        options.hasTrigger = instance && instance.constructor.options.hasTrigger;
        const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);
        options.type = QueryTypes.INSERT;
        options.instance = instance;
        const results = await this.sequelize.query(sql, options);
        if (instance) results[0].isNewRecord = false;
        return results;
    }
    async upsert(tableName, insertValues, updateValues, where, options) {
        options = __spreadValues({}, options);
        const model = options.model;
        options.type = QueryTypes.UPSERT;
        options.updateOnDuplicate = Object.keys(updateValues);
        options.upsertKeys = options.conflictFields || [];
        if (options.upsertKeys.length === 0) {
            const primaryKeys = Object.values(model.primaryKeys).map((item)=>item.field);
            const uniqueKeys = Object.values(model.uniqueKeys).filter((c)=>c.fields.length > 0).map((c)=>c.fields);
            const indexKeys = Object.values(model._indexes).filter((c)=>c.unique && c.fields.length > 0).map((c)=>c.fields);
            for (const field of options.updateOnDuplicate){
                const uniqueKey = uniqueKeys.find((fields)=>fields.includes(field));
                if (uniqueKey) {
                    options.upsertKeys = uniqueKey;
                    break;
                }
                const indexKey = indexKeys.find((fields)=>fields.includes(field));
                if (indexKey) {
                    options.upsertKeys = indexKey;
                    break;
                }
            }
            if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {
                options.upsertKeys = primaryKeys;
            }
            options.upsertKeys = _.uniq(options.upsertKeys);
        }
        const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
        return await this.sequelize.query(sql, options);
    }
    async bulkInsert(tableName, records, options, attributes) {
        options = __spreadValues({}, options);
        options.type = QueryTypes.INSERT;
        const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);
        return results[0];
    }
    async update(instance, tableName, values, identifier2, options) {
        options = __spreadValues({}, options);
        options.hasTrigger = instance && instance.constructor.options.hasTrigger;
        const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);
        options.type = QueryTypes.UPDATE;
        options.instance = instance;
        return await this.sequelize.query(sql, options);
    }
    async bulkUpdate(tableName, values, identifier2, options, attributes) {
        options = Utils.cloneDeep(options);
        if (typeof identifier2 === "object") identifier2 = Utils.cloneDeep(identifier2);
        const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);
        const table = _.isObject(tableName) ? tableName : {
            tableName
        };
        const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, {
            tableName: table.tableName
        });
        options.type = QueryTypes.BULKUPDATE;
        options.model = model;
        return await this.sequelize.query(sql, options);
    }
    async delete(instance, tableName, identifier2, options) {
        const cascades = [];
        const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);
        options = __spreadValues({}, options);
        if (!!instance.constructor && !!instance.constructor.associations) {
            const keys = Object.keys(instance.constructor.associations);
            const length = keys.length;
            let association;
            for(let i = 0; i < length; i++){
                association = instance.constructor.associations[keys[i]];
                if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === "cascade" && association.options.useHooks === true) {
                    cascades.push(association.accessors.get);
                }
            }
        }
        for (const cascade of cascades){
            let instances = await instance[cascade](options);
            if (!instances) continue;
            if (!Array.isArray(instances)) instances = [
                instances
            ];
            for (const _instance of instances)await _instance.destroy(options);
        }
        options.instance = instance;
        return await this.sequelize.query(sql, options);
    }
    async bulkDelete(tableName, where, options, model) {
        options = Utils.cloneDeep(options);
        options = _.defaults(options, {
            limit: null
        });
        if (options.truncate === true) {
            return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);
        }
        if (typeof identifier === "object") where = Utils.cloneDeep(where);
        return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);
    }
    async select(model, tableName, optionsArg) {
        const options = __spreadProps(__spreadValues({}, optionsArg), {
            type: QueryTypes.SELECT,
            model
        });
        return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);
    }
    async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
        options = Utils.cloneDeep(options);
        const sql = this.queryGenerator.arithmeticQuery("+", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);
        options.type = QueryTypes.UPDATE;
        options.model = model;
        return await this.sequelize.query(sql, options);
    }
    async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
        options = Utils.cloneDeep(options);
        const sql = this.queryGenerator.arithmeticQuery("-", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);
        options.type = QueryTypes.UPDATE;
        options.model = model;
        return await this.sequelize.query(sql, options);
    }
    async rawSelect(tableName, options, attributeSelector, Model) {
        options = Utils.cloneDeep(options);
        options = _.defaults(options, {
            raw: true,
            plain: true,
            type: QueryTypes.SELECT
        });
        const sql = this.queryGenerator.selectQuery(tableName, options, Model);
        if (attributeSelector === void 0) {
            throw new Error("Please pass an attribute selector!");
        }
        const data = await this.sequelize.query(sql, options);
        if (!options.plain) {
            return data;
        }
        const result = data ? data[attributeSelector] : null;
        if (!options || !options.dataType) {
            return result;
        }
        const dataType = options.dataType;
        if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {
            if (result !== null) {
                return parseFloat(result);
            }
        }
        if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {
            if (result !== null) {
                return parseInt(result, 10);
            }
        }
        if (dataType instanceof DataTypes.DATE) {
            if (result !== null && !(result instanceof Date)) {
                return new Date(result);
            }
        }
        return result;
    }
    async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {
        const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async dropTrigger(tableName, triggerName, options) {
        const sql = this.queryGenerator.dropTrigger(tableName, triggerName);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {
        const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async createFunction(functionName, params, returnType, language, body, optionsArray, options) {
        const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async dropFunction(functionName, params, options) {
        const sql = this.queryGenerator.dropFunction(functionName, params);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async renameFunction(oldFunctionName, params, newFunctionName, options) {
        const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);
        options = options || {};
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    ensureEnums() {}
    async setIsolationLevel(transaction, value, options) {
        if (!transaction || !(transaction instanceof Transaction)) {
            throw new Error("Unable to set isolation level for a transaction without transaction object!");
        }
        if (transaction.parent || !value) {
            return;
        }
        options = __spreadProps(__spreadValues({}, options), {
            transaction: transaction.parent || transaction
        });
        const sql = this.queryGenerator.setIsolationLevelQuery(value, {
            parent: transaction.parent
        });
        if (!sql) return;
        return await this.sequelize.query(sql, options);
    }
    async startTransaction(transaction, options) {
        if (!transaction || !(transaction instanceof Transaction)) {
            throw new Error("Unable to start a transaction without transaction object!");
        }
        options = __spreadProps(__spreadValues({}, options), {
            transaction: transaction.parent || transaction
        });
        options.transaction.name = transaction.parent ? transaction.name : void 0;
        const sql = this.queryGenerator.startTransactionQuery(transaction);
        return await this.sequelize.query(sql, options);
    }
    async deferConstraints(transaction, options) {
        options = __spreadProps(__spreadValues({}, options), {
            transaction: transaction.parent || transaction
        });
        const sql = this.queryGenerator.deferConstraintsQuery(options);
        if (sql) {
            return await this.sequelize.query(sql, options);
        }
    }
    async commitTransaction(transaction, options) {
        if (!transaction || !(transaction instanceof Transaction)) {
            throw new Error("Unable to commit a transaction without transaction object!");
        }
        if (transaction.parent) {
            return;
        }
        options = __spreadProps(__spreadValues({}, options), {
            transaction: transaction.parent || transaction,
            supportsSearchPath: false,
            completesTransaction: true
        });
        const sql = this.queryGenerator.commitTransactionQuery(transaction);
        const promise = this.sequelize.query(sql, options);
        transaction.finished = "commit";
        return await promise;
    }
    async rollbackTransaction(transaction, options) {
        if (!transaction || !(transaction instanceof Transaction)) {
            throw new Error("Unable to rollback a transaction without transaction object!");
        }
        options = __spreadProps(__spreadValues({}, options), {
            transaction: transaction.parent || transaction,
            supportsSearchPath: false,
            completesTransaction: true
        });
        options.transaction.name = transaction.parent ? transaction.name : void 0;
        const sql = this.queryGenerator.rollbackTransactionQuery(transaction);
        const promise = this.sequelize.query(sql, options);
        transaction.finished = "rollback";
        return await promise;
    }
}
exports.QueryInterface = QueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    withSqliteForeignKeysOff: ()=>withSqliteForeignKeysOff
});
async function withSqliteForeignKeysOff(sequelize, options, cb) {
    try {
        await sequelize.query("PRAGMA foreign_keys = OFF", options);
        return await cb();
    } finally{
        await sequelize.query("PRAGMA foreign_keys = ON", options);
    }
} //# sourceMappingURL=sqlite-utils.js.map
}),
"[project]/node_modules/sequelize/lib/utils/sql.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
__export(exports, {
    injectReplacements: ()=>injectReplacements
});
var import_isPlainObject = __toModule(__turbopack_context__.r("[project]/node_modules/lodash/isPlainObject.js [app-route] (ecmascript)"));
var import_sql_string = __toModule(__turbopack_context__.r("[project]/node_modules/sequelize/lib/sql-string.js [app-route] (ecmascript)"));
function injectReplacements(sqlString, dialect, replacements) {
    var _a, _b, _c, _d;
    if (replacements == null) {
        return sqlString;
    }
    if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {
        throw new TypeError(`"replacements" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);
    }
    const isNamedReplacements = (0, import_isPlainObject.default)(replacements);
    const isPositionalReplacements = Array.isArray(replacements);
    let lastConsumedPositionalReplacementIndex = -1;
    let output = "";
    let currentDollarStringTagName = null;
    let isString = false;
    let isColumn = false;
    let previousSliceEnd = 0;
    let isSingleLineComment = false;
    let isCommentBlock = false;
    let stringIsBackslashEscapable = false;
    for(let i = 0; i < sqlString.length; i++){
        const char = sqlString[i];
        if (isColumn) {
            if (char === dialect.TICK_CHAR_RIGHT) {
                isColumn = false;
            }
            continue;
        }
        if (isString) {
            if (char === "'" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {
                isString = false;
                stringIsBackslashEscapable = false;
            }
            continue;
        }
        if (currentDollarStringTagName !== null) {
            if (char !== "$") {
                continue;
            }
            const remainingString = sqlString.slice(i, sqlString.length);
            const dollarStringStartMatch = remainingString.match(/^\$(?<name>[a-z_][0-9a-z_]*)?(\$)/i);
            const tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || "";
            if (currentDollarStringTagName === tagName) {
                currentDollarStringTagName = null;
            }
            continue;
        }
        if (isSingleLineComment) {
            if (char === "\n") {
                isSingleLineComment = false;
            }
            continue;
        }
        if (isCommentBlock) {
            if (char === "*" && sqlString[i + 1] === "/") {
                isCommentBlock = false;
            }
            continue;
        }
        if (char === dialect.TICK_CHAR_LEFT) {
            isColumn = true;
            continue;
        }
        if (char === "'") {
            isString = true;
            stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === "E" || sqlString[i - 1] === "e") && canPrecedeNewToken(sqlString[i - 2]);
            continue;
        }
        if (char === "-" && sqlString.slice(i, i + 3) === "-- ") {
            isSingleLineComment = true;
            continue;
        }
        if (char === "/" && sqlString.slice(i, i + 2) === "/*") {
            isCommentBlock = true;
            continue;
        }
        if (char === "$") {
            const previousChar = sqlString[i - 1];
            if (/[0-9a-z_]/i.test(previousChar)) {
                continue;
            }
            const remainingString = sqlString.slice(i, sqlString.length);
            const dollarStringStartMatch = remainingString.match(/^\$(?<name>[a-z_][0-9a-z_]*)?(\$)/i);
            if (dollarStringStartMatch) {
                currentDollarStringTagName = (_c = (_b = dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : "";
                i += dollarStringStartMatch[0].length - 1;
                continue;
            }
            continue;
        }
        if (isNamedReplacements && char === ":") {
            const previousChar = sqlString[i - 1];
            if (!canPrecedeNewToken(previousChar) && previousChar !== "[") {
                continue;
            }
            const remainingString = sqlString.slice(i, sqlString.length);
            const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\)|,|$|\s|::|;|])/i);
            const replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;
            if (!replacementName) {
                continue;
            }
            const replacementValue = replacements[replacementName];
            if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {
                throw new Error(`Named replacement ":${replacementName}" has no entry in the replacement map.`);
            }
            const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);
            output += sqlString.slice(previousSliceEnd, i);
            previousSliceEnd = i + replacementName.length + 1;
            output += escapedReplacement;
            continue;
        }
        if (isPositionalReplacements && char === "?") {
            const previousChar = sqlString[i - 1];
            if (!canPrecedeNewToken(previousChar) && previousChar !== "[") {
                continue;
            }
            const nextChar = sqlString[i + 1];
            if (nextChar === "|" || nextChar === "&") {
                continue;
            }
            const replacementIndex = ++lastConsumedPositionalReplacementIndex;
            const replacementValue = replacements[lastConsumedPositionalReplacementIndex];
            if (replacementValue === void 0) {
                throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);
            }
            const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);
            output += sqlString.slice(previousSliceEnd, i);
            previousSliceEnd = i + 1;
            output += escapedReplacement;
        }
    }
    if (isString) {
        throw new Error(`The following SQL query includes an unterminated string literal:
${sqlString}`);
    }
    output += sqlString.slice(previousSliceEnd, sqlString.length);
    return output;
}
function canPrecedeNewToken(char) {
    return char === void 0 || /[\s(>,=]/.test(char);
}
function isBackslashEscaped(string, pos) {
    let escaped = false;
    for(let i = pos; i >= 0; i--){
        const char = string[i];
        if (char !== "\\") {
            break;
        }
        escaped = !escaped;
    }
    return escaped;
} //# sourceMappingURL=sql.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class AbstractDialect {
    canBackslashEscape() {
        return false;
    }
}
AbstractDialect.prototype.supports = {
    "DEFAULT": true,
    "DEFAULT VALUES": false,
    "VALUES ()": false,
    "LIMIT ON UPDATE": false,
    "ON DUPLICATE KEY": true,
    "ORDER NULLS": false,
    "UNION": true,
    "UNION ALL": true,
    "RIGHT JOIN": true,
    returnValues: false,
    autoIncrement: {
        identityInsert: false,
        defaultValue: true,
        update: true
    },
    bulkDefault: false,
    schemas: false,
    transactions: true,
    settingIsolationLevelDuringTransaction: true,
    transactionOptions: {
        type: false
    },
    migrations: true,
    upserts: true,
    inserts: {
        ignoreDuplicates: "",
        updateOnDuplicate: false,
        onConflictDoNothing: "",
        onConflictWhere: false,
        conflictFields: false
    },
    constraints: {
        restrict: true,
        addConstraint: true,
        dropConstraint: true,
        unique: true,
        default: false,
        check: true,
        foreignKey: true,
        primaryKey: true
    },
    index: {
        collate: true,
        length: false,
        parser: false,
        concurrently: false,
        type: false,
        using: true,
        functionBased: false,
        operator: false
    },
    groupedLimit: true,
    indexViaAlter: false,
    JSON: false,
    deferrableConstraints: false,
    escapeStringConstants: false
};
module.exports = AbstractDialect;
module.exports.AbstractDialect = AbstractDialect;
module.exports.default = AbstractDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Pool, TimeoutError } = __turbopack_context__.r("[project]/node_modules/sequelize-pool/lib/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const errors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const deprecations = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)");
const debug = logger.debugContext("pool");
class ConnectionManager {
    constructor(dialect, sequelize){
        const config = _.cloneDeep(sequelize.config);
        this.sequelize = sequelize;
        this.config = config;
        this.dialect = dialect;
        this.versionPromise = null;
        this.dialectName = this.sequelize.options.dialect;
        if (config.pool === false) {
            throw new Error("Support for pool:false was removed in v4.0");
        }
        config.pool = _.defaults(config.pool || {}, {
            max: 5,
            min: 0,
            idle: 1e4,
            acquire: 6e4,
            evict: 1e3,
            validate: this._validate.bind(this)
        });
        this.initPools();
    }
    refreshTypeParser(dataTypes) {
        _.each(dataTypes, (dataType)=>{
            if (Object.prototype.hasOwnProperty.call(dataType, "parse")) {
                if (dataType.types[this.dialectName]) {
                    this._refreshTypeParser(dataType);
                } else {
                    throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);
                }
            }
        });
    }
    _loadDialectModule(moduleName) {
        try {
            if (this.sequelize.config.dialectModulePath) {
                return (()=>{
                    const e = new Error("Cannot find module as expression is too dynamic");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            }
            if (this.sequelize.config.dialectModule) {
                return this.sequelize.config.dialectModule;
            }
            return (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
                if (this.sequelize.config.dialectModulePath) {
                    throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);
                }
                throw new Error(`Please install ${moduleName} package manually`);
            }
            throw err;
        }
    }
    async _onProcessExit() {
        if (!this.pool) {
            return;
        }
        await this.pool.drain();
        debug("connection drain due to process exit");
        return await this.pool.destroyAllNow();
    }
    async close() {
        this.getConnection = async function getConnection() {
            throw new Error("ConnectionManager.getConnection was called after the connection manager was closed!");
        };
        return await this._onProcessExit();
    }
    initPools() {
        const config = this.config;
        if (!config.replication) {
            this.pool = new Pool({
                name: "sequelize",
                create: ()=>this._connect(config),
                destroy: async (connection)=>{
                    const result = await this._disconnect(connection);
                    debug("connection destroy");
                    return result;
                },
                validate: config.pool.validate,
                max: config.pool.max,
                min: config.pool.min,
                acquireTimeoutMillis: config.pool.acquire,
                idleTimeoutMillis: config.pool.idle,
                reapIntervalMillis: config.pool.evict,
                maxUses: config.pool.maxUses
            });
            debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);
            return;
        }
        if (!Array.isArray(config.replication.read)) {
            config.replication.read = [
                config.replication.read
            ];
        }
        config.replication.write = _.defaults(config.replication.write, _.omit(config, "replication"));
        config.replication.read = config.replication.read.map((readConfig)=>_.defaults(readConfig, _.omit(this.config, "replication")));
        let reads = 0;
        this.pool = {
            release: (client)=>{
                if (client.queryType === "read") {
                    this.pool.read.release(client);
                } else {
                    this.pool.write.release(client);
                }
            },
            acquire: (queryType, useMaster)=>{
                useMaster = useMaster === void 0 ? false : useMaster;
                if (queryType === "SELECT" && !useMaster) {
                    return this.pool.read.acquire();
                }
                return this.pool.write.acquire();
            },
            destroy: (connection)=>{
                this.pool[connection.queryType].destroy(connection);
                debug("connection destroy");
            },
            destroyAllNow: async ()=>{
                await Promise.all([
                    this.pool.read.destroyAllNow(),
                    this.pool.write.destroyAllNow()
                ]);
                debug("all connections destroyed");
            },
            drain: async ()=>Promise.all([
                    this.pool.write.drain(),
                    this.pool.read.drain()
                ]),
            read: new Pool({
                name: "sequelize:read",
                create: async ()=>{
                    const nextRead = reads++ % config.replication.read.length;
                    const connection = await this._connect(config.replication.read[nextRead]);
                    connection.queryType = "read";
                    return connection;
                },
                destroy: (connection)=>this._disconnect(connection),
                validate: config.pool.validate,
                max: config.pool.max,
                min: config.pool.min,
                acquireTimeoutMillis: config.pool.acquire,
                idleTimeoutMillis: config.pool.idle,
                reapIntervalMillis: config.pool.evict,
                maxUses: config.pool.maxUses
            }),
            write: new Pool({
                name: "sequelize:write",
                create: async ()=>{
                    const connection = await this._connect(config.replication.write);
                    connection.queryType = "write";
                    return connection;
                },
                destroy: (connection)=>this._disconnect(connection),
                validate: config.pool.validate,
                max: config.pool.max,
                min: config.pool.min,
                acquireTimeoutMillis: config.pool.acquire,
                idleTimeoutMillis: config.pool.idle,
                reapIntervalMillis: config.pool.evict,
                maxUses: config.pool.maxUses
            })
        };
        debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);
    }
    async getConnection(options) {
        options = options || {};
        if (this.sequelize.options.databaseVersion === 0) {
            if (!this.versionPromise) {
                this.versionPromise = (async ()=>{
                    try {
                        const connection = await this._connect(this.config.replication.write || this.config);
                        const _options = {};
                        _options.transaction = {
                            connection
                        };
                        _options.logging = ()=>{};
                        _options.logging.__testLoggingFn = true;
                        if (this.sequelize.options.databaseVersion === 0) {
                            const version = await this.sequelize.databaseVersion(_options);
                            const parsedVersion = _.get(semver.coerce(version), "version") || version;
                            this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;
                        }
                        if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {
                            deprecations.unsupportedEngine();
                            debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);
                        }
                        this.versionPromise = null;
                        return await this._disconnect(connection);
                    } catch (err) {
                        this.versionPromise = null;
                        throw err;
                    }
                })();
            }
            await this.versionPromise;
        }
        let result;
        try {
            await this.sequelize.runHooks("beforePoolAcquire", options);
            result = await this.pool.acquire(options.type, options.useMaster);
            await this.sequelize.runHooks("afterPoolAcquire", result, options);
        } catch (error) {
            if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);
            throw error;
        }
        debug("connection acquired");
        return result;
    }
    releaseConnection(connection) {
        this.pool.release(connection);
        debug("connection released");
    }
    async destroyConnection(connection) {
        await this.pool.destroy(connection);
        debug(`connection ${connection.uuid} destroyed`);
    }
    async _connect(config) {
        await this.sequelize.runHooks("beforeConnect", config);
        const connection = await this.dialect.connectionManager.connect(config);
        await this.sequelize.runHooks("afterConnect", connection, config);
        return connection;
    }
    async _disconnect(connection) {
        await this.sequelize.runHooks("beforeDisconnect", connection);
        await this.dialect.connectionManager.disconnect(connection);
        return this.sequelize.runHooks("afterDisconnect", connection);
    }
    _validate(connection) {
        if (!this.dialect.connectionManager.validate) {
            return true;
        }
        return this.dialect.connectionManager.validate(connection);
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const stores = /* @__PURE__ */ new Map();
module.exports = (dialect)=>{
    if (!stores.has(dialect)) {
        stores.set(dialect, /* @__PURE__ */ new Map());
    }
    return {
        clear () {
            stores.get(dialect).clear();
        },
        refresh (dataType) {
            for (const type of dataType.types[dialect]){
                stores.get(dialect).set(type, dataType.parse);
            }
        },
        get (type) {
            return stores.get(dialect).get(type);
        }
    };
}; //# sourceMappingURL=parserStore.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mariadb/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const SequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mariadb;
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const debug = logger.debugContext("connection:mariadb");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("mariadb");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 3306;
        super(dialect, sequelize);
        this.lib = this._loadDialectModule("mariadb");
        this.refreshTypeParser(DataTypes);
    }
    static _typecast(field, next) {
        if (parserStore.get(field.type)) {
            return parserStore.get(field.type)(field, this.sequelize.options, next);
        }
        return next();
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    async connect(config) {
        let tzOffset = this.sequelize.options.timezone;
        tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format("Z") : tzOffset;
        const connectionConfig = __spreadValues({
            host: config.host,
            port: config.port,
            user: config.username,
            password: config.password,
            database: config.database,
            timezone: tzOffset,
            typeCast: ConnectionManager._typecast.bind(this),
            bigNumberStrings: false,
            supportBigNumbers: true,
            foundRows: false
        }, config.dialectOptions);
        if (!this.sequelize.config.keepDefaultTimezone) {
            if (connectionConfig.initSql) {
                if (!Array.isArray(connectionConfig.initSql)) {
                    connectionConfig.initSql = [
                        connectionConfig.initSql
                    ];
                }
                connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);
            } else {
                connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;
            }
        }
        try {
            const connection = await this.lib.createConnection(connectionConfig);
            this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;
            debug("connection acquired");
            connection.on("error", (error)=>{
                switch(error.code){
                    case "ESOCKET":
                    case "ECONNRESET":
                    case "EPIPE":
                    case "PROTOCOL_CONNECTION_LOST":
                        this.pool.destroy(connection);
                }
            });
            return connection;
        } catch (err) {
            switch(err.code){
                case "ECONNREFUSED":
                    throw new SequelizeErrors.ConnectionRefusedError(err);
                case "ER_ACCESS_DENIED_ERROR":
                case "ER_ACCESS_DENIED_NO_PASSWORD_ERROR":
                    throw new SequelizeErrors.AccessDeniedError(err);
                case "ENOTFOUND":
                    throw new SequelizeErrors.HostNotFoundError(err);
                case "EHOSTUNREACH":
                case "ENETUNREACH":
                case "EADDRNOTAVAIL":
                    throw new SequelizeErrors.HostNotReachableError(err);
                case "EINVAL":
                    throw new SequelizeErrors.InvalidConnectionError(err);
                default:
                    throw new SequelizeErrors.ConnectionError(err);
            }
        }
    }
    async disconnect(connection) {
        if (!connection.isValid()) {
            debug("connection tried to disconnect but was already at CLOSED state");
            return;
        }
        return await connection.end();
    }
    validate(connection) {
        return connection && connection.isValid();
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const SqlString = __turbopack_context__.r("[project]/node_modules/sequelize/lib/sql-string.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const Dot = __turbopack_context__.r("[project]/node_modules/dottie/dottie.js [app-route] (ecmascript)");
const deprecations = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)");
const uuid = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)").v4;
const { safeStringifyJson } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
class AbstractQuery {
    constructor(connection, sequelize, options){
        this.uuid = uuid();
        this.connection = connection;
        this.instance = options.instance;
        this.model = options.model;
        this.sequelize = sequelize;
        this.options = __spreadValues({
            plain: false,
            raw: false,
            logging: console.log
        }, options);
        this.checkLoggingOption();
        if (options.rawErrors) {
            this.formatError = AbstractQuery.prototype.formatError;
        }
    }
    static formatBindParameters(sql, values, dialect, replacementFunc, options) {
        if (!values) {
            return [
                sql,
                []
            ];
        }
        options = options || {};
        if (typeof replacementFunc !== "function") {
            options = replacementFunc || {};
            replacementFunc = void 0;
        }
        if (!replacementFunc) {
            if (options.skipValueReplace) {
                replacementFunc = (match, key, values2)=>{
                    if (values2[key] !== void 0) {
                        return match;
                    }
                    return void 0;
                };
            } else {
                replacementFunc = (match, key, values2, timeZone2, dialect2)=>{
                    if (values2[key] !== void 0) {
                        return SqlString.escape(values2[key], timeZone2, dialect2);
                    }
                    return void 0;
                };
            }
        } else if (options.skipValueReplace) {
            const origReplacementFunc = replacementFunc;
            replacementFunc = (match, key, values2, timeZone2, dialect2, options2)=>{
                if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {
                    return match;
                }
                return void 0;
            };
        }
        const timeZone = null;
        const list = Array.isArray(values);
        sql = sql.replace(/\B\$(\$|\w+)/g, (match, key)=>{
            if (key === "$") {
                return options.skipUnescape ? match : key;
            }
            let replVal;
            if (list) {
                if (key.match(/^[1-9]\d*$/)) {
                    key = key - 1;
                    replVal = replacementFunc(match, key, values, timeZone, dialect, options);
                }
            } else if (!key.match(/^\d*$/)) {
                replVal = replacementFunc(match, key, values, timeZone, dialect, options);
            }
            if (replVal === void 0) {
                throw new Error(`Named bind parameter "${match}" has no value in the given object.`);
            }
            return replVal;
        });
        return [
            sql,
            []
        ];
    }
    formatError(error, errStack) {
        error.stack = errStack;
        return error;
    }
    run() {
        throw new Error("The run method wasn't overwritten!");
    }
    checkLoggingOption() {
        if (this.options.logging === true) {
            deprecations.noTrueLogging();
            this.options.logging = console.log;
        }
    }
    getInsertIdField() {
        return "insertId";
    }
    getUniqueConstraintErrorMessage(field) {
        let message = field ? `${field} must be unique` : "Must be unique";
        if (field && this.model) {
            for (const key of Object.keys(this.model.uniqueKeys)){
                if (this.model.uniqueKeys[key].fields.includes(field.replace(/"/g, ""))) {
                    if (this.model.uniqueKeys[key].msg) {
                        message = this.model.uniqueKeys[key].msg;
                    }
                }
            }
        }
        return message;
    }
    isRawQuery() {
        return this.options.type === QueryTypes.RAW;
    }
    isVersionQuery() {
        return this.options.type === QueryTypes.VERSION;
    }
    isUpsertQuery() {
        return this.options.type === QueryTypes.UPSERT;
    }
    isInsertQuery(results, metaData) {
        let result = true;
        if (this.options.type === QueryTypes.INSERT) {
            return true;
        }
        result = result && this.sql.toLowerCase().startsWith("insert into");
        result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));
        result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));
        return result;
    }
    handleInsertQuery(results, metaData) {
        if (this.instance) {
            const autoIncrementAttribute = this.model.autoIncrementAttribute;
            let id = null;
            id = id || results && results[this.getInsertIdField()];
            id = id || metaData && metaData[this.getInsertIdField()];
            this.instance[autoIncrementAttribute] = id;
        }
    }
    isShowTablesQuery() {
        return this.options.type === QueryTypes.SHOWTABLES;
    }
    handleShowTablesQuery(results) {
        return _.flatten(results.map((resultSet)=>Object.values(resultSet)));
    }
    isShowIndexesQuery() {
        return this.options.type === QueryTypes.SHOWINDEXES;
    }
    isShowConstraintsQuery() {
        return this.options.type === QueryTypes.SHOWCONSTRAINTS;
    }
    isDescribeQuery() {
        return this.options.type === QueryTypes.DESCRIBE;
    }
    isSelectQuery() {
        return this.options.type === QueryTypes.SELECT;
    }
    isBulkUpdateQuery() {
        return this.options.type === QueryTypes.BULKUPDATE;
    }
    isBulkDeleteQuery() {
        return this.options.type === QueryTypes.BULKDELETE;
    }
    isForeignKeysQuery() {
        return this.options.type === QueryTypes.FOREIGNKEYS;
    }
    isUpdateQuery() {
        return this.options.type === QueryTypes.UPDATE;
    }
    handleSelectQuery(results) {
        let result = null;
        if (this.options.fieldMap) {
            const fieldMap = this.options.fieldMap;
            results = results.map((result2)=>_.reduce(fieldMap, (result3, name, field)=>{
                    if (result3[field] !== void 0 && name !== field) {
                        result3[name] = result3[field];
                        delete result3[field];
                    }
                    return result3;
                }, result2));
        }
        if (this.options.raw) {
            result = results.map((result2)=>{
                let o = {};
                for(const key in result2){
                    if (Object.prototype.hasOwnProperty.call(result2, key)) {
                        o[key] = result2[key];
                    }
                }
                if (this.options.nest) {
                    o = Dot.transform(o);
                }
                return o;
            });
        } else if (this.options.hasJoin === true) {
            results = AbstractQuery._groupJoinData(results, {
                model: this.model,
                includeMap: this.options.includeMap,
                includeNames: this.options.includeNames
            }, {
                checkExisting: this.options.hasMultiAssociation
            });
            result = this.model.bulkBuild(results, {
                isNewRecord: false,
                include: this.options.include,
                includeNames: this.options.includeNames,
                includeMap: this.options.includeMap,
                includeValidated: true,
                attributes: this.options.originalAttributes || this.options.attributes,
                raw: true
            });
        } else {
            result = this.model.bulkBuild(results, {
                isNewRecord: false,
                raw: true,
                attributes: this.options.originalAttributes || this.options.attributes
            });
        }
        if (this.options.plain) {
            result = result.length === 0 ? null : result[0];
        }
        return result;
    }
    isShowOrDescribeQuery() {
        let result = false;
        result = result || this.sql.toLowerCase().startsWith("show");
        result = result || this.sql.toLowerCase().startsWith("describe");
        return result;
    }
    isCallQuery() {
        return this.sql.toLowerCase().startsWith("call");
    }
    _logQuery(sql, debugContext, parameters) {
        const { connection, options } = this;
        const benchmark = this.sequelize.options.benchmark || options.benchmark;
        const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;
        const startTime = Date.now();
        let logParameter = "";
        if (logQueryParameters && parameters) {
            const delimiter = sql.endsWith(";") ? "" : ";";
            let paramStr;
            if (Array.isArray(parameters)) {
                paramStr = parameters.map((p)=>safeStringifyJson(p)).join(", ");
            } else {
                paramStr = safeStringifyJson(parameters);
            }
            logParameter = `${delimiter} ${paramStr}`;
        }
        const fmt = `(${connection.uuid || "default"}): ${sql}${logParameter}`;
        const msg = `Executing ${fmt}`;
        debugContext(msg);
        if (!benchmark) {
            this.sequelize.log(`Executing ${fmt}`, options);
        }
        return ()=>{
            const afterMsg = `Executed ${fmt}`;
            debugContext(afterMsg);
            if (benchmark) {
                this.sequelize.log(afterMsg, Date.now() - startTime, options);
            }
        };
    }
    static _groupJoinData(rows, includeOptions, options) {
        if (!rows.length) {
            return [];
        }
        let i;
        let length;
        let $i;
        let $length;
        let rowsI;
        let row;
        const rowsLength = rows.length;
        let keys;
        let key;
        let keyI;
        let keyLength;
        let prevKey;
        let values;
        let topValues;
        let topExists;
        const checkExisting = options.checkExisting;
        let itemHash;
        let parentHash;
        let topHash;
        const results = checkExisting ? [] : new Array(rowsLength);
        const resultMap = {};
        const includeMap = {};
        let $keyPrefix;
        let $keyPrefixString;
        let $prevKeyPrefixString;
        let $prevKeyPrefix;
        let $lastKeyPrefix;
        let $current;
        let $parent;
        let previousPiece;
        const buildIncludeMap = (piece)=>{
            if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {
                includeMap[key] = $current = $current.includeMap[piece];
                if (previousPiece) {
                    previousPiece = `${previousPiece}.${piece}`;
                } else {
                    previousPiece = piece;
                }
                includeMap[previousPiece] = $current;
            }
        };
        const keyPrefixStringMemo = {};
        const keyPrefixString = (key2, memo)=>{
            if (!Object.prototype.hasOwnProperty.call(memo, key2)) {
                memo[key2] = key2.substr(0, key2.lastIndexOf("."));
            }
            return memo[key2];
        };
        const removeKeyPrefixMemo = {};
        const removeKeyPrefix = (key2)=>{
            if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {
                const index = key2.lastIndexOf(".");
                removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);
            }
            return removeKeyPrefixMemo[key2];
        };
        const keyPrefixMemo = {};
        const keyPrefix = (key2)=>{
            if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {
                const prefixString = keyPrefixString(key2, keyPrefixStringMemo);
                if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {
                    keyPrefixMemo[prefixString] = prefixString ? prefixString.split(".") : [];
                }
                keyPrefixMemo[key2] = keyPrefixMemo[prefixString];
            }
            return keyPrefixMemo[key2];
        };
        const lastKeyPrefixMemo = {};
        const lastKeyPrefix = (key2)=>{
            if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {
                const prefix2 = keyPrefix(key2);
                const length2 = prefix2.length;
                lastKeyPrefixMemo[key2] = !length2 ? "" : prefix2[length2 - 1];
            }
            return lastKeyPrefixMemo[key2];
        };
        const getUniqueKeyAttributes = (model)=>{
            let uniqueKeyAttributes2 = _.chain(model.uniqueKeys);
            uniqueKeyAttributes2 = uniqueKeyAttributes2.result(`${uniqueKeyAttributes2.findKey()}.fields`).map((field)=>_.findKey(model.attributes, (chr)=>chr.field === field)).value();
            return uniqueKeyAttributes2;
        };
        const stringify = (obj)=>obj instanceof Buffer ? obj.toString("hex") : obj;
        let primaryKeyAttributes;
        let uniqueKeyAttributes;
        let prefix;
        for(rowsI = 0; rowsI < rowsLength; rowsI++){
            row = rows[rowsI];
            if (rowsI === 0) {
                keys = _.sortBy(Object.keys(row), (item)=>[
                        item.split(".").length
                    ]);
                keyLength = keys.length;
            }
            if (checkExisting) {
                topExists = false;
                $length = includeOptions.model.primaryKeyAttributes.length;
                topHash = "";
                if ($length === 1) {
                    topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);
                } else if ($length > 1) {
                    for($i = 0; $i < $length; $i++){
                        topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);
                    }
                } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {
                    uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);
                    for($i = 0; $i < uniqueKeyAttributes.length; $i++){
                        topHash += row[uniqueKeyAttributes[$i]];
                    }
                }
            }
            topValues = values = {};
            $prevKeyPrefix = void 0;
            for(keyI = 0; keyI < keyLength; keyI++){
                key = keys[keyI];
                $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);
                $keyPrefix = keyPrefix(key);
                if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {
                    if (!$keyPrefix.length) {
                        includeMap[key] = includeMap[""] = includeOptions;
                    } else {
                        $current = includeOptions;
                        previousPiece = void 0;
                        $keyPrefix.forEach(buildIncludeMap);
                    }
                }
                if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {
                    if (checkExisting) {
                        length = $prevKeyPrefix.length;
                        $parent = null;
                        parentHash = null;
                        if (length) {
                            for(i = 0; i < length; i++){
                                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
                                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                                $length = primaryKeyAttributes.length;
                                itemHash = prefix;
                                if ($length === 1) {
                                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
                                } else if ($length > 1) {
                                    for($i = 0; $i < $length; $i++){
                                        itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
                                    }
                                } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                                    uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
                                    for($i = 0; $i < uniqueKeyAttributes.length; $i++){
                                        itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
                                    }
                                }
                                if (!parentHash) {
                                    parentHash = topHash;
                                }
                                itemHash = parentHash + itemHash;
                                $parent = prefix;
                                if (i < length - 1) {
                                    parentHash = itemHash;
                                }
                            }
                        } else {
                            itemHash = topHash;
                        }
                        if (itemHash === topHash) {
                            if (!resultMap[itemHash]) {
                                resultMap[itemHash] = values;
                            } else {
                                topExists = true;
                            }
                        } else if (!resultMap[itemHash]) {
                            $parent = resultMap[parentHash];
                            $lastKeyPrefix = lastKeyPrefix(prevKey);
                            if (includeMap[prevKey].association.isSingleAssociation) {
                                if ($parent) {
                                    $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                                }
                            } else {
                                if (!$parent[$lastKeyPrefix]) {
                                    $parent[$lastKeyPrefix] = [];
                                }
                                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
                            }
                        }
                        values = {};
                    } else {
                        $current = topValues;
                        length = $keyPrefix.length;
                        if (length) {
                            for(i = 0; i < length; i++){
                                if (i === length - 1) {
                                    values = $current[$keyPrefix[i]] = {};
                                }
                                $current = $current[$keyPrefix[i]] || {};
                            }
                        }
                    }
                }
                values[removeKeyPrefix(key)] = row[key];
                prevKey = key;
                $prevKeyPrefix = $keyPrefix;
                $prevKeyPrefixString = $keyPrefixString;
            }
            if (checkExisting) {
                length = $prevKeyPrefix.length;
                $parent = null;
                parentHash = null;
                if (length) {
                    for(i = 0; i < length; i++){
                        prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];
                        primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;
                        $length = primaryKeyAttributes.length;
                        itemHash = prefix;
                        if ($length === 1) {
                            itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);
                        } else if ($length > 0) {
                            for($i = 0; $i < $length; $i++){
                                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);
                            }
                        } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {
                            uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);
                            for($i = 0; $i < uniqueKeyAttributes.length; $i++){
                                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];
                            }
                        }
                        if (!parentHash) {
                            parentHash = topHash;
                        }
                        itemHash = parentHash + itemHash;
                        $parent = prefix;
                        if (i < length - 1) {
                            parentHash = itemHash;
                        }
                    }
                } else {
                    itemHash = topHash;
                }
                if (itemHash === topHash) {
                    if (!resultMap[itemHash]) {
                        resultMap[itemHash] = values;
                    } else {
                        topExists = true;
                    }
                } else if (!resultMap[itemHash]) {
                    $parent = resultMap[parentHash];
                    $lastKeyPrefix = lastKeyPrefix(prevKey);
                    if (includeMap[prevKey].association.isSingleAssociation) {
                        if ($parent) {
                            $parent[$lastKeyPrefix] = resultMap[itemHash] = values;
                        }
                    } else {
                        if (!$parent[$lastKeyPrefix]) {
                            $parent[$lastKeyPrefix] = [];
                        }
                        $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);
                    }
                }
                if (!topExists) {
                    results.push(topValues);
                }
            } else {
                results[rowsI] = topValues;
            }
        }
        return results;
    }
}
module.exports = AbstractQuery;
module.exports.AbstractQuery = AbstractQuery;
module.exports.default = AbstractQuery; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mariadb/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;
const debug = logger.debugContext("sql:mariadb");
class Query extends AbstractQuery {
    constructor(connection, sequelize, options){
        super(connection, sequelize, __spreadValues({
            showWarnings: false
        }, options));
    }
    static formatBindParameters(sql, values, dialect) {
        const bindParam = [];
        const replacementFunc = (match, key, values_)=>{
            if (values_[key] !== void 0) {
                bindParam.push(values_[key]);
                return "?";
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        return [
            sql,
            bindParam.length > 0 ? bindParam : void 0
        ];
    }
    async run(sql, parameters) {
        this.sql = sql;
        const { connection, options } = this;
        const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;
        const complete = this._logQuery(sql, debug, parameters);
        if (parameters) {
            debug("parameters(%j)", parameters);
        }
        let results;
        const errForStack = new Error();
        try {
            results = await connection.query(this.sql, parameters);
        } catch (error) {
            if (options.transaction && error.errno === ER_DEADLOCK) {
                try {
                    await options.transaction.rollback();
                } catch (error_) {}
                options.transaction.finished = "rollback";
            }
            error.sql = sql;
            error.parameters = parameters;
            throw this.formatError(error, errForStack.stack);
        } finally{
            complete();
        }
        if (showWarnings && results && results.warningStatus > 0) {
            await this.logWarnings(results);
        }
        return this.formatResults(results);
    }
    formatResults(data) {
        let result = this.instance;
        if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
            return data.affectedRows;
        }
        if (this.isUpsertQuery()) {
            return [
                result,
                data.affectedRows === 1
            ];
        }
        if (this.isInsertQuery(data)) {
            this.handleInsertQuery(data);
            if (!this.instance) {
                if (this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {
                    const startId = data[this.getInsertIdField()];
                    result = new Array(data.affectedRows);
                    const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;
                    for(let i = 0; i < data.affectedRows; i++){
                        result[i] = {
                            [pkField]: startId + i
                        };
                    }
                    return [
                        result,
                        data.affectedRows
                    ];
                }
                return [
                    data[this.getInsertIdField()],
                    data.affectedRows
                ];
            }
        }
        if (this.isSelectQuery()) {
            this.handleJsonSelectQuery(data);
            return this.handleSelectQuery(data);
        }
        if (this.isInsertQuery() || this.isUpdateQuery()) {
            return [
                result,
                data.affectedRows
            ];
        }
        if (this.isCallQuery()) {
            return data[0];
        }
        if (this.isRawQuery()) {
            const meta = data.meta;
            delete data.meta;
            return [
                data,
                meta
            ];
        }
        if (this.isShowIndexesQuery()) {
            return this.handleShowIndexesQuery(data);
        }
        if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {
            return data;
        }
        if (this.isShowTablesQuery()) {
            return this.handleShowTablesQuery(data);
        }
        if (this.isDescribeQuery()) {
            result = {};
            for (const _result of data){
                result[_result.Field] = {
                    type: _result.Type.toLowerCase().startsWith("enum") ? _result.Type.replace(/^enum/i, "ENUM") : _result.Type.toUpperCase(),
                    allowNull: _result.Null === "YES",
                    defaultValue: _result.Default,
                    primaryKey: _result.Key === "PRI",
                    autoIncrement: Object.prototype.hasOwnProperty.call(_result, "Extra") && _result.Extra.toLowerCase() === "auto_increment",
                    comment: _result.Comment ? _result.Comment : null
                };
            }
            return result;
        }
        if (this.isVersionQuery()) {
            return data[0].version;
        }
        return result;
    }
    handleJsonSelectQuery(rows) {
        if (!this.model || !this.model.fieldRawAttributesMap) {
            return;
        }
        for (const _field of Object.keys(this.model.fieldRawAttributesMap)){
            const modelField = this.model.fieldRawAttributesMap[_field];
            if (modelField.type instanceof DataTypes.JSON) {
                rows = rows.map((row)=>{
                    if (row[modelField.fieldName] && typeof row[modelField.fieldName] === "string" && !this.connection.info.hasMinVersion(10, 5, 2)) {
                        row[modelField.fieldName] = JSON.parse(row[modelField.fieldName]);
                    }
                    if (DataTypes.JSON.parse) {
                        return DataTypes.JSON.parse(modelField, this.sequelize.options, row[modelField.fieldName]);
                    }
                    return row;
                });
            }
        }
    }
    async logWarnings(results) {
        const warningResults = await this.run("SHOW WARNINGS");
        const warningMessage = `MariaDB Warnings (${this.connection.uuid || "default"}): `;
        const messages = [];
        for (const _warningRow of warningResults){
            if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== "function") {
                continue;
            }
            for (const _warningResult of _warningRow){
                if (Object.prototype.hasOwnProperty.call(_warningResult, "Message")) {
                    messages.push(_warningResult.Message);
                } else {
                    for (const _objectKey of _warningResult.keys()){
                        messages.push([
                            _objectKey,
                            _warningResult[_objectKey]
                        ].join(": "));
                    }
                }
            }
        }
        this.sequelize.log(warningMessage + messages.join("; "), this.options);
        return results;
    }
    formatError(err, errStack) {
        switch(err.errno){
            case ER_DUP_ENTRY:
                {
                    const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?\s.*$/);
                    let fields = {};
                    let message = "Validation error";
                    const values = match ? match[1].split("-") : void 0;
                    const fieldKey = match ? match[2] : void 0;
                    const fieldVal = match ? match[1] : void 0;
                    const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];
                    if (uniqueKey) {
                        if (uniqueKey.msg) message = uniqueKey.msg;
                        fields = _.zipObject(uniqueKey.fields, values);
                    } else {
                        fields[fieldKey] = fieldVal;
                    }
                    const errors = [];
                    _.forOwn(fields, (value, field)=>{
                        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
                    });
                    return new sequelizeErrors.UniqueConstraintError({
                        message,
                        errors,
                        parent: err,
                        fields,
                        stack: errStack
                    });
                }
            case ER_ROW_IS_REFERENCED:
            case ER_NO_REFERENCED_ROW:
                {
                    const match = err.message.match(/CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/);
                    const quoteChar = match ? match[1] : "`";
                    const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;
                    return new sequelizeErrors.ForeignKeyConstraintError({
                        reltype: err.errno === ER_ROW_IS_REFERENCED ? "parent" : "child",
                        table: match ? match[4] : void 0,
                        fields,
                        value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,
                        index: match ? match[2] : void 0,
                        parent: err,
                        stack: errStack
                    });
                }
            default:
                return new sequelizeErrors.DatabaseError(err, {
                    stack: errStack
                });
        }
    }
    handleShowTablesQuery(results) {
        return results.map((resultSet)=>({
                tableName: resultSet.TABLE_NAME,
                schema: resultSet.TABLE_SCHEMA
            }));
    }
    handleShowIndexesQuery(data) {
        let currItem;
        const result = [];
        data.forEach((item)=>{
            if (!currItem || currItem.name !== item.Key_name) {
                currItem = {
                    primary: item.Key_name === "PRIMARY",
                    fields: [],
                    name: item.Key_name,
                    tableName: item.Table,
                    unique: item.Non_unique !== 1,
                    type: item.Index_type
                };
                result.push(currItem);
            }
            currItem.fields[item.Seq_in_index - 1] = {
                attribute: item.Column_name,
                length: item.Sub_part || void 0,
                order: item.Collation === "A" ? "ASC" : void 0
            };
        });
        return result;
    }
}
module.exports = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const OperatorHelpers = {
    OperatorMap: {
        [Op.eq]: "=",
        [Op.ne]: "!=",
        [Op.gte]: ">=",
        [Op.gt]: ">",
        [Op.lte]: "<=",
        [Op.lt]: "<",
        [Op.not]: "IS NOT",
        [Op.is]: "IS",
        [Op.in]: "IN",
        [Op.notIn]: "NOT IN",
        [Op.like]: "LIKE",
        [Op.notLike]: "NOT LIKE",
        [Op.iLike]: "ILIKE",
        [Op.notILike]: "NOT ILIKE",
        [Op.startsWith]: "LIKE",
        [Op.endsWith]: "LIKE",
        [Op.substring]: "LIKE",
        [Op.regexp]: "~",
        [Op.notRegexp]: "!~",
        [Op.iRegexp]: "~*",
        [Op.notIRegexp]: "!~*",
        [Op.between]: "BETWEEN",
        [Op.notBetween]: "NOT BETWEEN",
        [Op.overlap]: "&&",
        [Op.contains]: "@>",
        [Op.contained]: "<@",
        [Op.adjacent]: "-|-",
        [Op.strictLeft]: "<<",
        [Op.strictRight]: ">>",
        [Op.noExtendRight]: "&<",
        [Op.noExtendLeft]: "&>",
        [Op.any]: "ANY",
        [Op.all]: "ALL",
        [Op.and]: " AND ",
        [Op.or]: " OR ",
        [Op.col]: "COL",
        [Op.placeholder]: "$$PLACEHOLDER$$",
        [Op.match]: "@@"
    },
    OperatorsAliasMap: {},
    setOperatorsAliases (aliases) {
        if (!aliases || _.isEmpty(aliases)) {
            this.OperatorsAliasMap = false;
        } else {
            this.OperatorsAliasMap = __spreadValues({}, aliases);
        }
    },
    _replaceAliases (orig) {
        const obj = {};
        if (!this.OperatorsAliasMap) {
            return orig;
        }
        Utils.getOperators(orig).forEach((op)=>{
            const item = orig[op];
            if (_.isPlainObject(item)) {
                obj[op] = this._replaceAliases(item);
            } else {
                obj[op] = item;
            }
        });
        _.forOwn(orig, (item, prop)=>{
            prop = this.OperatorsAliasMap[prop] || prop;
            if (_.isPlainObject(item)) {
                item = this._replaceAliases(item);
            }
            obj[prop] = item;
        });
        return obj;
    }
};
module.exports = OperatorHelpers; //# sourceMappingURL=operators.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const uuidv4 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)").v4;
const TransactionQueries = {
    setIsolationLevelQuery (value, options) {
        if (options.parent) {
            return;
        }
        return `SET TRANSACTION ISOLATION LEVEL ${value};`;
    },
    generateTransactionId () {
        return uuidv4();
    },
    startTransactionQuery (transaction) {
        if (transaction.parent) {
            return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
        }
        return "START TRANSACTION;";
    },
    deferConstraintsQuery () {},
    setConstraintQuery () {},
    setDeferredQuery () {},
    setImmediateQuery () {},
    commitTransactionQuery (transaction) {
        if (transaction.parent) {
            return;
        }
        return "COMMIT;";
    },
    rollbackTransactionQuery (transaction) {
        if (transaction.parent) {
            return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;
        }
        return "ROLLBACK;";
    }
};
module.exports = TransactionQueries; //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const uuidv4 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)").v4;
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const deprecations = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)");
const SqlString = __turbopack_context__.r("[project]/node_modules/sequelize/lib/sql-string.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const Model = __turbopack_context__.r("[project]/node_modules/sequelize/lib/model.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/base.js [app-route] (ecmascript)");
const BelongsTo = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
const BelongsToMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)");
const HasMany = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const sequelizeError = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const IndexHints = __turbopack_context__.r("[project]/node_modules/sequelize/lib/index-hints.js [app-route] (ecmascript)");
class QueryGenerator {
    constructor(options){
        if (!options.sequelize) throw new Error("QueryGenerator initialized without options.sequelize");
        if (!options._dialect) throw new Error("QueryGenerator initialized without options._dialect");
        this.sequelize = options.sequelize;
        this.options = options.sequelize.options;
        this.dialect = options._dialect.name;
        this._dialect = options._dialect;
        this._initQuoteIdentifier();
    }
    extractTableDetails(tableName, options) {
        options = options || {};
        tableName = tableName || {};
        return {
            schema: tableName.schema || options.schema || this.options.schema || "public",
            tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,
            delimiter: tableName.delimiter || options.delimiter || "."
        };
    }
    addSchema(param) {
        if (!param._schema) return param.tableName || param;
        const self = this;
        return {
            tableName: param.tableName || param,
            table: param.tableName || param,
            name: param.name || param,
            schema: param._schema,
            delimiter: param._schemaDelimiter || ".",
            toString () {
                return self.quoteTable(this);
            }
        };
    }
    dropSchema(tableName, options) {
        return this.dropTableQuery(tableName, options);
    }
    describeTableQuery(tableName, schema, schemaDelimiter) {
        const table = this.quoteTable(this.addSchema({
            tableName,
            _schema: schema,
            _schemaDelimiter: schemaDelimiter
        }));
        return `DESCRIBE ${table};`;
    }
    dropTableQuery(tableName) {
        return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;
    }
    renameTableQuery(before, after) {
        return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;
    }
    populateInsertQueryReturnIntoBinds() {}
    insertQuery(table, valueHash, modelAttributes, options) {
        options = options || {};
        _.defaults(options, this.options);
        const modelAttributeMap = {};
        const bind = options.bind || [];
        const fields = [];
        const returningModelAttributes = [];
        const returnTypes = [];
        const values = [];
        const quotedTable = this.quoteTable(table);
        const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;
        const returnAttributes = [];
        let query;
        let valueQuery = "";
        let emptyQuery = "";
        let outputFragment = "";
        let returningFragment = "";
        let identityWrapperRequired = false;
        let tmpTable = "";
        if (modelAttributes) {
            _.each(modelAttributes, (attribute, key)=>{
                modelAttributeMap[key] = attribute;
                if (attribute.field) {
                    modelAttributeMap[attribute.field] = attribute;
                }
            });
        }
        if (this._dialect.supports["DEFAULT VALUES"]) {
            emptyQuery += " DEFAULT VALUES";
        } else if (this._dialect.supports["VALUES ()"]) {
            emptyQuery += " VALUES ()";
        }
        if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {
            const returnValues = this.generateReturnValues(modelAttributes, options);
            returningModelAttributes.push(...returnValues.returnFields);
            if (this._dialect.supports.returnIntoValues) {
                returnTypes.push(...returnValues.returnTypes);
            }
            returningFragment = returnValues.returningFragment;
            tmpTable = returnValues.tmpTable || "";
            outputFragment = returnValues.outputFragment || "";
        }
        if (_.get(this, [
            "sequelize",
            "options",
            "dialectOptions",
            "prependSearchPath"
        ]) || options.searchPath) {
            options.bindParam = false;
        }
        if (this._dialect.supports.EXCEPTION && options.exception) {
            options.bindParam = false;
        }
        valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);
        for(const key in valueHash){
            if (Object.prototype.hasOwnProperty.call(valueHash, key)) {
                const value = valueHash[key];
                fields.push(this.quoteIdentifier(key));
                if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {
                    if (!this._dialect.supports.autoIncrement.defaultValue) {
                        fields.splice(-1, 1);
                    } else if (this._dialect.supports.DEFAULT) {
                        values.push("DEFAULT");
                    } else {
                        values.push(this.escape(null));
                    }
                } else {
                    if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {
                        identityWrapperRequired = true;
                    }
                    if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
                        values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                            context: "INSERT"
                        }));
                    } else {
                        values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                            context: "INSERT"
                        }, bindParam));
                    }
                }
            }
        }
        let onDuplicateKeyUpdate = "";
        if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {
            throw new Error("missing dialect support for conflictWhere option");
        }
        if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
            if (this._dialect.supports.inserts.updateOnDuplicate == " ON CONFLICT DO UPDATE SET") {
                const conflictKeys = options.upsertKeys.map((attr)=>this.quoteIdentifier(attr));
                const updateKeys = options.updateOnDuplicate.map((attr)=>`${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
                const fragments = [
                    "ON CONFLICT",
                    "(",
                    conflictKeys.join(","),
                    ")"
                ];
                if (!_.isEmpty(options.conflictWhere)) {
                    fragments.push(this.whereQuery(options.conflictWhere, options));
                }
                if (_.isEmpty(updateKeys)) {
                    fragments.push("DO NOTHING");
                } else {
                    fragments.push("DO UPDATE SET", updateKeys.join(","));
                }
                onDuplicateKeyUpdate = ` ${Utils.joinSQLFragments(fragments)}`;
            } else {
                const valueKeys = options.updateOnDuplicate.map((attr)=>`${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
                if (_.isEmpty(valueKeys) && options.upsertKeys) {
                    valueKeys.push(...options.upsertKeys.map((attr)=>`${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));
                }
                if (_.isEmpty(valueKeys)) {
                    throw new Error("No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.");
                }
                onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(",")}`;
            }
        }
        const replacements = {
            ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : "",
            onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : "",
            attributes: fields.join(","),
            output: outputFragment,
            values: values.join(","),
            tmpTable
        };
        valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;
        emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;
        if (this._dialect.supports.EXCEPTION && options.exception) {
            const dropFunction = "DROP FUNCTION IF EXISTS pg_temp.testfunc()";
            if (returningModelAttributes.length === 0) {
                returningModelAttributes.push("*");
            }
            const delimiter = `$func_${uuidv4().replace(/-/g, "")}$`;
            const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(", (testfunc.response).")}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;
            options.exception = "WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;";
            valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;
        } else {
            valueQuery += returningFragment;
            emptyQuery += returningFragment;
        }
        if (this._dialect.supports.returnIntoValues && options.returning) {
            this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);
        }
        query = `${replacements.attributes.length ? valueQuery : emptyQuery}${returnAttributes.join(",")};`;
        if (this._dialect.supports.finalTable) {
            query = `SELECT * FROM FINAL TABLE(${replacements.attributes.length ? valueQuery : emptyQuery});`;
        }
        if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {
            query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;
        }
        const result = {
            query
        };
        if (options.bindParam !== false) {
            result.bind = bind;
        }
        return result;
    }
    bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
        options = options || {};
        fieldMappedAttributes = fieldMappedAttributes || {};
        const tuples = [];
        const serials = {};
        const allAttributes = [];
        let onDuplicateKeyUpdate = "";
        for (const fieldValueHash of fieldValueHashes){
            _.forOwn(fieldValueHash, (value, key)=>{
                if (!allAttributes.includes(key)) {
                    allAttributes.push(key);
                }
                if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {
                    serials[key] = true;
                }
            });
        }
        for (const fieldValueHash of fieldValueHashes){
            const values = allAttributes.map((key)=>{
                if (this._dialect.supports.bulkDefault && serials[key] === true) {
                    return fieldValueHash[key] != null ? fieldValueHash[key] : "DEFAULT";
                }
                return this.escape(fieldValueHash[key], fieldMappedAttributes[key], {
                    context: "INSERT"
                });
            });
            tuples.push(`(${values.join(",")})`);
        }
        if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {
            if (this._dialect.supports.inserts.updateOnDuplicate == " ON CONFLICT DO UPDATE SET") {
                const conflictKeys = options.upsertKeys.map((attr)=>this.quoteIdentifier(attr));
                const updateKeys = options.updateOnDuplicate.map((attr)=>`${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);
                let whereClause = false;
                if (options.conflictWhere) {
                    if (!this._dialect.supports.inserts.onConflictWhere) {
                        throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);
                    }
                    whereClause = this.whereQuery(options.conflictWhere, options);
                }
                onDuplicateKeyUpdate = [
                    "ON CONFLICT",
                    "(",
                    conflictKeys.join(","),
                    ")",
                    whereClause,
                    "DO UPDATE SET",
                    updateKeys.join(",")
                ];
            } else {
                if (options.conflictWhere) {
                    throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);
                }
                const valueKeys = options.updateOnDuplicate.map((attr)=>`${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);
                onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(",")}`;
            }
        }
        const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : "";
        const attributes = allAttributes.map((attr)=>this.quoteIdentifier(attr)).join(",");
        const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : "";
        let returning = "";
        if (this._dialect.supports.returnValues && options.returning) {
            const returnValues = this.generateReturnValues(fieldMappedAttributes, options);
            returning += returnValues.returningFragment;
        }
        return Utils.joinSQLFragments([
            "INSERT",
            ignoreDuplicates,
            "INTO",
            this.quoteTable(tableName),
            `(${attributes})`,
            "VALUES",
            tuples.join(","),
            onDuplicateKeyUpdate,
            onConflictDoNothing,
            returning,
            ";"
        ]);
    }
    updateQuery(tableName, attrValueHash, where, options, attributes) {
        options = options || {};
        _.defaults(options, this.options);
        attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
        const values = [];
        const bind = [];
        const modelAttributeMap = {};
        let outputFragment = "";
        let tmpTable = "";
        let suffix = "";
        if (_.get(this, [
            "sequelize",
            "options",
            "dialectOptions",
            "prependSearchPath"
        ]) || options.searchPath) {
            options.bindParam = false;
        }
        const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;
        if (this._dialect.supports["LIMIT ON UPDATE"] && options.limit) {
            if (![
                "mssql",
                "db2",
                "oracle"
            ].includes(this.dialect)) {
                suffix = ` LIMIT ${this.escape(options.limit)} `;
            } else if (this.dialect === "oracle") {
                if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {
                    suffix += " AND ";
                } else {
                    suffix += " WHERE ";
                }
                suffix += `rownum <= ${this.escape(options.limit)} `;
            }
        }
        if (this._dialect.supports.returnValues && options.returning) {
            const returnValues = this.generateReturnValues(attributes, options);
            suffix += returnValues.returningFragment;
            tmpTable = returnValues.tmpTable || "";
            outputFragment = returnValues.outputFragment || "";
            if (!this._dialect.supports.returnValues.output && options.returning) {
                options.mapToModel = true;
            }
        }
        if (attributes) {
            _.each(attributes, (attribute, key)=>{
                modelAttributeMap[key] = attribute;
                if (attribute.field) {
                    modelAttributeMap[attribute.field] = attribute;
                }
            });
        }
        for(const key in attrValueHash){
            if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {
                continue;
            }
            const value = attrValueHash[key];
            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
                values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                })}`);
            } else {
                values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                }, bindParam)}`);
            }
        }
        const whereOptions = __spreadProps(__spreadValues({}, options), {
            bindParam
        });
        if (values.length === 0) {
            return "";
        }
        const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(",")}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();
        const result = {
            query
        };
        if (options.bindParam !== false) {
            result.bind = bind;
        }
        return result;
    }
    arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
        options = options || {};
        _.defaults(options, {
            returning: true
        });
        extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);
        let outputFragment = "";
        let returningFragment = "";
        if (this._dialect.supports.returnValues && options.returning) {
            const returnValues = this.generateReturnValues(null, options);
            outputFragment = returnValues.outputFragment;
            returningFragment = returnValues.returningFragment;
        }
        const updateSetSqlFragments = [];
        for(const field in incrementAmountsByField){
            const incrementAmount = incrementAmountsByField[field];
            const quotedField = this.quoteIdentifier(field);
            const escapedAmount = this.escape(incrementAmount);
            updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);
        }
        for(const field in extraAttributesToBeUpdated){
            const newValue = extraAttributesToBeUpdated[field];
            const quotedField = this.quoteIdentifier(field);
            const escapedValue = this.escape(newValue);
            updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);
        }
        return Utils.joinSQLFragments([
            "UPDATE",
            this.quoteTable(tableName),
            "SET",
            updateSetSqlFragments.join(","),
            outputFragment,
            this.whereQuery(where),
            returningFragment
        ]);
    }
    addIndexQuery(tableName, attributes, options, rawTablename) {
        options = options || {};
        if (!Array.isArray(attributes)) {
            options = attributes;
            attributes = void 0;
        } else {
            options.fields = attributes;
        }
        options.prefix = options.prefix || rawTablename || tableName;
        if (options.prefix && typeof options.prefix === "string") {
            options.prefix = options.prefix.replace(/\./g, "_");
            options.prefix = options.prefix.replace(/("|')/g, "");
        }
        const fieldsSql = options.fields.map((field)=>{
            if (field instanceof Utils.SequelizeMethod) {
                return this.handleSequelizeMethod(field);
            }
            if (typeof field === "string") {
                field = {
                    name: field
                };
            }
            let result = "";
            if (field.attribute) {
                field.name = field.attribute;
            }
            if (!field.name) {
                throw new Error(`The following index field has no name: ${util.inspect(field)}`);
            }
            result += this.quoteIdentifier(field.name);
            if (this._dialect.supports.index.collate && field.collate) {
                result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;
            }
            if (this._dialect.supports.index.operator) {
                const operator = field.operator || options.operator;
                if (operator) {
                    result += ` ${operator}`;
                }
            }
            if (this._dialect.supports.index.length && field.length) {
                result += `(${field.length})`;
            }
            if (field.order) {
                result += ` ${field.order}`;
            }
            return result;
        });
        if (!options.name) {
            options = Utils.nameIndex(options, options.prefix);
        }
        options = Model._conformIndex(options);
        if (!this._dialect.supports.index.type) {
            delete options.type;
        }
        if (options.where) {
            options.where = this.whereQuery(options.where);
        }
        if (typeof tableName === "string") {
            tableName = this.quoteIdentifiers(tableName);
        } else {
            tableName = this.quoteTable(tableName);
        }
        const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? "CONCURRENTLY" : void 0;
        let ind;
        if (this._dialect.supports.indexViaAlter) {
            ind = [
                "ALTER TABLE",
                tableName,
                concurrently,
                "ADD"
            ];
        } else {
            ind = [
                "CREATE"
            ];
        }
        ind = ind.concat(options.unique ? "UNIQUE" : "", options.type, "INDEX", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : "", !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : void 0, this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : "", `(${fieldsSql.join(", ")})`, this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);
        return _.compact(ind).join(" ");
    }
    addConstraintQuery(tableName, options) {
        if (typeof tableName === "string") {
            tableName = this.quoteIdentifiers(tableName);
        } else {
            tableName = this.quoteTable(tableName);
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            tableName,
            "ADD",
            this.getConstraintSnippet(tableName, options || {}),
            ";"
        ]);
    }
    getConstraintSnippet(tableName, options) {
        let constraintSnippet, constraintName;
        const fieldsSql = options.fields.map((field)=>{
            if (typeof field === "string") {
                return this.quoteIdentifier(field);
            }
            if (field instanceof Utils.SequelizeMethod) {
                return this.handleSequelizeMethod(field);
            }
            if (field.attribute) {
                field.name = field.attribute;
            }
            if (!field.name) {
                throw new Error(`The following index field has no name: ${field}`);
            }
            return this.quoteIdentifier(field.name);
        });
        const fieldsSqlQuotedString = fieldsSql.join(", ");
        const fieldsSqlString = fieldsSql.join("_");
        switch(options.type.toUpperCase()){
            case "UNIQUE":
                constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);
                constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;
                break;
            case "CHECK":
                options.where = this.whereItemsQuery(options.where);
                constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);
                constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;
                break;
            case "DEFAULT":
                if (options.defaultValue === void 0) {
                    throw new Error("Default value must be specified for DEFAULT CONSTRAINT");
                }
                if (this._dialect.name !== "mssql") {
                    throw new Error("Default constraints are supported only for MSSQL dialect.");
                }
                constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);
                constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;
                break;
            case "PRIMARY KEY":
                constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);
                constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;
                break;
            case "FOREIGN KEY":
                const references = options.references;
                if (!references || !references.table || !(references.field || references.fields)) {
                    throw new Error("references object with table and field must be specified");
                }
                constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);
                const quotedReferences = typeof references.field !== "undefined" ? this.quoteIdentifier(references.field) : references.fields.map((f)=>this.quoteIdentifier(f)).join(", ");
                const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;
                constraintSnippet = `CONSTRAINT ${constraintName} `;
                constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;
                if (options.onUpdate) {
                    constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;
                }
                if (options.onDelete) {
                    constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;
                }
                break;
            default:
                throw new Error(`${options.type} is invalid.`);
        }
        if (options.deferrable && [
            "UNIQUE",
            "PRIMARY KEY",
            "FOREIGN KEY"
        ].includes(options.type.toUpperCase())) {
            constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;
        }
        return constraintSnippet;
    }
    removeConstraintQuery(tableName, constraintName) {
        if (typeof tableName === "string") {
            tableName = this.quoteIdentifiers(tableName);
        } else {
            tableName = this.quoteTable(tableName);
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            tableName,
            "DROP CONSTRAINT",
            this.quoteIdentifiers(constraintName)
        ]);
    }
    quote(collection, parent, connector) {
        const validOrderOptions = [
            "ASC",
            "DESC",
            "ASC NULLS LAST",
            "DESC NULLS LAST",
            "ASC NULLS FIRST",
            "DESC NULLS FIRST",
            "NULLS FIRST",
            "NULLS LAST"
        ];
        connector = connector || ".";
        if (typeof collection === "string") {
            return this.quoteIdentifiers(collection);
        }
        if (Array.isArray(collection)) {
            collection.forEach((item2, index)=>{
                const previous = collection[index - 1];
                let previousAssociation;
                let previousModel;
                if (!previous && parent !== void 0) {
                    previousModel = parent;
                } else if (previous && previous instanceof Association) {
                    previousAssociation = previous;
                    previousModel = previous.target;
                }
                if (previousModel && previousModel.prototype instanceof Model) {
                    let model;
                    let as;
                    if (typeof item2 === "function" && item2.prototype instanceof Model) {
                        model = item2;
                    } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {
                        model = item2.model;
                        as = item2.as;
                    }
                    if (model) {
                        if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {
                            item2 = new Association(previousModel, model, {
                                as: model.name
                            });
                        } else {
                            item2 = previousModel.getAssociationForAlias(model, as);
                            if (!item2) {
                                item2 = previousModel.getAssociationForAlias(model, model.name);
                            }
                        }
                        if (!(item2 instanceof Association)) {
                            throw new Error(util.format("Unable to find a valid association for model, '%s'", model.name));
                        }
                    }
                }
                if (typeof item2 === "string") {
                    const orderIndex = validOrderOptions.indexOf(item2.toUpperCase());
                    if (index > 0 && orderIndex !== -1) {
                        item2 = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);
                    } else if (previousModel && previousModel.prototype instanceof Model) {
                        if (previousModel.associations !== void 0 && previousModel.associations[item2]) {
                            item2 = previousModel.associations[item2];
                        } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {
                            item2 = previousModel.rawAttributes[item2].field;
                        } else if (item2.includes(".") && previousModel.rawAttributes !== void 0) {
                            const itemSplit = item2.split(".");
                            if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {
                                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);
                                const path = itemSplit.slice(1);
                                item2 = this.jsonPathExtractionQuery(identifier, path);
                                item2 = this.sequelize.literal(item2);
                            }
                        }
                    }
                }
                collection[index] = item2;
            }, this);
            const collectionLength = collection.length;
            const tableNames = [];
            let item;
            let i = 0;
            for(i = 0; i < collectionLength - 1; i++){
                item = collection[i];
                if (typeof item === "string" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {
                    break;
                } else if (item instanceof Association) {
                    tableNames[i] = item.as;
                }
            }
            let sql = "";
            if (i > 0) {
                sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;
            } else if (typeof collection[0] === "string" && parent) {
                sql += `${this.quoteIdentifier(parent.name)}.`;
            }
            collection.slice(i).forEach((collectionItem)=>{
                sql += this.quote(collectionItem, parent, connector);
            }, this);
            return sql;
        }
        if (collection._modelAttribute) {
            return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;
        }
        if (collection instanceof Utils.SequelizeMethod) {
            return this.handleSequelizeMethod(collection);
        }
        if (_.isPlainObject(collection) && collection.raw) {
            throw new Error('The `{raw: "..."}` syntax is no longer supported.  Use `sequelize.literal` instead.');
        }
        throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);
    }
    _initQuoteIdentifier() {
        this._quoteIdentifier = this.quoteIdentifier;
        this.quoteIdentifier = function(identifier, force) {
            if (identifier === "*") return identifier;
            return this._quoteIdentifier(identifier, force);
        };
    }
    quoteIdentifier(identifier, force) {
        throw new Error(`quoteIdentifier for Dialect "${this.dialect}" is not implemented`);
    }
    quoteIdentifiers(identifiers) {
        if (identifiers.includes(".")) {
            identifiers = identifiers.split(".");
            const head = identifiers.slice(0, identifiers.length - 1).join("->");
            const tail = identifiers[identifiers.length - 1];
            return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;
        }
        return this.quoteIdentifier(identifiers);
    }
    quoteAttribute(attribute, model) {
        if (model && attribute in model.rawAttributes) {
            return this.quoteIdentifier(attribute);
        }
        return this.quoteIdentifiers(attribute);
    }
    getAliasToken() {
        return "AS";
    }
    quoteTable(param, alias) {
        let table = "";
        if (alias === true) {
            alias = param.as || param.name || param;
        }
        if (_.isObject(param)) {
            if (this._dialect.supports.schemas) {
                if (param.schema) {
                    table += `${this.quoteIdentifier(param.schema)}.`;
                }
                table += this.quoteIdentifier(param.tableName);
            } else {
                if (param.schema) {
                    table += param.schema + (param.delimiter || ".");
                }
                table += param.tableName;
                table = this.quoteIdentifier(table);
            }
        } else {
            table = this.quoteIdentifier(param);
        }
        if (alias) {
            table += ` ${this.getAliasToken()} ${this.quoteIdentifier(alias)}`;
        }
        return table;
    }
    escape(value, field, options) {
        options = options || {};
        if (value !== null && value !== void 0) {
            if (value instanceof Utils.SequelizeMethod) {
                return this.handleSequelizeMethod(value);
            }
            if (field && field.type) {
                if (field.type instanceof DataTypes.STRING && [
                    "mysql",
                    "mariadb"
                ].includes(this.dialect) && [
                    "number",
                    "boolean"
                ].includes(typeof value)) {
                    value = String(Number(value));
                }
                this.validate(value, field, options);
                if (field.type.stringify) {
                    const simpleEscape = (escVal)=>SqlString.escape(escVal, this.options.timezone, this.dialect);
                    value = field.type.stringify(value, {
                        escape: simpleEscape,
                        field,
                        timezone: this.options.timezone,
                        operation: options.operation
                    });
                    if (field.type.escape === false) {
                        return value;
                    }
                }
            }
        }
        return SqlString.escape(value, this.options.timezone, this.dialect);
    }
    bindParam(bind) {
        return (value)=>{
            bind.push(value);
            return `$${bind.length}`;
        };
    }
    format(value, field, options, bindParam) {
        options = options || {};
        if (value !== null && value !== void 0) {
            if (value instanceof Utils.SequelizeMethod) {
                throw new Error("Cannot pass SequelizeMethod as a bind parameter - use escape instead");
            }
            if (field && field.type) {
                this.validate(value, field, options);
                if (field.type.bindParam) {
                    return field.type.bindParam(value, {
                        escape: _.identity,
                        field,
                        timezone: this.options.timezone,
                        operation: options.operation,
                        bindParam
                    });
                }
            }
        }
        return bindParam(value);
    }
    validate(value, field, options) {
        if (this.typeValidation && field.type.validate && value) {
            try {
                if (options.isList && Array.isArray(value)) {
                    for (const item of value){
                        field.type.validate(item, options);
                    }
                } else {
                    field.type.validate(value, options);
                }
            } catch (error) {
                if (error instanceof sequelizeError.ValidationError) {
                    error.errors.push(new sequelizeError.ValidationErrorItem(error.message, "Validation error", field.fieldName, value, null, `${field.type.key} validator`));
                }
                throw error;
            }
        }
    }
    isIdentifierQuoted(identifier) {
        return /^\s*(?:([`"'])(?:(?!\1).|\1{2})*\1\.?)+\s*$/i.test(identifier);
    }
    jsonPathExtractionQuery(column, path, isJson) {
        let paths = _.toPath(path);
        let pathStr;
        const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);
        switch(this.dialect){
            case "mysql":
            case "mariadb":
            case "sqlite":
                if (this.dialect === "mysql") {
                    paths = paths.map((subPath)=>{
                        return /\D/.test(subPath) ? Utils.addTicks(subPath, '"') : subPath;
                    });
                }
                pathStr = this.escape([
                    "$"
                ].concat(paths).join(".").replace(/\.(\d+)(?:(?=\.)|$)/g, (__, digit)=>`[${digit}]`));
                if (this.dialect === "sqlite") {
                    return `json_extract(${quotedColumn},${pathStr})`;
                }
                return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;
            case "postgres":
                const join = isJson ? "#>" : "#>>";
                pathStr = this.escape(`{${paths.join(",")}}`);
                return `(${quotedColumn}${join}${pathStr})`;
            default:
                throw new Error(`Unsupported ${this.dialect} for JSON operations`);
        }
    }
    selectQuery(tableName, options, model) {
        options = options || {};
        const limit = options.limit;
        const mainQueryItems = [];
        const subQueryItems = [];
        const subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;
        const attributes = {
            main: options.attributes && options.attributes.slice(),
            subQuery: null
        };
        const mainTable = {
            name: tableName,
            quotedName: null,
            as: null,
            model
        };
        const topLevelInfo = {
            names: mainTable,
            options,
            subQuery
        };
        let mainJoinQueries = [];
        let subJoinQueries = [];
        let query;
        if (this.options.minifyAliases && !options.aliasesMapping) {
            options.aliasesMapping = /* @__PURE__ */ new Map();
            options.aliasesByTable = {};
            options.includeAliases = /* @__PURE__ */ new Map();
        }
        if (options.tableAs) {
            mainTable.as = this.quoteIdentifier(options.tableAs);
        } else if (!Array.isArray(mainTable.name) && mainTable.model) {
            mainTable.as = this.quoteIdentifier(mainTable.model.name);
        }
        mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map((t)=>{
            return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);
        }).join(", ");
        if (subQuery && attributes.main) {
            for (const keyAtt of mainTable.model.primaryKeyAttributes){
                if (!attributes.main.some((attr)=>keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {
                    attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [
                        keyAtt,
                        mainTable.model.rawAttributes[keyAtt].field
                    ] : keyAtt);
                }
            }
        }
        attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);
        attributes.main = attributes.main || (options.include ? [
            `${mainTable.as}.*`
        ] : [
            "*"
        ]);
        if (subQuery || options.groupedLimit) {
            attributes.subQuery = attributes.main;
            attributes.main = [
                `${mainTable.as || mainTable.quotedName}.*`
            ];
        }
        if (options.include) {
            for (const include of options.include){
                if (include.separate) {
                    continue;
                }
                const joinQueries = this.generateInclude(include, {
                    externalAs: mainTable.as,
                    internalAs: mainTable.as
                }, topLevelInfo);
                subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);
                mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);
                if (joinQueries.attributes.main.length > 0) {
                    attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));
                }
                if (joinQueries.attributes.subQuery.length > 0) {
                    attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));
                }
            }
        }
        if (subQuery) {
            subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));
            subQueryItems.push(subJoinQueries.join(""));
        } else {
            if (options.groupedLimit) {
                if (!mainTable.as) {
                    mainTable.as = mainTable.quotedName;
                }
                const where = __spreadValues({}, options.where);
                let groupedLimitOrder, whereKey, include, groupedTableName = mainTable.as;
                if (typeof options.groupedLimit.on === "string") {
                    whereKey = options.groupedLimit.on;
                } else if (options.groupedLimit.on instanceof HasMany) {
                    whereKey = options.groupedLimit.on.foreignKeyField;
                }
                if (options.groupedLimit.on instanceof BelongsToMany) {
                    groupedTableName = options.groupedLimit.on.manyFromSource.as;
                    const groupedLimitOptions = Model._validateIncludedElements({
                        include: [
                            {
                                association: options.groupedLimit.on.manyFromSource,
                                duplicating: false,
                                required: true,
                                where: __spreadValues({
                                    [Op.placeholder]: true
                                }, options.groupedLimit.through && options.groupedLimit.through.where)
                            }
                        ],
                        model
                    });
                    options.hasJoin = true;
                    options.hasMultiAssociation = true;
                    options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);
                    options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);
                    include = groupedLimitOptions.include;
                    if (Array.isArray(options.order)) {
                        options.order.forEach((order, i)=>{
                            if (Array.isArray(order)) {
                                order = order[0];
                            }
                            let alias = `subquery_order_${i}`;
                            options.attributes.push([
                                order,
                                alias
                            ]);
                            alias = this.sequelize.literal(this.quote(alias));
                            if (Array.isArray(options.order[i])) {
                                options.order[i][0] = alias;
                            } else {
                                options.order[i] = alias;
                            }
                        });
                        groupedLimitOrder = options.order;
                    }
                } else {
                    groupedLimitOrder = options.order;
                    if (!this._dialect.supports.topLevelOrderByRequired) {
                        delete options.order;
                    }
                    where[Op.placeholder] = true;
                }
                const baseQuery = `SELECT * FROM (${this.selectQuery(tableName, {
                    attributes: options.attributes,
                    offset: options.offset,
                    limit: options.groupedLimit.limit,
                    order: groupedLimitOrder,
                    aliasesMapping: options.aliasesMapping,
                    aliasesByTable: options.aliasesByTable,
                    where,
                    include,
                    model
                }, model).replace(/;$/, "")}) ${this.getAliasToken()} sub`;
                const placeHolder = this.whereItemQuery(Op.placeholder, true, {
                    model
                });
                const splicePos = baseQuery.indexOf(placeHolder);
                mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${options.groupedLimit.values.map((value)=>{
                    let groupWhere;
                    if (whereKey) {
                        groupWhere = {
                            [whereKey]: value
                        };
                    }
                    if (include) {
                        groupWhere = {
                            [options.groupedLimit.on.foreignIdentifierField]: value
                        };
                    }
                    return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));
                }).join(this._dialect.supports["UNION ALL"] ? " UNION ALL " : " UNION ")})`, mainTable.as));
            } else {
                mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));
            }
            mainQueryItems.push(mainJoinQueries.join(""));
        }
        if (Object.prototype.hasOwnProperty.call(options, "where") && !options.groupedLimit) {
            options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);
            if (options.where) {
                if (subQuery) {
                    subQueryItems.push(` WHERE ${options.where}`);
                } else {
                    mainQueryItems.push(` WHERE ${options.where}`);
                    mainQueryItems.forEach((value, key)=>{
                        if (value.startsWith("SELECT")) {
                            mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);
                        }
                    });
                }
            }
        }
        if (options.group) {
            options.group = Array.isArray(options.group) ? options.group.map((t)=>this.aliasGrouping(t, model, mainTable.as, options)).join(", ") : this.aliasGrouping(options.group, model, mainTable.as, options);
            if (subQuery && options.group) {
                subQueryItems.push(` GROUP BY ${options.group}`);
            } else if (options.group) {
                mainQueryItems.push(` GROUP BY ${options.group}`);
            }
        }
        if (Object.prototype.hasOwnProperty.call(options, "having")) {
            options.having = this.getWhereConditions(options.having, tableName, model, options, false);
            if (options.having) {
                if (subQuery) {
                    subQueryItems.push(` HAVING ${options.having}`);
                } else {
                    mainQueryItems.push(` HAVING ${options.having}`);
                }
            }
        }
        if (options.order) {
            const orders = this.getQueryOrders(options, model, subQuery);
            if (orders.mainQueryOrder.length) {
                mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(", ")}`);
            }
            if (orders.subQueryOrder.length) {
                subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(", ")}`);
            }
        }
        const limitOrder = this.addLimitAndOffset(options, mainTable.model);
        if (limitOrder && !options.groupedLimit) {
            if (subQuery) {
                subQueryItems.push(limitOrder);
            } else {
                mainQueryItems.push(limitOrder);
            }
        }
        if (subQuery) {
            this._throwOnEmptyAttributes(attributes.main, {
                modelName: model && model.name,
                as: mainTable.as
            });
            query = `SELECT ${attributes.main.join(", ")} FROM (${subQueryItems.join("")}) ${this.getAliasToken()} ${mainTable.as}${mainJoinQueries.join("")}${mainQueryItems.join("")}`;
        } else {
            query = mainQueryItems.join("");
        }
        if (options.lock && this._dialect.supports.lock) {
            let lock = options.lock;
            if (typeof options.lock === "object") {
                lock = options.lock.level;
            }
            if (this._dialect.supports.lockKey && [
                "KEY SHARE",
                "NO KEY UPDATE"
            ].includes(lock)) {
                query += ` FOR ${lock}`;
            } else if (lock === "SHARE") {
                query += ` ${this._dialect.supports.forShare}`;
            } else {
                query += " FOR UPDATE";
            }
            if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {
                query += ` OF ${this.quoteTable(options.lock.of.name)}`;
            }
            if (this._dialect.supports.skipLocked && options.skipLocked) {
                query += " SKIP LOCKED";
            }
        }
        return `${query};`;
    }
    aliasGrouping(field, model, tableName, options) {
        const src = Array.isArray(field) ? field[0] : field;
        return this.quote(this._getAliasForField(tableName, src, options) || src, model);
    }
    escapeAttributes(attributes, options, mainTableAs) {
        return attributes && attributes.map((attr)=>{
            let addTable = true;
            if (attr instanceof Utils.SequelizeMethod) {
                return this.handleSequelizeMethod(attr);
            }
            if (Array.isArray(attr)) {
                if (attr.length !== 2) {
                    throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);
                }
                attr = attr.slice();
                if (attr[0] instanceof Utils.SequelizeMethod) {
                    attr[0] = this.handleSequelizeMethod(attr[0]);
                    addTable = false;
                } else if (this.options.attributeBehavior === "escape" || !attr[0].includes("(") && !attr[0].includes(")")) {
                    attr[0] = this.quoteIdentifier(attr[0]);
                } else if (this.options.attributeBehavior !== "unsafe-legacy") {
                    throw new Error(`Attributes cannot include parentheses in Sequelize 6:
In order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.
Sequelize 7 escapes all attributes, even if they include parentheses.
For Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.

Here is what you can do to fix this error:
- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.
- Set the "attributeBehavior" sequelize option to "escape" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.
- Set the "attributeBehavior" sequelize option to "unsafe-legacy" to make Sequelize escape the attribute, like in Sequelize v5.

We sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:
https://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx
https://github.com/sequelize/sequelize/discussions/15694`);
                }
                let alias = attr[1];
                if (this.options.minifyAliases) {
                    alias = this._getMinifiedAlias(alias, mainTableAs, options);
                }
                attr = [
                    attr[0],
                    this.quoteIdentifier(alias)
                ].join(" AS ");
            } else {
                attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('"') ? this.quoteAttribute(attr, options.model) : this.escape(attr);
            }
            if (!_.isEmpty(options.include) && (!attr.includes(".") || options.dotNotation) && addTable) {
                attr = `${mainTableAs}.${attr}`;
            }
            return attr;
        });
    }
    generateInclude(include, parentTableName, topLevelInfo) {
        const joinQueries = {
            mainQuery: [],
            subQuery: []
        };
        const mainChildIncludes = [];
        const subChildIncludes = [];
        let requiredMismatch = false;
        const includeAs = {
            internalAs: include.as,
            externalAs: include.as
        };
        const attributes = {
            main: [],
            subQuery: []
        };
        let joinQuery;
        topLevelInfo.options.keysEscaped = true;
        if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {
            includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;
            includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;
        }
        if (topLevelInfo.options.includeIgnoreAttributes !== false) {
            include.model._expandAttributes(include);
            Utils.mapFinderOptions(include, include.model);
            const includeAttributes = include.attributes.map((attr)=>{
                let attrAs = attr;
                let verbatim = false;
                if (Array.isArray(attr) && attr.length === 2) {
                    if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {
                        verbatim = true;
                    }
                    attr = attr.map((attr2)=>attr2 instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr2) : attr2);
                    attrAs = attr[1];
                    attr = attr[0];
                }
                if (attr instanceof Utils.Literal) {
                    return attr.val;
                }
                if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {
                    throw new Error("Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance");
                }
                let prefix;
                if (verbatim === true) {
                    prefix = attr;
                } else if (/#>>|->>/.test(attr)) {
                    prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\(|\)/g, "")})`;
                } else if (/json_extract\(/.test(attr)) {
                    prefix = attr.replace(/json_extract\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);
                } else if (/json_value\(/.test(attr)) {
                    prefix = attr.replace(/json_value\(/i, `json_value(${this.quoteIdentifier(includeAs.internalAs)}.`);
                } else {
                    prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;
                }
                let alias = `${includeAs.externalAs}.${attrAs}`;
                if (this.options.minifyAliases) {
                    alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);
                }
                return Utils.joinSQLFragments([
                    prefix,
                    "AS",
                    this.quoteIdentifier(alias, true)
                ]);
            });
            if (include.subQuery && topLevelInfo.subQuery) {
                for (const attr of includeAttributes){
                    attributes.subQuery.push(attr);
                }
            } else {
                for (const attr of includeAttributes){
                    attributes.main.push(attr);
                }
            }
        }
        if (include.through) {
            joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);
        } else {
            this._generateSubQueryFilter(include, includeAs, topLevelInfo);
            joinQuery = this.generateJoin(include, topLevelInfo);
        }
        if (joinQuery.attributes.main.length > 0) {
            attributes.main = attributes.main.concat(joinQuery.attributes.main);
        }
        if (joinQuery.attributes.subQuery.length > 0) {
            attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);
        }
        if (include.include) {
            for (const childInclude of include.include){
                if (childInclude.separate || childInclude._pseudo) {
                    continue;
                }
                const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);
                if (include.required === false && childInclude.required === true) {
                    requiredMismatch = true;
                }
                if (childInclude.subQuery && topLevelInfo.subQuery) {
                    subChildIncludes.push(childJoinQueries.subQuery);
                }
                if (childJoinQueries.mainQuery) {
                    mainChildIncludes.push(childJoinQueries.mainQuery);
                }
                if (childJoinQueries.attributes.main.length > 0) {
                    attributes.main = attributes.main.concat(childJoinQueries.attributes.main);
                }
                if (childJoinQueries.attributes.subQuery.length > 0) {
                    attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);
                }
            }
        }
        if (include.subQuery && topLevelInfo.subQuery) {
            if (requiredMismatch && subChildIncludes.length > 0) {
                joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join("")} ) ON ${joinQuery.condition}`);
            } else {
                joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
                if (subChildIncludes.length > 0) {
                    joinQueries.subQuery.push(subChildIncludes.join(""));
                }
            }
            joinQueries.mainQuery.push(mainChildIncludes.join(""));
        } else {
            if (requiredMismatch && mainChildIncludes.length > 0) {
                joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join("")} ) ON ${joinQuery.condition}`);
            } else {
                joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);
                if (mainChildIncludes.length > 0) {
                    joinQueries.mainQuery.push(mainChildIncludes.join(""));
                }
            }
            joinQueries.subQuery.push(subChildIncludes.join(""));
        }
        return {
            mainQuery: joinQueries.mainQuery.join(""),
            subQuery: joinQueries.subQuery.join(""),
            attributes
        };
    }
    _getMinifiedAlias(alias, tableName, options) {
        if (options.aliasesByTable[`${tableName}${alias}`]) {
            return options.aliasesByTable[`${tableName}${alias}`];
        }
        if (alias.match(/subquery_order_[0-9]/)) {
            return alias;
        }
        const minifiedAlias = `_${options.aliasesMapping.size}`;
        options.aliasesMapping.set(minifiedAlias, alias);
        options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;
        return minifiedAlias;
    }
    _getAliasForField(tableName, field, options) {
        if (this.options.minifyAliases) {
            if (options.aliasesByTable[`${tableName}${field}`]) {
                return options.aliasesByTable[`${tableName}${field}`];
            }
        }
        return null;
    }
    generateJoin(include, topLevelInfo) {
        const association = include.association;
        const parent = include.parent;
        const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
        let $parent;
        let joinWhere;
        const left = association.source;
        const attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;
        const fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;
        let asLeft;
        const right = include.model;
        const tableRight = right.getTableName();
        const fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;
        let asRight = include.as;
        while(($parent = $parent && $parent.parent || include.parent) && $parent.association){
            if (asLeft) {
                asLeft = `${$parent.as}->${asLeft}`;
            } else {
                asLeft = $parent.as;
            }
        }
        if (!asLeft) asLeft = parent.as || parent.model.name;
        else asRight = `${asLeft}->${asRight}`;
        let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;
        const subqueryAttributes = [];
        if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {
            if (parentIsTop) {
                const tableName = this.quoteTable(parent.as || parent.model.name);
                joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;
                if (topLevelInfo.subQuery) {
                    const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;
                    subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);
                }
            } else {
                const joinSource = `${asLeft.replace(/->/g, ".")}.${attrLeft}`;
                joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);
            }
        }
        joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;
        if (include.on) {
            joinOn = this.whereItemsQuery(include.on, {
                prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
                model: include.model
            });
        }
        if (include.where) {
            joinWhere = this.whereItemsQuery(include.where, {
                prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),
                model: include.model
            });
            if (joinWhere) {
                if (include.or) {
                    joinOn += ` OR ${joinWhere}`;
                } else {
                    joinOn += ` AND ${joinWhere}`;
                }
            }
        }
        this.aliasAs(asRight, topLevelInfo);
        return {
            join: include.required ? "INNER JOIN" : include.right && this._dialect.supports["RIGHT JOIN"] ? "RIGHT OUTER JOIN" : "LEFT OUTER JOIN",
            body: this.quoteTable(tableRight, asRight),
            condition: joinOn,
            attributes: {
                main: [],
                subQuery: subqueryAttributes
            }
        };
    }
    generateReturnValues(modelAttributes, options) {
        const returnFields = [];
        const returnTypes = [];
        let outputFragment = "";
        let returningFragment = "";
        let tmpTable = "";
        if (Array.isArray(options.returning)) {
            returnFields.push(...options.returning.map((field)=>this.quoteIdentifier(field)));
        } else if (modelAttributes) {
            _.each(modelAttributes, (attribute)=>{
                if (!(attribute.type instanceof DataTypes.VIRTUAL)) {
                    returnFields.push(this.quoteIdentifier(attribute.field));
                    returnTypes.push(attribute.type);
                }
            });
        }
        if (_.isEmpty(returnFields)) {
            returnFields.push("*");
        }
        if (this._dialect.supports.returnValues.returning) {
            returningFragment = ` RETURNING ${returnFields.join(",")}`;
        } else if (this._dialect.supports.returnIntoValues) {
            returningFragment = ` RETURNING ${returnFields.join(",")} INTO `;
        } else if (this._dialect.supports.returnValues.output) {
            outputFragment = ` OUTPUT ${returnFields.map((field)=>`INSERTED.${field}`).join(",")}`;
            if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {
                const tmpColumns = returnFields.map((field, i)=>`${field} ${returnTypes[i].toSql()}`);
                tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(",")}); `;
                outputFragment += " INTO @tmp";
                returningFragment = "; SELECT * FROM @tmp";
            }
        }
        return {
            outputFragment,
            returnFields,
            returnTypes,
            returningFragment,
            tmpTable
        };
    }
    generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {
        const through = include.through;
        const throughTable = through.model.getTableName();
        const throughAs = `${includeAs.internalAs}->${through.as}`;
        const externalThroughAs = `${includeAs.externalAs}.${through.as}`;
        const throughAttributes = through.attributes.map((attr)=>{
            let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;
            if (this.options.minifyAliases) {
                alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);
            }
            return Utils.joinSQLFragments([
                `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,
                "AS",
                this.quoteIdentifier(alias)
            ]);
        });
        const association = include.association;
        const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;
        const tableSource = parentTableName;
        const identSource = association.identifierField;
        const tableTarget = includeAs.internalAs;
        const identTarget = association.foreignIdentifierField;
        const attrTarget = association.targetKeyField;
        const joinType = include.required ? "INNER JOIN" : include.right && this._dialect.supports["RIGHT JOIN"] ? "RIGHT OUTER JOIN" : "LEFT OUTER JOIN";
        let joinBody;
        let joinCondition;
        const attributes = {
            main: [],
            subQuery: []
        };
        let attrSource = association.sourceKey;
        let sourceJoinOn;
        let targetJoinOn;
        let throughWhere;
        let targetWhere;
        if (topLevelInfo.options.includeIgnoreAttributes !== false) {
            for (const attr of throughAttributes){
                attributes.main.push(attr);
            }
        }
        if (!topLevelInfo.subQuery) {
            attrSource = association.sourceKeyField;
        }
        if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {
            attrSource = association.sourceKeyField;
        }
        if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {
            const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;
            sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;
        } else {
            const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;
            sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;
        }
        sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;
        targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;
        targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;
        if (through.where) {
            throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);
        }
        this.aliasAs(includeAs.internalAs, topLevelInfo);
        joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;
        if (throughWhere) {
            joinBody += ` AND ${throughWhere}`;
        }
        joinBody += ")";
        joinCondition = sourceJoinOn;
        if (include.where || include.through.where) {
            if (include.where) {
                targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);
                if (targetWhere) {
                    joinCondition += ` AND ${targetWhere}`;
                }
            }
        }
        this._generateSubQueryFilter(include, includeAs, topLevelInfo);
        return {
            join: joinType,
            body: joinBody,
            condition: joinCondition,
            attributes
        };
    }
    aliasAs(as, topLevelInfo) {
        if (this.options.minifyAliases && as.length >= 64) {
            const alias = `%${topLevelInfo.options.includeAliases.size}`;
            topLevelInfo.options.includeAliases.set(alias, as);
        }
    }
    _generateSubQueryFilter(include, includeAs, topLevelInfo) {
        if (!topLevelInfo.subQuery || !include.subQueryFilter) {
            return;
        }
        if (!topLevelInfo.options.where) {
            topLevelInfo.options.where = {};
        }
        let parent = include;
        let child = include;
        let nestedIncludes = this._getRequiredClosure(include).include;
        let query;
        while(parent = parent.parent){
            if (parent.parent && !parent.required) {
                return;
            }
            if (parent.subQueryFilter) {
                return;
            }
            nestedIncludes = [
                __spreadProps(__spreadValues({}, child), {
                    include: nestedIncludes,
                    attributes: []
                })
            ];
            child = parent;
        }
        const topInclude = nestedIncludes[0];
        const topParent = topInclude.parent;
        const topAssociation = topInclude.association;
        topInclude.association = void 0;
        if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {
            query = this.selectQuery(topInclude.through.model.getTableName(), {
                attributes: [
                    topInclude.through.model.primaryKeyField
                ],
                include: Model._validateIncludedElements({
                    model: topInclude.through.model,
                    include: [
                        {
                            association: topAssociation.toTarget,
                            required: true,
                            where: topInclude.where,
                            include: topInclude.include
                        }
                    ]
                }).include,
                model: topInclude.through.model,
                where: {
                    [Op.and]: [
                        this.sequelize.literal([
                            `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,
                            `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`
                        ].join(" = ")),
                        topInclude.through.where
                    ]
                },
                limit: 1,
                includeIgnoreAttributes: false
            }, topInclude.through.model);
        } else {
            const isBelongsTo = topAssociation.associationType === "BelongsTo";
            const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;
            const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;
            const join = [
                `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,
                `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`
            ].join(" = ");
            query = this.selectQuery(topInclude.model.getTableName(), {
                attributes: [
                    targetField
                ],
                include: Model._validateIncludedElements(topInclude).include,
                model: topInclude.model,
                where: {
                    [Op.and]: [
                        topInclude.where,
                        {
                            [Op.join]: this.sequelize.literal(join)
                        }
                    ]
                },
                limit: 1,
                tableAs: topInclude.as,
                includeIgnoreAttributes: false
            }, topInclude.model);
        }
        if (!topLevelInfo.options.where[Op.and]) {
            topLevelInfo.options.where[Op.and] = [];
        }
        topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([
            "(",
            query.replace(/;$/, ""),
            ")",
            "IS NOT NULL"
        ].join(" "));
    }
    _getRequiredClosure(include) {
        const copy = __spreadProps(__spreadValues({}, include), {
            attributes: [],
            include: []
        });
        if (Array.isArray(include.include)) {
            copy.include = include.include.filter((i)=>i.required).map((inc)=>this._getRequiredClosure(inc));
        }
        return copy;
    }
    getQueryOrders(options, model, subQuery) {
        const mainQueryOrder = [];
        const subQueryOrder = [];
        if (Array.isArray(options.order)) {
            for (let order of options.order){
                if (!Array.isArray(order)) {
                    order = [
                        order
                    ];
                }
                if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === "function" && order[0].prototype instanceof Model) && !(typeof order[0].model === "function" && order[0].model.prototype instanceof Model) && !(typeof order[0] === "string" && model && model.associations !== void 0 && model.associations[order[0]])) {
                    const field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];
                    const subQueryAlias = this._getAliasForField(this.quoteIdentifier(model.name), field, options);
                    let parent = null;
                    let orderToQuote = [];
                    if (subQueryAlias === null) {
                        orderToQuote = order;
                        parent = model;
                    } else {
                        orderToQuote = [
                            subQueryAlias,
                            order.length > 1 ? order[1] : "ASC"
                        ];
                        parent = null;
                    }
                    subQueryOrder.push(this.quote(orderToQuote, parent, "->"));
                }
                if (options.attributes && model) {
                    const aliasedAttribute = options.attributes.find((attr)=>Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]));
                    if (aliasedAttribute) {
                        const modelName = this.quoteIdentifier(model.name);
                        const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);
                        order[0] = new Utils.Col(alias || aliasedAttribute[1]);
                    }
                }
                mainQueryOrder.push(this.quote(order, model, "->"));
            }
        } else if (options.order instanceof Utils.SequelizeMethod) {
            const sql = this.quote(options.order, model, "->");
            if (subQuery) {
                subQueryOrder.push(sql);
            }
            mainQueryOrder.push(sql);
        } else {
            throw new Error("Order must be type of array or instance of a valid sequelize method.");
        }
        return {
            mainQueryOrder,
            subQueryOrder
        };
    }
    _throwOnEmptyAttributes(attributes, extraInfo = {}) {
        if (attributes.length > 0) return;
        const asPart = extraInfo.as && `as ${extraInfo.as}` || "";
        const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || "";
        const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;
        throw new sequelizeError.QueryError(message.replace(/ +/g, " "));
    }
    selectFromTableFragment(options, model, attributes, tables, mainTableAs) {
        this._throwOnEmptyAttributes(attributes, {
            modelName: model && model.name,
            as: mainTableAs
        });
        let fragment = `SELECT ${attributes.join(", ")} FROM ${tables}`;
        if (mainTableAs) {
            fragment += ` ${this.getAliasToken()} ${mainTableAs}`;
        }
        if (options.indexHints && this._dialect.supports.indexHints) {
            for (const hint of options.indexHints){
                if (IndexHints[hint.type]) {
                    fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map((indexName)=>this.quoteIdentifiers(indexName)).join(",")})`;
                }
            }
        }
        return fragment;
    }
    addLimitAndOffset(options) {
        let fragment = "";
        if (options.offset != null && options.limit == null) {
            fragment += " LIMIT " + this.escape(options.offset) + ", " + 1e13;
        } else if (options.limit != null) {
            if (options.offset != null) {
                fragment += " LIMIT " + this.escape(options.offset) + ", " + this.escape(options.limit);
            } else {
                fragment += " LIMIT " + this.escape(options.limit);
            }
        }
        return fragment;
    }
    handleSequelizeMethod(smth, tableName, factory, options, prepend) {
        let result;
        if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {
            smth.comparator = this.OperatorMap[smth.comparator];
        }
        if (smth instanceof Utils.Where) {
            let value = smth.logic;
            let key;
            if (smth.attribute instanceof Utils.SequelizeMethod) {
                key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);
            } else {
                key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;
            }
            if (value && value instanceof Utils.SequelizeMethod) {
                value = this.getWhereConditions(value, tableName, factory, options, prepend);
                if (value === "NULL") {
                    if (smth.comparator === "=") {
                        smth.comparator = "IS";
                    }
                    if (smth.comparator === "!=") {
                        smth.comparator = "IS NOT";
                    }
                }
                return [
                    key,
                    value
                ].join(` ${smth.comparator} `);
            }
            if (_.isPlainObject(value)) {
                return this.whereItemQuery(smth.attribute, value, {
                    model: factory
                });
            }
            if ([
                this.OperatorMap[Op.between],
                this.OperatorMap[Op.notBetween]
            ].includes(smth.comparator)) {
                value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;
            } else if (typeof value === "boolean") {
                value = this.booleanValue(value);
            } else {
                value = this.escape(value);
            }
            if (value === "NULL") {
                if (smth.comparator === "=") {
                    smth.comparator = "IS";
                }
                if (smth.comparator === "!=") {
                    smth.comparator = "IS NOT";
                }
            }
            return [
                key,
                value
            ].join(` ${smth.comparator} `);
        }
        if (smth instanceof Utils.Literal) {
            return smth.val;
        }
        if (smth instanceof Utils.Cast) {
            if (smth.val instanceof Utils.SequelizeMethod) {
                result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
            } else if (_.isPlainObject(smth.val)) {
                result = this.whereItemsQuery(smth.val);
            } else {
                result = this.escape(smth.val);
            }
            return `CAST(${result} AS ${smth.type.toUpperCase()})`;
        }
        if (smth instanceof Utils.Fn) {
            return `${smth.fn}(${smth.args.map((arg)=>{
                if (arg instanceof Utils.SequelizeMethod) {
                    return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);
                }
                if (_.isPlainObject(arg)) {
                    return this.whereItemsQuery(arg);
                }
                return this.escape(typeof arg === "string" ? arg.replace(/\$/g, "$$$") : arg);
            }).join(", ")})`;
        }
        if (smth instanceof Utils.Col) {
            if (Array.isArray(smth.col) && !factory) {
                throw new Error("Cannot call Sequelize.col() with array outside of order / group clause");
            }
            if (smth.col.startsWith("*")) {
                return "*";
            }
            return this.quote(smth.col, factory);
        }
        return smth.toString(this, factory);
    }
    whereQuery(where, options) {
        const query = this.whereItemsQuery(where, options);
        if (query && query.length) {
            return `WHERE ${query}`;
        }
        return "";
    }
    whereItemsQuery(where, options, binding) {
        if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {
            return "";
        }
        if (typeof where === "string") {
            throw new Error("Support for `{where: 'raw query'}` has been removed.");
        }
        const items = [];
        binding = binding || "AND";
        if (binding[0] !== " ") binding = ` ${binding} `;
        if (_.isPlainObject(where)) {
            Utils.getComplexKeys(where).forEach((prop)=>{
                const item = where[prop];
                items.push(this.whereItemQuery(prop, item, options));
            });
        } else {
            items.push(this.whereItemQuery(void 0, where, options));
        }
        return items.length && items.filter((item)=>item && item.length).join(binding) || "";
    }
    whereItemQuery(key, value, options = {}) {
        if (value === void 0) {
            throw new Error(`WHERE parameter "${key}" has invalid "undefined" value`);
        }
        if (typeof key === "string" && key.includes(".") && options.model) {
            const keyParts = key.split(".");
            if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {
                const tmp = {};
                const field2 = options.model.rawAttributes[keyParts[0]];
                _.set(tmp, keyParts.slice(1), value);
                return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({
                    field: field2
                }, options));
            }
        }
        const field = this._findField(key, options);
        const fieldType = field && field.type || options.type;
        const isPlainObject = _.isPlainObject(value);
        const isArray = !isPlainObject && Array.isArray(value);
        key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;
        if (isPlainObject) {
            value = this._replaceAliases(value);
        }
        const valueKeys = isPlainObject && Utils.getComplexKeys(value);
        if (key === void 0) {
            if (typeof value === "string") {
                return value;
            }
            if (isPlainObject && valueKeys.length === 1) {
                return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);
            }
        }
        if (value === null) {
            const opValue2 = options.bindParam ? "NULL" : this.escape(value, field);
            return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);
        }
        if (!value) {
            const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
            return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);
        }
        if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {
            return this.handleSequelizeMethod(value);
        }
        if (key === void 0 && isArray) {
            if (Utils.canTreatArrayAsAnd(value)) {
                key = Op.and;
            } else {
                throw new Error("Support for literal replacements in the `where` object has been removed.");
            }
        }
        if (key === Op.or || key === Op.and || key === Op.not) {
            return this._whereGroupBind(key, value, options);
        }
        if (value[Op.or]) {
            return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);
        }
        if (value[Op.and]) {
            return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);
        }
        if (isArray && fieldType instanceof DataTypes.ARRAY) {
            const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
            return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);
        }
        if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {
            return this._whereJSON(key, value, options);
        }
        if (isPlainObject && valueKeys.length > 1) {
            return this._whereBind(this.OperatorMap[Op.and], key, value, options);
        }
        if (isArray) {
            return this._whereParseSingleValueObject(key, field, Op.in, value, options);
        }
        if (isPlainObject) {
            if (this.OperatorMap[valueKeys[0]]) {
                return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);
            }
            return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);
        }
        if (key === Op.placeholder) {
            const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
            return this._joinKeyValue(this.OperatorMap[key], opValue2, this.OperatorMap[Op.eq], options.prefix);
        }
        const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);
        return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);
    }
    _findField(key, options) {
        if (options.field) {
            return options.field;
        }
        if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {
            return options.model.rawAttributes[key];
        }
        if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {
            return options.model.fieldRawAttributesMap[key];
        }
    }
    _whereGroupBind(key, value, options) {
        const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];
        const outerBinding = key === Op.not ? "NOT " : "";
        if (Array.isArray(value)) {
            value = value.map((item)=>{
                let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);
                if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {
                    itemQuery = `(${itemQuery})`;
                }
                return itemQuery;
            }).filter((item)=>item && item.length);
            value = value.length && value.join(binding);
        } else {
            value = this.whereItemsQuery(value, options, binding);
        }
        if ((key === Op.or || key === Op.not) && !value) {
            return "0 = 1";
        }
        return value ? `${outerBinding}(${value})` : void 0;
    }
    _whereBind(binding, key, value, options) {
        if (_.isPlainObject(value)) {
            value = Utils.getComplexKeys(value).map((prop)=>{
                const item = value[prop];
                return this.whereItemQuery(key, {
                    [prop]: item
                }, options);
            });
        } else {
            value = value.map((item)=>this.whereItemQuery(key, item, options));
        }
        value = value.filter((item)=>item && item.length);
        return value.length ? `(${value.join(binding)})` : void 0;
    }
    _whereJSON(key, value, options) {
        const items = [];
        let baseKey = this.quoteIdentifier(key);
        if (options.prefix) {
            if (options.prefix instanceof Utils.Literal) {
                baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;
            } else {
                baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;
            }
        }
        Utils.getOperators(value).forEach((op)=>{
            const where = {
                [op]: value[op]
            };
            items.push(this.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), {
                json: false
            })));
        });
        _.forOwn(value, (item, prop)=>{
            this._traverseJSON(items, baseKey, prop, item, [
                prop
            ]);
        });
        const result = items.join(this.OperatorMap[Op.and]);
        return items.length > 1 ? `(${result})` : result;
    }
    _traverseJSON(items, baseKey, prop, item, path) {
        let cast;
        if (path[path.length - 1].includes("::")) {
            const tmp = path[path.length - 1].split("::");
            cast = tmp[1];
            path[path.length - 1] = tmp[0];
        }
        let pathKey = this.jsonPathExtractionQuery(baseKey, path);
        if (_.isPlainObject(item)) {
            Utils.getOperators(item).forEach((op)=>{
                const value = this._toJSONValue(item[op]);
                let isJson = false;
                if (typeof value === "string" && op === Op.contains) {
                    try {
                        JSON.stringify(value);
                        isJson = true;
                    } catch (e) {}
                }
                pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);
                items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), {
                    [op]: value
                }));
            });
            _.forOwn(item, (value, itemProp)=>{
                this._traverseJSON(items, baseKey, itemProp, value, path.concat([
                    itemProp
                ]));
            });
            return;
        }
        item = this._toJSONValue(item);
        items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), {
            [Op.eq]: item
        }));
    }
    _toJSONValue(value) {
        return value;
    }
    _castKey(key, value, cast, json) {
        cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);
        if (cast) {
            return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));
        }
        return new Utils.Literal(key);
    }
    _getJsonCast(value) {
        if (typeof value === "number") {
            return "double precision";
        }
        if (value instanceof Date) {
            return "timestamptz";
        }
        if (typeof value === "boolean") {
            return "boolean";
        }
        return;
    }
    _joinKeyValue(key, value, comparator, prefix) {
        if (!key) {
            return value;
        }
        if (comparator === void 0) {
            throw new Error(`${key} and ${value} has no comparator`);
        }
        key = this._getSafeKey(key, prefix);
        return [
            key,
            value
        ].join(` ${comparator} `);
    }
    _getSafeKey(key, prefix) {
        if (key instanceof Utils.SequelizeMethod) {
            key = this.handleSequelizeMethod(key);
            return this._prefixKey(this.handleSequelizeMethod(key), prefix);
        }
        if (Utils.isColString(key)) {
            key = key.substr(1, key.length - 2).split(".");
            if (key.length > 2) {
                key = [
                    key.slice(0, -1).join("->"),
                    key[key.length - 1]
                ];
            }
            return key.map((identifier)=>this.quoteIdentifier(identifier)).join(".");
        }
        return this._prefixKey(this.quoteIdentifier(key), prefix);
    }
    _prefixKey(key, prefix) {
        if (prefix) {
            if (prefix instanceof Utils.Literal) {
                return [
                    this.handleSequelizeMethod(prefix),
                    key
                ].join(".");
            }
            return [
                this.quoteTable(prefix),
                key
            ].join(".");
        }
        return key;
    }
    _whereParseSingleValueObject(key, field, prop, value, options) {
        if (prop === Op.not) {
            if (Array.isArray(value)) {
                prop = Op.notIn;
            } else if (value !== null && value !== true && value !== false) {
                prop = Op.ne;
            }
        }
        let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];
        switch(prop){
            case Op.in:
            case Op.notIn:
                if (value instanceof Utils.Literal) {
                    return this._joinKeyValue(key, value.val, comparator, options.prefix);
                }
                if (value.length) {
                    return this._joinKeyValue(key, `(${value.map((item)=>this.escape(item, field)).join(", ")})`, comparator, options.prefix);
                }
                if (comparator === this.OperatorMap[Op.in]) {
                    return this._joinKeyValue(key, "(NULL)", comparator, options.prefix);
                }
                return "";
            case Op.any:
            case Op.all:
                comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;
                if (value[Op.values]) {
                    return this._joinKeyValue(key, `(VALUES ${value[Op.values].map((item)=>`(${this.escape(item)})`).join(", ")})`, comparator, options.prefix);
                }
                return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);
            case Op.between:
            case Op.notBetween:
                return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);
            case Op.raw:
                throw new Error("The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.");
            case Op.col:
                comparator = this.OperatorMap[Op.eq];
                value = value.split(".");
                if (value.length > 2) {
                    value = [
                        value.slice(0, -1).join("->"),
                        value[value.length - 1]
                    ];
                }
                return this._joinKeyValue(key, value.map((identifier)=>this.quoteIdentifier(identifier)).join("."), comparator, options.prefix);
            case Op.startsWith:
            case Op.endsWith:
            case Op.substring:
                comparator = this.OperatorMap[Op.like];
                if (value instanceof Utils.Literal) {
                    value = value.val;
                }
                let pattern = `${value}%`;
                if (prop === Op.endsWith) pattern = `%${value}`;
                if (prop === Op.substring) pattern = `%${value}%`;
                return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);
        }
        const escapeOptions = {
            acceptStrings: comparator.includes(this.OperatorMap[Op.like])
        };
        if (_.isPlainObject(value)) {
            if (value[Op.col]) {
                return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);
            }
            if (value[Op.any]) {
                escapeOptions.isList = true;
                return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);
            }
            if (value[Op.all]) {
                escapeOptions.isList = true;
                return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);
            }
        }
        if (value === null && comparator === this.OperatorMap[Op.eq]) {
            return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);
        }
        if (value === null && comparator === this.OperatorMap[Op.ne]) {
            return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);
        }
        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);
    }
    getWhereConditions(smth, tableName, factory, options, prepend) {
        const where = {};
        if (Array.isArray(tableName)) {
            tableName = tableName[0];
            if (Array.isArray(tableName)) {
                tableName = tableName[1];
            }
        }
        options = options || {};
        if (prepend === void 0) {
            prepend = true;
        }
        if (smth && smth instanceof Utils.SequelizeMethod) {
            return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);
        }
        if (_.isPlainObject(smth)) {
            return this.whereItemsQuery(smth, {
                model: factory,
                prefix: prepend && tableName,
                type: options.type
            });
        }
        if (typeof smth === "number" || typeof smth === "bigint") {
            let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];
            if (primaryKeys.length > 0) {
                primaryKeys = primaryKeys[0];
            } else {
                primaryKeys = "id";
            }
            where[primaryKeys] = smth;
            return this.whereItemsQuery(where, {
                model: factory,
                prefix: prepend && tableName
            });
        }
        if (typeof smth === "string") {
            return this.whereItemsQuery(smth, {
                model: factory,
                prefix: prepend && tableName
            });
        }
        if (Buffer.isBuffer(smth)) {
            return this.escape(smth);
        }
        if (Array.isArray(smth)) {
            if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return "1=1";
            if (Utils.canTreatArrayAsAnd(smth)) {
                const _smth = {
                    [Op.and]: smth
                };
                return this.getWhereConditions(_smth, tableName, factory, options, prepend);
            }
            throw new Error("Support for literal replacements in the `where` object has been removed.");
        }
        if (smth == null) {
            return this.whereItemsQuery(smth, {
                model: factory,
                prefix: prepend && tableName
            });
        }
        throw new Error(`Unsupported where option value: ${util.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);
    }
    parseConditionObject(conditions, path) {
        path = path || [];
        return _.reduce(conditions, (result, value, key)=>{
            if (_.isObject(value)) {
                return result.concat(this.parseConditionObject(value, path.concat(key)));
            }
            result.push({
                path: path.concat(key),
                value
            });
            return result;
        }, []);
    }
    booleanValue(value) {
        return value;
    }
    authTestQuery() {
        return "SELECT 1+1 AS result";
    }
}
Object.assign(QueryGenerator.prototype, __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js [app-route] (ecmascript)"));
Object.assign(QueryGenerator.prototype, __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js [app-route] (ecmascript)"));
module.exports = QueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
const FOREIGN_KEY_FIELDS = [
    "CONSTRAINT_NAME as constraint_name",
    "CONSTRAINT_NAME as constraintName",
    "CONSTRAINT_SCHEMA as constraintSchema",
    "CONSTRAINT_SCHEMA as constraintCatalog",
    "TABLE_NAME as tableName",
    "TABLE_SCHEMA as tableSchema",
    "TABLE_SCHEMA as tableCatalog",
    "COLUMN_NAME as columnName",
    "REFERENCED_TABLE_SCHEMA as referencedTableSchema",
    "REFERENCED_TABLE_SCHEMA as referencedTableCatalog",
    "REFERENCED_TABLE_NAME as referencedTableName",
    "REFERENCED_COLUMN_NAME as referencedColumnName"
].join(",");
const typeWithoutDefault = /* @__PURE__ */ new Set([
    "BLOB",
    "TEXT",
    "GEOMETRY",
    "JSON"
]);
class MySQLQueryGenerator extends AbstractQueryGenerator {
    constructor(options){
        super(options);
        this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {
            [Op.regexp]: "REGEXP",
            [Op.notRegexp]: "NOT REGEXP"
        });
    }
    createDatabaseQuery(databaseName, options) {
        options = __spreadValues({
            charset: null,
            collate: null
        }, options);
        return Utils.joinSQLFragments([
            "CREATE DATABASE IF NOT EXISTS",
            this.quoteIdentifier(databaseName),
            options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
            options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
            ";"
        ]);
    }
    dropDatabaseQuery(databaseName) {
        return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;
    }
    createSchema() {
        return "SHOW TABLES";
    }
    showSchemasQuery() {
        return "SHOW TABLES";
    }
    versionQuery() {
        return "SELECT VERSION() as `version`";
    }
    createTableQuery(tableName, attributes, options) {
        options = __spreadValues({
            engine: "InnoDB",
            charset: null,
            rowFormat: null
        }, options);
        const primaryKeys = [];
        const foreignKeys = {};
        const attrStr = [];
        for(const attr in attributes){
            if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
            const dataType = attributes[attr];
            let match;
            if (dataType.includes("PRIMARY KEY")) {
                primaryKeys.push(attr);
                if (dataType.includes("REFERENCES")) {
                    match = dataType.match(/^(.+) (REFERENCES.*)$/);
                    attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace("PRIMARY KEY", "")}`);
                    foreignKeys[attr] = match[2];
                } else {
                    attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
                }
            } else if (dataType.includes("REFERENCES")) {
                match = dataType.match(/^(.+) (REFERENCES.*)$/);
                attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
                foreignKeys[attr] = match[2];
            } else {
                attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
            }
        }
        const table = this.quoteTable(tableName);
        let attributesClause = attrStr.join(", ");
        const pkString = primaryKeys.map((pk)=>this.quoteIdentifier(pk)).join(", ");
        if (options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns, indexName)=>{
                if (columns.customIndex) {
                    if (typeof indexName !== "string") {
                        indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
                    }
                    attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                }
            });
        }
        if (pkString.length > 0) {
            attributesClause += `, PRIMARY KEY (${pkString})`;
        }
        for(const fkey in foreignKeys){
            if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
                attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
            }
        }
        return Utils.joinSQLFragments([
            "CREATE TABLE IF NOT EXISTS",
            table,
            `(${attributesClause})`,
            `ENGINE=${options.engine}`,
            options.comment && typeof options.comment === "string" && `COMMENT ${this.escape(options.comment)}`,
            options.charset && `DEFAULT CHARSET=${options.charset}`,
            options.collate && `COLLATE ${options.collate}`,
            options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,
            options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,
            ";"
        ]);
    }
    describeTableQuery(tableName, schema, schemaDelimiter) {
        const table = this.quoteTable(this.addSchema({
            tableName,
            _schema: schema,
            _schemaDelimiter: schemaDelimiter
        }));
        return `SHOW FULL COLUMNS FROM ${table};`;
    }
    showTablesQuery(database) {
        let query = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";
        if (database) {
            query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
        } else {
            query += " AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')";
        }
        return `${query};`;
    }
    tableExistsQuery(table) {
        const tableName = this.escape(this.quoteTable(table).slice(1, -1));
        return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;
    }
    addColumnQuery(table, key, dataType) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(table),
            "ADD",
            this.quoteIdentifier(key),
            this.attributeToSQL(dataType, {
                context: "addColumn",
                tableName: table,
                foreignKey: key
            }),
            ";"
        ]);
    }
    removeColumnQuery(tableName, attributeName) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP",
            this.quoteIdentifier(attributeName),
            ";"
        ]);
    }
    changeColumnQuery(tableName, attributes) {
        const attrString = [];
        const constraintString = [];
        for(const attributeName in attributes){
            let definition = attributes[attributeName];
            if (definition.includes("REFERENCES")) {
                const attrName = this.quoteIdentifier(attributeName);
                definition = definition.replace(/.+?(?=REFERENCES)/, "");
                constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);
            } else {
                attrString.push(`\`${attributeName}\` \`${attributeName}\` ${definition}`);
            }
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            attrString.length && `CHANGE ${attrString.join(", ")}`,
            constraintString.length && `ADD ${constraintString.join(", ")}`,
            ";"
        ]);
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const attrString = [];
        for(const attrName in attributes){
            const definition = attributes[attrName];
            attrString.push(`\`${attrBefore}\` \`${attrName}\` ${definition}`);
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "CHANGE",
            attrString.join(", "),
            ";"
        ]);
    }
    handleSequelizeMethod(smth, tableName, factory, options, prepend) {
        if (smth instanceof Utils.Json) {
            if (smth.conditions) {
                const conditions = this.parseConditionObject(smth.conditions).map((condition)=>`${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);
                return conditions.join(" AND ");
            }
            if (smth.path) {
                let str;
                if (this._checkValidJsonStatement(smth.path)) {
                    str = smth.path;
                } else {
                    const paths = _.toPath(smth.path);
                    const column = paths.shift();
                    str = this.jsonPathExtractionQuery(column, paths);
                }
                if (smth.value) {
                    str += util.format(" = %s", this.escape(smth.value));
                }
                return str;
            }
        } else if (smth instanceof Utils.Cast) {
            if (/timestamp/i.test(smth.type)) {
                smth.type = "datetime";
            } else if (smth.json && /boolean/i.test(smth.type)) {
                smth.type = "char";
            } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {
                smth.type = "decimal";
            } else if (/text/i.test(smth.type)) {
                smth.type = "char";
            }
        }
        return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }
    _toJSONValue(value) {
        if (typeof value === "boolean") {
            return value.toString();
        }
        if (value === null) {
            return "null";
        }
        return value;
    }
    truncateTableQuery(tableName) {
        return `TRUNCATE ${this.quoteTable(tableName)}`;
    }
    deleteQuery(tableName, where, options = {}, model) {
        let limit = "";
        let query = `DELETE FROM ${this.quoteTable(tableName)}`;
        if (options.limit) {
            limit = ` LIMIT ${this.escape(options.limit)}`;
        }
        where = this.getWhereConditions(where, null, model, options);
        if (where) {
            query += ` WHERE ${where}`;
        }
        return query + limit;
    }
    showIndexesQuery(tableName, options) {
        return Utils.joinSQLFragments([
            `SHOW INDEX FROM ${this.quoteTable(tableName)}`,
            options && options.database && `FROM \`${options.database}\``
        ]);
    }
    showConstraintsQuery(table, constraintName) {
        const tableName = table.tableName || table;
        const schemaName = table.schema;
        return Utils.joinSQLFragments([
            "SELECT CONSTRAINT_CATALOG AS constraintCatalog,",
            "CONSTRAINT_NAME AS constraintName,",
            "CONSTRAINT_SCHEMA AS constraintSchema,",
            "CONSTRAINT_TYPE AS constraintType,",
            "TABLE_NAME AS tableName,",
            "TABLE_SCHEMA AS tableSchema",
            "from INFORMATION_SCHEMA.TABLE_CONSTRAINTS",
            `WHERE table_name='${tableName}'`,
            constraintName && `AND constraint_name = '${constraintName}'`,
            schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,
            ";"
        ]);
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return Utils.joinSQLFragments([
            "DROP INDEX",
            this.quoteIdentifier(indexName),
            "ON",
            this.quoteTable(tableName)
        ]);
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        const attributeString = attribute.type.toString({
            escape: this.escape.bind(this)
        });
        let template = attributeString;
        if (attribute.allowNull === false) {
            template += " NOT NULL";
        }
        if (attribute.autoIncrement) {
            template += " auto_increment";
        }
        if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
        }
        if (attribute.unique === true) {
            template += " UNIQUE";
        }
        if (attribute.primaryKey) {
            template += " PRIMARY KEY";
        }
        if (attribute.comment) {
            template += ` COMMENT ${this.escape(attribute.comment)}`;
        }
        if (attribute.first) {
            template += " FIRST";
        }
        if (attribute.after) {
            template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
        }
        if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
            if (options && options.context === "addColumn" && options.foreignKey) {
                const attrName = this.quoteIdentifier(options.foreignKey);
                const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);
                template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
            }
            template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
            if (attribute.references.key) {
                template += ` (${this.quoteIdentifier(attribute.references.key)})`;
            } else {
                template += ` (${this.quoteIdentifier("id")})`;
            }
            if (attribute.onDelete) {
                template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
            }
            if (attribute.onUpdate) {
                template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
            }
        }
        return template;
    }
    attributesToSQL(attributes, options) {
        const result = {};
        for(const key in attributes){
            const attribute = attributes[key];
            result[attribute.field || key] = this.attributeToSQL(attribute, options);
        }
        return result;
    }
    _checkValidJsonStatement(stmt) {
        if (typeof stmt !== "string") {
            return false;
        }
        let currentIndex = 0;
        let openingBrackets = 0;
        let closingBrackets = 0;
        let hasJsonFunction = false;
        let hasInvalidToken = false;
        while(currentIndex < stmt.length){
            const string = stmt.substr(currentIndex);
            const functionMatches = JSON_FUNCTION_REGEX.exec(string);
            if (functionMatches) {
                currentIndex += functionMatches[0].indexOf("(");
                hasJsonFunction = true;
                continue;
            }
            const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
            if (operatorMatches) {
                currentIndex += operatorMatches[0].length;
                hasJsonFunction = true;
                continue;
            }
            const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
            if (tokenMatches) {
                const capturedToken = tokenMatches[1];
                if (capturedToken === "(") {
                    openingBrackets++;
                } else if (capturedToken === ")") {
                    closingBrackets++;
                } else if (capturedToken === ";") {
                    hasInvalidToken = true;
                    break;
                }
                currentIndex += tokenMatches[0].length;
                continue;
            }
            break;
        }
        if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
            throw new Error(`Invalid json statement: ${stmt}`);
        }
        return hasJsonFunction;
    }
    getForeignKeysQuery(table, schemaName) {
        const tableName = table.tableName || table;
        return Utils.joinSQLFragments([
            "SELECT",
            FOREIGN_KEY_FIELDS,
            `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,
            `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,
            "AND REFERENCED_TABLE_NAME IS NOT NULL",
            ";"
        ]);
    }
    getForeignKeyQuery(table, columnName) {
        const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : "";
        const quotedTableName = wrapSingleQuote(table.tableName || table);
        const quotedColumnName = wrapSingleQuote(columnName);
        return Utils.joinSQLFragments([
            "SELECT",
            FOREIGN_KEY_FIELDS,
            "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE",
            "WHERE (",
            [
                `REFERENCED_TABLE_NAME = ${quotedTableName}`,
                table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,
                `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`
            ],
            ") OR (",
            [
                `TABLE_NAME = ${quotedTableName}`,
                table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,
                `AND COLUMN_NAME = ${quotedColumnName}`,
                "AND REFERENCED_TABLE_NAME IS NOT NULL"
            ],
            ")"
        ]);
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP FOREIGN KEY",
            this.quoteIdentifier(foreignKey),
            ";"
        ]);
    }
    quoteIdentifier(identifier, force) {
        return Utils.addTicks(Utils.removeTicks(identifier, "`"), "`");
    }
}
function wrapSingleQuote(identifier) {
    return Utils.addTicks(identifier, "'");
}
module.exports = MySQLQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mariadb/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const MySQLQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query-generator.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
class MariaDBQueryGenerator extends MySQLQueryGenerator {
    createSchema(schema, options) {
        options = __spreadValues({
            charset: null,
            collate: null
        }, options);
        return Utils.joinSQLFragments([
            "CREATE SCHEMA IF NOT EXISTS",
            this.quoteIdentifier(schema),
            options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
            options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
            ";"
        ]);
    }
    dropSchema(schema) {
        return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;
    }
    showSchemasQuery(options) {
        const schemasToSkip = [
            "'MYSQL'",
            "'INFORMATION_SCHEMA'",
            "'PERFORMANCE_SCHEMA'"
        ];
        if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {
            for (const schemaName of options.skip){
                schemasToSkip.push(this.escape(schemaName));
            }
        }
        return Utils.joinSQLFragments([
            "SELECT SCHEMA_NAME as schema_name",
            "FROM INFORMATION_SCHEMA.SCHEMATA",
            `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(", ")})`,
            ";"
        ]);
    }
    showTablesQuery(database) {
        let query = "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";
        if (database) {
            query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;
        } else {
            query += " AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA')";
        }
        return `${query};`;
    }
    quoteIdentifier(identifier, force) {
        return Utils.addTicks(Utils.removeTicks(identifier, "`"), "`");
    }
}
module.exports = MariaDBQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
class MySQLQueryInterface extends QueryInterface {
    async removeColumn(tableName, columnName, options) {
        options = options || {};
        const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {
            tableName,
            schema: this.sequelize.config.database
        }, columnName), __spreadValues({
            raw: true
        }, options));
        if (results.length && results[0].constraint_name !== "PRIMARY") {
            await Promise.all(results.map((constraint)=>this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({
                    raw: true
                }, options))));
        }
        return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({
            raw: true
        }, options));
    }
    async upsert(tableName, insertValues, updateValues, where, options) {
        options = __spreadValues({}, options);
        options.type = QueryTypes.UPSERT;
        options.updateOnDuplicate = Object.keys(updateValues);
        options.upsertKeys = Object.values(options.model.primaryKeys).map((item)=>item.field);
        const model = options.model;
        const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
        return await this.sequelize.query(sql, options);
    }
    async removeConstraint(tableName, constraintName, options) {
        const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {
            tableName,
            schema: this.sequelize.config.database
        }, constraintName);
        const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            type: this.sequelize.QueryTypes.SHOWCONSTRAINTS
        }));
        const constraint = constraints[0];
        let query;
        if (!constraint || !constraint.constraintType) {
            throw new sequelizeErrors.UnknownConstraintError({
                message: `Constraint ${constraintName} on table ${tableName} does not exist`,
                constraint: constraintName,
                table: tableName
            });
        }
        if (constraint.constraintType === "FOREIGN KEY") {
            query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);
        } else {
            query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);
        }
        return await this.sequelize.query(query, options);
    }
}
exports.MySQLQueryInterface = MySQLQueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mariadb/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mariadb/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mariadb/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mariadb/query-generator.js [app-route] (ecmascript)");
const { MySQLQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query-interface.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mariadb;
class MariadbDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
    }
    canBackslashEscape() {
        return true;
    }
}
MariadbDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "VALUES ()": true,
    "LIMIT ON UPDATE": true,
    lock: true,
    forShare: "LOCK IN SHARE MODE",
    settingIsolationLevelDuringTransaction: false,
    schemas: true,
    inserts: {
        ignoreDuplicates: " IGNORE",
        updateOnDuplicate: " ON DUPLICATE KEY UPDATE"
    },
    index: {
        collate: false,
        length: true,
        parser: true,
        type: true,
        using: 1
    },
    constraints: {
        dropConstraint: false,
        check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: true,
    JSON: true,
    REGEXP: true
});
MariadbDialect.prototype.defaultVersion = "10.1.44";
MariadbDialect.prototype.Query = Query;
MariadbDialect.prototype.QueryGenerator = QueryGenerator;
MariadbDialect.prototype.DataTypes = DataTypes;
MariadbDialect.prototype.name = "mariadb";
MariadbDialect.prototype.TICK_CHAR = "`";
MariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;
MariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;
module.exports = MariadbDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const AsyncQueue = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/async-queue.js [app-route] (ecmascript)").default;
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mssql;
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("mssql");
const debug = logger.debugContext("connection:mssql");
const debugTedious = logger.debugContext("connection:mssql:tedious");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 1433;
        super(dialect, sequelize);
        this.lib = this._loadDialectModule("tedious");
        this.refreshTypeParser(DataTypes);
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    async connect(config) {
        const connectionConfig = {
            server: config.host,
            authentication: {
                type: "default",
                options: {
                    userName: config.username || void 0,
                    password: config.password || void 0
                }
            },
            options: {
                port: parseInt(config.port, 10),
                database: config.database,
                trustServerCertificate: true
            }
        };
        if (config.dialectOptions) {
            if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {
                delete connectionConfig.options.port;
            }
            if (config.dialectOptions.authentication) {
                Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);
            }
            Object.assign(connectionConfig.options, config.dialectOptions.options);
        }
        try {
            return await new Promise((resolve, reject)=>{
                const connection = new this.lib.Connection(connectionConfig);
                if (connection.state === connection.STATE.INITIALIZED) {
                    connection.connect();
                }
                connection.queue = new AsyncQueue();
                connection.lib = this.lib;
                const connectHandler = (error)=>{
                    connection.removeListener("end", endHandler);
                    connection.removeListener("error", errorHandler);
                    if (error) return reject(error);
                    debug("connection acquired");
                    resolve(connection);
                };
                const endHandler = ()=>{
                    connection.removeListener("connect", connectHandler);
                    connection.removeListener("error", errorHandler);
                    reject(new Error("Connection was closed by remote server"));
                };
                const errorHandler = (error)=>{
                    connection.removeListener("connect", connectHandler);
                    connection.removeListener("end", endHandler);
                    reject(error);
                };
                connection.once("error", errorHandler);
                connection.once("end", endHandler);
                connection.once("connect", connectHandler);
                connection.on("error", (error)=>{
                    switch(error.code){
                        case "ESOCKET":
                        case "ECONNRESET":
                            this.pool.destroy(connection);
                    }
                });
                if (config.dialectOptions && config.dialectOptions.debug) {
                    connection.on("debug", debugTedious.log.bind(debugTedious));
                }
            });
        } catch (error) {
            if (!error.code) {
                throw new sequelizeErrors.ConnectionError(error);
            }
            switch(error.code){
                case "ESOCKET":
                    if (error.message.includes("connect EHOSTUNREACH")) {
                        throw new sequelizeErrors.HostNotReachableError(error);
                    }
                    if (error.message.includes("connect ENETUNREACH")) {
                        throw new sequelizeErrors.HostNotReachableError(error);
                    }
                    if (error.message.includes("connect EADDRNOTAVAIL")) {
                        throw new sequelizeErrors.HostNotReachableError(error);
                    }
                    if (error.message.includes("connect EAFNOSUPPORT")) {
                        throw new sequelizeErrors.HostNotReachableError(error);
                    }
                    if (error.message.includes("getaddrinfo ENOTFOUND")) {
                        throw new sequelizeErrors.HostNotFoundError(error);
                    }
                    if (error.message.includes("connect ECONNREFUSED")) {
                        throw new sequelizeErrors.ConnectionRefusedError(error);
                    }
                    throw new sequelizeErrors.ConnectionError(error);
                case "ER_ACCESS_DENIED_ERROR":
                case "ELOGIN":
                    throw new sequelizeErrors.AccessDeniedError(error);
                case "EINVAL":
                    throw new sequelizeErrors.InvalidConnectionError(error);
                default:
                    throw new sequelizeErrors.ConnectionError(error);
            }
        }
    }
    async disconnect(connection) {
        if (connection.closed) {
            return;
        }
        connection.queue.close();
        return new Promise((resolve)=>{
            connection.on("end", resolve);
            connection.close();
            debug("connection closed");
        });
    }
    validate(connection) {
        return connection && (connection.loggedIn || connection.state.name === "LoggedIn");
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("mssql");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("sql:mssql");
const minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);
const maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);
function getScale(aNum) {
    if (!Number.isFinite(aNum)) return 0;
    let e = 1;
    while(Math.round(aNum * e) / e !== aNum)e *= 10;
    return Math.log10(e);
}
class Query extends AbstractQuery {
    getInsertIdField() {
        return "id";
    }
    getSQLTypeFromJsType(value, TYPES) {
        const paramType = {
            type: TYPES.NVarChar,
            typeOptions: {},
            value
        };
        if (typeof value === "number") {
            if (Number.isInteger(value)) {
                if (value >= -2147483648 && value <= 2147483647) {
                    paramType.type = TYPES.Int;
                } else {
                    paramType.type = TYPES.BigInt;
                }
            } else {
                paramType.type = TYPES.Numeric;
                paramType.typeOptions = {
                    precision: 30,
                    scale: getScale(value)
                };
            }
        } else if (typeof value === "bigint") {
            if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {
                paramType.type = TYPES.VarChar;
                paramType.value = value.toString();
            } else {
                return this.getSQLTypeFromJsType(Number(value), TYPES);
            }
        } else if (typeof value === "boolean") {
            paramType.type = TYPES.Bit;
        }
        if (Buffer.isBuffer(value)) {
            paramType.type = TYPES.VarBinary;
        }
        return paramType;
    }
    async _run(connection, sql, parameters, errStack) {
        this.sql = sql;
        const { options } = this;
        const complete = this._logQuery(sql, debug, parameters);
        const query = new Promise((resolve, reject)=>{
            if (sql.startsWith("BEGIN TRANSACTION")) {
                return connection.beginTransaction((error)=>error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);
            }
            if (sql.startsWith("COMMIT TRANSACTION")) {
                return connection.commitTransaction((error)=>error ? reject(error) : resolve([]));
            }
            if (sql.startsWith("ROLLBACK TRANSACTION")) {
                return connection.rollbackTransaction((error)=>error ? reject(error) : resolve([]), options.transaction.name);
            }
            if (sql.startsWith("SAVE TRANSACTION")) {
                return connection.saveTransaction((error)=>error ? reject(error) : resolve([]), options.transaction.name);
            }
            const rows2 = [];
            const request = new connection.lib.Request(sql, (err, rowCount2)=>err ? reject(err) : resolve([
                    rows2,
                    rowCount2
                ]));
            if (parameters) {
                _.forOwn(parameters, (value, key)=>{
                    const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);
                    request.addParameter(key, paramType.type, value, paramType.typeOptions);
                });
            }
            request.on("row", (columns)=>{
                rows2.push(columns);
            });
            connection.execSql(request);
        });
        let rows, rowCount;
        try {
            [rows, rowCount] = await query;
        } catch (err) {
            err.sql = sql;
            err.parameters = parameters;
            throw this.formatError(err, errStack);
        }
        complete();
        if (Array.isArray(rows)) {
            rows = rows.map((columns)=>{
                const row = {};
                for (const column of columns){
                    const typeid = column.metadata.type.id;
                    const parse = parserStore.get(typeid);
                    let value = column.value;
                    if (value !== null & !!parse) {
                        value = parse(value);
                    }
                    row[column.metadata.colName] = value;
                }
                return row;
            });
        }
        return this.formatResults(rows, rowCount);
    }
    run(sql, parameters) {
        const errForStack = new Error();
        return this.connection.queue.enqueue(()=>this._run(this.connection, sql, parameters, errForStack.stack));
    }
    static formatBindParameters(sql, values, dialect) {
        const bindParam = {};
        const replacementFunc = (match, key, values2)=>{
            if (values2[key] !== void 0) {
                bindParam[key] = values2[key];
                return `@${key}`;
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        return [
            sql,
            bindParam
        ];
    }
    formatResults(data, rowCount) {
        if (this.isInsertQuery(data)) {
            this.handleInsertQuery(data);
            return [
                this.instance || data,
                rowCount
            ];
        }
        if (this.isShowTablesQuery()) {
            return this.handleShowTablesQuery(data);
        }
        if (this.isDescribeQuery()) {
            const result = {};
            for (const _result of data){
                if (_result.Default) {
                    _result.Default = _result.Default.replace("('", "").replace("')", "").replace(/'/g, "");
                }
                result[_result.Name] = {
                    type: _result.Type.toUpperCase(),
                    allowNull: _result.IsNull === "YES" ? true : false,
                    defaultValue: _result.Default,
                    primaryKey: _result.Constraint === "PRIMARY KEY",
                    autoIncrement: _result.IsIdentity === 1,
                    comment: _result.Comment
                };
                if (result[_result.Name].type.includes("CHAR") && _result.Length) {
                    if (_result.Length === -1) {
                        result[_result.Name].type += "(MAX)";
                    } else {
                        result[_result.Name].type += `(${_result.Length})`;
                    }
                }
            }
            return result;
        }
        if (this.isSelectQuery()) {
            return this.handleSelectQuery(data);
        }
        if (this.isShowIndexesQuery()) {
            return this.handleShowIndexesQuery(data);
        }
        if (this.isCallQuery()) {
            return data[0];
        }
        if (this.isBulkUpdateQuery()) {
            if (this.options.returning) {
                return this.handleSelectQuery(data);
            }
            return rowCount;
        }
        if (this.isBulkDeleteQuery()) {
            return data[0] ? data[0].AFFECTEDROWS : 0;
        }
        if (this.isVersionQuery()) {
            return data[0].version;
        }
        if (this.isForeignKeysQuery()) {
            return data;
        }
        if (this.isUpsertQuery()) {
            if (data && data.length === 0) {
                return [
                    this.instance || data,
                    false
                ];
            }
            this.handleInsertQuery(data);
            return [
                this.instance || data,
                data[0].$action === "INSERT"
            ];
        }
        if (this.isUpdateQuery()) {
            return [
                this.instance || data,
                rowCount
            ];
        }
        if (this.isShowConstraintsQuery()) {
            return this.handleShowConstraintsQuery(data);
        }
        if (this.isRawQuery()) {
            return [
                data,
                rowCount
            ];
        }
        return data;
    }
    handleShowTablesQuery(results) {
        return results.map((resultSet)=>{
            return {
                tableName: resultSet.TABLE_NAME,
                schema: resultSet.TABLE_SCHEMA
            };
        });
    }
    handleShowConstraintsQuery(data) {
        return data.slice(1).map((result)=>{
            const constraint = {};
            for(const key in result){
                constraint[_.camelCase(key)] = result[key];
            }
            return constraint;
        });
    }
    formatError(err, errStack) {
        let match;
        match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \((.*)\).)?/);
        match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);
        if (match && match.length > 1) {
            let fields = {};
            const uniqueKey = this.model && this.model.uniqueKeys[match[1]];
            let message = "Validation error";
            if (uniqueKey && !!uniqueKey.msg) {
                message = uniqueKey.msg;
            }
            if (match[3]) {
                const values = match[3].split(",").map((part)=>part.trim());
                if (uniqueKey) {
                    fields = _.zipObject(uniqueKey.fields, values);
                } else {
                    fields[match[1]] = match[3];
                }
            }
            const errors = [];
            _.forOwn(fields, (value, field)=>{
                errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
            });
            return new sequelizeErrors.UniqueConstraintError({
                message,
                errors,
                parent: err,
                fields,
                stack: errStack
            });
        }
        match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint "(.*)". The conflict occurred in database "(.*)", table "(.*)", column '(.*)'./);
        if (match && match.length > 0) {
            return new sequelizeErrors.ForeignKeyConstraintError({
                fields: null,
                index: match[1],
                parent: err,
                stack: errStack
            });
        }
        match = err.message.match(/Could not drop constraint. See previous errors./);
        if (match && match.length > 0) {
            let constraint = err.sql.match(/(?:constraint|index) \[(.+?)\]/i);
            constraint = constraint ? constraint[1] : void 0;
            let table = err.sql.match(/table \[(.+?)\]/i);
            table = table ? table[1] : void 0;
            return new sequelizeErrors.UnknownConstraintError({
                message: match[1],
                constraint,
                table,
                parent: err,
                stack: errStack
            });
        }
        return new sequelizeErrors.DatabaseError(err, {
            stack: errStack
        });
    }
    isShowOrDescribeQuery() {
        let result = false;
        result = result || this.sql.toLowerCase().startsWith("select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'");
        result = result || this.sql.toLowerCase().startsWith("select tablename = t.name, name = ind.name,");
        result = result || this.sql.toLowerCase().startsWith("exec sys.sp_helpindex @objname");
        return result;
    }
    isShowIndexesQuery() {
        return this.sql.toLowerCase().startsWith("exec sys.sp_helpindex @objname");
    }
    handleShowIndexesQuery(data) {
        data = data.reduce((acc, item)=>{
            if (!(item.index_name in acc)) {
                acc[item.index_name] = item;
                item.fields = [];
            }
            item.index_keys.split(",").forEach((column)=>{
                let columnName = column.trim();
                if (columnName.includes("(-)")) {
                    columnName = columnName.replace("(-)", "");
                }
                acc[item.index_name].fields.push({
                    attribute: columnName,
                    length: void 0,
                    order: column.includes("(-)") ? "DESC" : "ASC",
                    collate: void 0
                });
            });
            delete item.index_keys;
            return acc;
        }, {});
        return _.map(data, (item)=>({
                primary: item.index_name.toLowerCase().startsWith("pk"),
                fields: item.fields,
                name: item.index_name,
                tableName: void 0,
                unique: item.index_description.toLowerCase().includes("unique"),
                type: void 0
            }));
    }
    handleInsertQuery(results, metaData) {
        if (this.instance) {
            const autoIncrementAttribute = this.model.autoIncrementAttribute;
            let id = null;
            let autoIncrementAttributeAlias = null;
            if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0) autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;
            id = id || results && results[0][this.getInsertIdField()];
            id = id || metaData && metaData[this.getInsertIdField()];
            id = id || results && results[0][autoIncrementAttribute];
            id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];
            this.instance[autoIncrementAttribute] = id;
            if (this.instance.dataValues) {
                for(const key in results[0]){
                    if (Object.prototype.hasOwnProperty.call(results[0], key)) {
                        const record = results[0][key];
                        const attr = _.find(this.model.rawAttributes, (attribute)=>attribute.fieldName === key || attribute.field === key);
                        this.instance.dataValues[attr && attr.fieldName || key] = record;
                    }
                }
            }
        }
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const TableHints = __turbopack_context__.r("[project]/node_modules/sequelize/lib/table-hints.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const randomBytes = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)").randomBytes;
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const throwMethodUndefined = function(methodName) {
    throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};
class MSSQLQueryGenerator extends AbstractQueryGenerator {
    createDatabaseQuery(databaseName, options) {
        options = __spreadValues({
            collate: null
        }, options);
        const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : "";
        return [
            "IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =",
            wrapSingleQuote(databaseName),
            ")",
            "BEGIN",
            "CREATE DATABASE",
            this.quoteIdentifier(databaseName),
            `${collation};`,
            "END;"
        ].join(" ");
    }
    dropDatabaseQuery(databaseName) {
        return [
            "IF EXISTS (SELECT * FROM sys.databases WHERE name =",
            wrapSingleQuote(databaseName),
            ")",
            "BEGIN",
            "DROP DATABASE",
            this.quoteIdentifier(databaseName),
            ";",
            "END;"
        ].join(" ");
    }
    createSchema(schema) {
        return [
            "IF NOT EXISTS (SELECT schema_name",
            "FROM information_schema.schemata",
            "WHERE schema_name =",
            wrapSingleQuote(schema),
            ")",
            "BEGIN",
            "EXEC sp_executesql N'CREATE SCHEMA",
            this.quoteIdentifier(schema),
            ";'",
            "END;"
        ].join(" ");
    }
    dropSchema(schema) {
        const quotedSchema = wrapSingleQuote(schema);
        return [
            "IF EXISTS (SELECT schema_name",
            "FROM information_schema.schemata",
            "WHERE schema_name =",
            quotedSchema,
            ")",
            "BEGIN",
            "DECLARE @id INT, @ms_sql NVARCHAR(2000);",
            "DECLARE @cascade TABLE (",
            "id INT NOT NULL IDENTITY PRIMARY KEY,",
            "ms_sql NVARCHAR(2000) NOT NULL );",
            "INSERT INTO @cascade ( ms_sql )",
            "SELECT CASE WHEN o.type IN ('F','PK')",
            "THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'",
            "ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END",
            "FROM sys.objects o",
            "JOIN sys.schemas s on o.schema_id = s.schema_id",
            "LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id",
            "WHERE o.type IN ('F', 'PK', 'U') AND s.name = ",
            quotedSchema,
            "ORDER BY o.type ASC;",
            "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;",
            "WHILE @id IS NOT NULL",
            "BEGIN",
            "BEGIN TRY EXEC sp_executesql @ms_sql; END TRY",
            "BEGIN CATCH BREAK; THROW; END CATCH;",
            "DELETE FROM @cascade WHERE id = @id;",
            "SELECT @id = NULL, @ms_sql = NULL;",
            "SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;",
            "END",
            "EXEC sp_executesql N'DROP SCHEMA",
            this.quoteIdentifier(schema),
            ";'",
            "END;"
        ].join(" ");
    }
    showSchemasQuery() {
        return [
            'SELECT "name" as "schema_name" FROM sys.schemas as s',
            'WHERE "s"."name" NOT IN (',
            "'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'",
            ")",
            "AND",
            '"s"."name" NOT LIKE',
            "'db_%'"
        ].join(" ");
    }
    versionQuery() {
        return [
            "DECLARE @ms_ver NVARCHAR(20);",
            "SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));",
            "SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'"
        ].join(" ");
    }
    createTableQuery(tableName, attributes, options) {
        const primaryKeys = [], foreignKeys = {}, attributesClauseParts = [];
        let commentStr = "";
        for(const attr in attributes){
            if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
                let dataType = attributes[attr];
                let match;
                if (dataType.includes("COMMENT ")) {
                    const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
                    const commentText = commentMatch[2].replace("COMMENT", "").trim();
                    commentStr += this.commentTemplate(commentText, tableName, attr);
                    dataType = commentMatch[1];
                }
                if (dataType.includes("PRIMARY KEY")) {
                    primaryKeys.push(attr);
                    if (dataType.includes("REFERENCES")) {
                        match = dataType.match(/^(.+) (REFERENCES.*)$/);
                        attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace("PRIMARY KEY", "")}`);
                        foreignKeys[attr] = match[2];
                    } else {
                        attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
                    }
                } else if (dataType.includes("REFERENCES")) {
                    match = dataType.match(/^(.+) (REFERENCES.*)$/);
                    attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
                    foreignKeys[attr] = match[2];
                } else {
                    attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);
                }
            }
        }
        const pkString = primaryKeys.map((pk)=>this.quoteIdentifier(pk)).join(", ");
        if (options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns, indexName)=>{
                if (columns.customIndex) {
                    if (typeof indexName !== "string") {
                        indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
                    }
                    attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`);
                }
            });
        }
        if (pkString.length > 0) {
            attributesClauseParts.push(`PRIMARY KEY (${pkString})`);
        }
        for(const fkey in foreignKeys){
            if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
                attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);
            }
        }
        const quotedTableName = this.quoteTable(tableName);
        return Utils.joinSQLFragments([
            `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,
            `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(", ")})`,
            ";",
            commentStr
        ]);
    }
    describeTableQuery(tableName, schema) {
        let sql = [
            "SELECT",
            "c.COLUMN_NAME AS 'Name',",
            "c.DATA_TYPE AS 'Type',",
            "c.CHARACTER_MAXIMUM_LENGTH AS 'Length',",
            "c.IS_NULLABLE as 'IsNull',",
            "COLUMN_DEFAULT AS 'Default',",
            "pk.CONSTRAINT_TYPE AS 'Constraint',",
            "COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',",
            "CAST(prop.value AS NVARCHAR) AS 'Comment'",
            "FROM",
            "INFORMATION_SCHEMA.TABLES t",
            "INNER JOIN",
            "INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA",
            "LEFT JOIN (SELECT tc.table_schema, tc.table_name, ",
            "cu.column_name, tc.CONSTRAINT_TYPE ",
            "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ",
            "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ",
            "ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ",
            "and tc.constraint_name=cu.constraint_name ",
            "and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk ",
            "ON pk.table_schema=c.table_schema ",
            "AND pk.table_name=c.table_name ",
            "AND pk.column_name=c.column_name ",
            "INNER JOIN sys.columns AS sc",
            "ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name",
            "LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id",
            "AND prop.minor_id = sc.column_id",
            "AND prop.name = 'MS_Description'",
            "WHERE t.TABLE_NAME =",
            wrapSingleQuote(tableName)
        ].join(" ");
        if (schema) {
            sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;
        }
        return sql;
    }
    renameTableQuery(before, after) {
        return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;
    }
    showTablesQuery() {
        return "SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';";
    }
    tableExistsQuery(table) {
        const tableName = table.tableName || table;
        const schemaName = table.schema || "dbo";
        return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;
    }
    dropTableQuery(tableName) {
        const quoteTbl = this.quoteTable(tableName);
        return Utils.joinSQLFragments([
            `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,
            "DROP TABLE",
            quoteTbl,
            ";"
        ]);
    }
    addColumnQuery(table, key, dataType) {
        dataType.field = key;
        let commentStr = "";
        if (dataType.comment && _.isString(dataType.comment)) {
            commentStr = this.commentTemplate(dataType.comment, table, key);
            delete dataType["comment"];
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(table),
            "ADD",
            this.quoteIdentifier(key),
            this.attributeToSQL(dataType, {
                context: "addColumn"
            }),
            ";",
            commentStr
        ]);
    }
    commentTemplate(comment, table, column) {
        return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;
    }
    removeColumnQuery(tableName, attributeName) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP COLUMN",
            this.quoteIdentifier(attributeName),
            ";"
        ]);
    }
    changeColumnQuery(tableName, attributes) {
        const attrString = [], constraintString = [];
        let commentString = "";
        for(const attributeName in attributes){
            const quotedAttrName = this.quoteIdentifier(attributeName);
            let definition = attributes[attributeName];
            if (definition.includes("COMMENT ")) {
                const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
                const commentText = commentMatch[2].replace("COMMENT", "").trim();
                commentString += this.commentTemplate(commentText, tableName, attributeName);
                definition = commentMatch[1];
            }
            if (definition.includes("REFERENCES")) {
                constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, "")}`);
            } else {
                attrString.push(`${quotedAttrName} ${definition}`);
            }
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            attrString.length && `ALTER COLUMN ${attrString.join(", ")}`,
            constraintString.length && `ADD ${constraintString.join(", ")}`,
            ";",
            commentString
        ]);
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const newName = Object.keys(attributes)[0];
        return Utils.joinSQLFragments([
            "EXEC sp_rename",
            `'${this.quoteTable(tableName)}.${attrBefore}',`,
            `'${newName}',`,
            "'COLUMN'",
            ";"
        ]);
    }
    bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
        const quotedTable = this.quoteTable(tableName);
        options = options || {};
        attributes = attributes || {};
        const tuples = [];
        const allAttributes = [];
        const allQueries = [];
        let needIdentityInsertWrapper = false, outputFragment = "";
        if (options.returning) {
            const returnValues = this.generateReturnValues(attributes, options);
            outputFragment = returnValues.outputFragment;
        }
        const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;
        attrValueHashes.forEach((attrValueHash)=>{
            const fields = Object.keys(attrValueHash);
            const firstAttr = attributes[fields[0]];
            if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
                allQueries.push(emptyQuery);
                return;
            }
            _.forOwn(attrValueHash, (value, key)=>{
                if (value !== null && attributes[key] && attributes[key].autoIncrement) {
                    needIdentityInsertWrapper = true;
                }
                if (!allAttributes.includes(key)) {
                    if (value === null && attributes[key] && attributes[key].autoIncrement) return;
                    allAttributes.push(key);
                }
            });
        });
        if (allAttributes.length > 0) {
            attrValueHashes.forEach((attrValueHash)=>{
                tuples.push(`(${allAttributes.map((key)=>this.escape(attrValueHash[key])).join(",")})`);
            });
            const quotedAttributes = allAttributes.map((attr)=>this.quoteIdentifier(attr)).join(",");
            allQueries.push((tupleStr)=>`INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);
        }
        const commands = [];
        let offset = 0;
        const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;
        while(offset < Math.max(tuples.length, 1)){
            const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
            let generatedQuery = allQueries.map((v)=>typeof v === "string" ? v : v(tupleStr)).join(";");
            if (needIdentityInsertWrapper) {
                generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;
            }
            commands.push(generatedQuery);
            offset += batch;
        }
        return commands.join(";");
    }
    updateQuery(tableName, attrValueHash, where, options, attributes) {
        const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
        if (options.limit) {
            const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;
            sql.query = sql.query.replace("UPDATE", updateArgs);
        }
        return sql;
    }
    upsertQuery(tableName, insertValues, updateValues, where, model) {
        const targetTableAlias = this.quoteTable(`${tableName}_target`);
        const sourceTableAlias = this.quoteTable(`${tableName}_source`);
        const primaryKeysAttrs = [];
        const identityAttrs = [];
        const uniqueAttrs = [];
        const tableNameQuoted = this.quoteTable(tableName);
        let needIdentityInsertWrapper = false;
        for(const key in model.rawAttributes){
            if (model.rawAttributes[key].primaryKey) {
                primaryKeysAttrs.push(model.rawAttributes[key].field || key);
            }
            if (model.rawAttributes[key].unique) {
                uniqueAttrs.push(model.rawAttributes[key].field || key);
            }
            if (model.rawAttributes[key].autoIncrement) {
                identityAttrs.push(model.rawAttributes[key].field || key);
            }
        }
        for (const index of model._indexes){
            if (index.unique && index.fields) {
                for (const field of index.fields){
                    const fieldName = typeof field === "string" ? field : field.name || field.attribute;
                    if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {
                        uniqueAttrs.push(fieldName);
                    }
                }
            }
        }
        const updateKeys = Object.keys(updateValues);
        const insertKeys = Object.keys(insertValues);
        const insertKeysQuoted = insertKeys.map((key)=>this.quoteIdentifier(key)).join(", ");
        const insertValuesEscaped = insertKeys.map((key)=>this.escape(insertValues[key])).join(", ");
        const sourceTableQuery = `VALUES(${insertValuesEscaped})`;
        let joinCondition;
        identityAttrs.forEach((key)=>{
            if (insertValues[key] && insertValues[key] !== null) {
                needIdentityInsertWrapper = true;
            }
        });
        const clauses = where[Op.or].filter((clause)=>{
            let valid = true;
            for(const key in clause){
                if (typeof clause[key] === "undefined" || clause[key] == null) {
                    valid = false;
                    break;
                }
            }
            return valid;
        });
        const getJoinSnippet = (array)=>{
            return array.map((key)=>{
                key = this.quoteIdentifier(key);
                return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
            });
        };
        if (clauses.length === 0) {
            throw new Error("Primary Key or Unique key should be passed to upsert query");
        } else {
            for(const key in clauses){
                const keys = Object.keys(clauses[key]);
                if (primaryKeysAttrs.includes(keys[0])) {
                    joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
                    break;
                }
            }
            if (!joinCondition) {
                joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
            }
        }
        const filteredUpdateClauses = updateKeys.filter((key)=>!identityAttrs.includes(key)).map((key)=>{
            const value = this.escape(updateValues[key]);
            key = this.quoteIdentifier(key);
            return `${targetTableAlias}.${key} = ${value}`;
        });
        const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(", ")}` : "";
        const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
        let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
        query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
        if (needIdentityInsertWrapper) {
            query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
        }
        return query;
    }
    truncateTableQuery(tableName) {
        return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
    }
    deleteQuery(tableName, where, options = {}, model) {
        const table = this.quoteTable(tableName);
        const whereClause = this.getWhereConditions(where, null, model, options);
        return Utils.joinSQLFragments([
            "DELETE",
            options.limit && `TOP(${this.escape(options.limit)})`,
            "FROM",
            table,
            whereClause && `WHERE ${whereClause}`,
            ";",
            "SELECT @@ROWCOUNT AS AFFECTEDROWS",
            ";"
        ]);
    }
    showIndexesQuery(tableName) {
        return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;
    }
    showConstraintsQuery(tableName) {
        return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        if (attribute.references) {
            if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
                this.sequelize.log("MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query");
                attribute.onDelete = "";
                attribute.onUpdate = "";
            }
        }
        let template;
        if (attribute.type instanceof DataTypes.ENUM) {
            if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
            template = attribute.type.toSql();
            template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value)=>{
                return this.escape(value);
            }).join(", ")}))`;
            return template;
        }
        template = attribute.type.toString();
        if (attribute.allowNull === false) {
            template += " NOT NULL";
        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += " NULL";
        }
        if (attribute.autoIncrement) {
            template += " IDENTITY(1,1)";
        }
        if (attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
        }
        if (attribute.unique === true) {
            template += " UNIQUE";
        }
        if (attribute.primaryKey) {
            template += " PRIMARY KEY";
        }
        if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
            template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
            if (attribute.references.key) {
                template += ` (${this.quoteIdentifier(attribute.references.key)})`;
            } else {
                template += ` (${this.quoteIdentifier("id")})`;
            }
            if (attribute.onDelete) {
                template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
            }
            if (attribute.onUpdate) {
                template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
            }
        }
        if (attribute.comment && typeof attribute.comment === "string") {
            template += ` COMMENT ${attribute.comment}`;
        }
        return template;
    }
    attributesToSQL(attributes, options) {
        const result = {}, existingConstraints = [];
        let key, attribute;
        for(key in attributes){
            attribute = attributes[key];
            if (attribute.references) {
                if (existingConstraints.includes(attribute.references.model.toString())) {
                    attribute.onDelete = "";
                    attribute.onUpdate = "";
                } else {
                    existingConstraints.push(attribute.references.model.toString());
                    attribute.onUpdate = "";
                }
            }
            if (key && !attribute.field) attribute.field = key;
            result[attribute.field || key] = this.attributeToSQL(attribute, options);
        }
        return result;
    }
    createTrigger() {
        throwMethodUndefined("createTrigger");
    }
    dropTrigger() {
        throwMethodUndefined("dropTrigger");
    }
    renameTrigger() {
        throwMethodUndefined("renameTrigger");
    }
    createFunction() {
        throwMethodUndefined("createFunction");
    }
    dropFunction() {
        throwMethodUndefined("dropFunction");
    }
    renameFunction() {
        throwMethodUndefined("renameFunction");
    }
    _getForeignKeysQueryPrefix(catalogName) {
        return `${"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, "}${catalogName ? `constraintCatalog = '${catalogName}', ` : ""}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : ""}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : ""}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;
    }
    getForeignKeysQuery(table, catalogName) {
        const tableName = table.tableName || table;
        let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;
        if (table.schema) {
            sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
        }
        return sql;
    }
    getForeignKeyQuery(table, attributeName) {
        const tableName = table.tableName || table;
        return Utils.joinSQLFragments([
            this._getForeignKeysQueryPrefix(),
            "WHERE",
            `TB.NAME =${wrapSingleQuote(tableName)}`,
            "AND",
            `COL.NAME =${wrapSingleQuote(attributeName)}`,
            table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`
        ]);
    }
    getPrimaryKeyConstraintQuery(table, attributeName) {
        const tableName = wrapSingleQuote(table.tableName || table);
        return Utils.joinSQLFragments([
            "SELECT K.TABLE_NAME AS tableName,",
            "K.COLUMN_NAME AS columnName,",
            "K.CONSTRAINT_NAME AS constraintName",
            "FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C",
            "JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K",
            "ON C.TABLE_NAME = K.TABLE_NAME",
            "AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG",
            "AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA",
            "AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME",
            "WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'",
            `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
            `AND K.TABLE_NAME = ${tableName}`,
            ";"
        ]);
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP",
            this.quoteIdentifier(foreignKey)
        ]);
    }
    getDefaultConstraintQuery(tableName, attributeName) {
        const quotedTable = this.quoteTable(tableName);
        return Utils.joinSQLFragments([
            "SELECT name FROM sys.default_constraints",
            `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,
            `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,
            `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,
            ";"
        ]);
    }
    dropConstraintQuery(tableName, constraintName) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP CONSTRAINT",
            this.quoteIdentifier(constraintName),
            ";"
        ]);
    }
    setIsolationLevelQuery() {}
    generateTransactionId() {
        return randomBytes(10).toString("hex");
    }
    startTransactionQuery(transaction) {
        if (transaction.parent) {
            return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
        }
        return "BEGIN TRANSACTION;";
    }
    commitTransactionQuery(transaction) {
        if (transaction.parent) {
            return;
        }
        return "COMMIT TRANSACTION;";
    }
    rollbackTransactionQuery(transaction) {
        if (transaction.parent) {
            return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
        }
        return "ROLLBACK TRANSACTION;";
    }
    selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
        this._throwOnEmptyAttributes(attributes, {
            modelName: model && model.name,
            as: mainTableAs
        });
        const dbVersion = this.sequelize.options.databaseVersion;
        const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, "11.0.0");
        if (isSQLServer2008 && options.offset) {
            const offset = options.offset || 0;
            const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
            let orders = {
                mainQueryOrder: []
            };
            if (options.order) {
                orders = this.getQueryOrders(options, model, isSubQuery);
            }
            if (orders.mainQueryOrder.length === 0) {
                orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
            }
            const tmpTable = mainTableAs || "OffsetTable";
            if (options.include) {
                const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;
                const mainTable = {
                    name: mainTableAs,
                    quotedName: null,
                    as: null,
                    model
                };
                const topLevelInfo = {
                    names: mainTable,
                    options,
                    subQuery
                };
                let mainJoinQueries = [];
                for (const include of options.include){
                    if (include.separate) {
                        continue;
                    }
                    const joinQueries = this.generateInclude(include, {
                        externalAs: mainTableAs,
                        internalAs: mainTableAs
                    }, topLevelInfo);
                    mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);
                }
                return Utils.joinSQLFragments([
                    "SELECT TOP 100 PERCENT",
                    attributes.join(", "),
                    "FROM (",
                    [
                        "SELECT",
                        options.limit && `TOP ${options.limit}`,
                        "* FROM (",
                        [
                            "SELECT ROW_NUMBER() OVER (",
                            [
                                "ORDER BY",
                                orders.mainQueryOrder.join(", ")
                            ],
                            `) as row_num, ${tmpTable}.* FROM (`,
                            [
                                "SELECT DISTINCT",
                                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,
                                mainJoinQueries,
                                where && `WHERE ${where}`
                            ],
                            `) AS ${tmpTable}`
                        ],
                        `) AS ${tmpTable} WHERE row_num > ${offset}`
                    ],
                    `) AS ${tmpTable}`
                ]);
            }
            return Utils.joinSQLFragments([
                "SELECT TOP 100 PERCENT",
                attributes.join(", "),
                "FROM (",
                [
                    "SELECT",
                    options.limit && `TOP ${options.limit}`,
                    "* FROM (",
                    [
                        "SELECT ROW_NUMBER() OVER (",
                        [
                            "ORDER BY",
                            orders.mainQueryOrder.join(", ")
                        ],
                        `) as row_num, * FROM ${tables} AS ${tmpTable}`,
                        where && `WHERE ${where}`
                    ],
                    `) AS ${tmpTable} WHERE row_num > ${offset}`
                ],
                `) AS ${tmpTable}`
            ]);
        }
        return Utils.joinSQLFragments([
            "SELECT",
            isSQLServer2008 && options.limit && `TOP ${options.limit}`,
            attributes.join(", "),
            `FROM ${tables}`,
            mainTableAs && `AS ${mainTableAs}`,
            options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`
        ]);
    }
    addLimitAndOffset(options, model) {
        if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, "11.0.0")) {
            return "";
        }
        const offset = options.offset || 0;
        const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;
        let fragment = "";
        let orders = {};
        if (options.order) {
            orders = this.getQueryOrders(options, model, isSubQuery);
        }
        if (options.limit || options.offset) {
            if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {
                let primaryKey = model.primaryKeyField;
                const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;
                const aliasedAttribute = (options.attributes || []).find((attr)=>Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));
                if (aliasedAttribute) {
                    const modelName = this.quoteIdentifier(options.tableAs || model.name);
                    const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);
                    primaryKey = new Utils.Col(alias || aliasedAttribute[1]);
                }
                if (!options.order || !options.order.length) {
                    fragment += ` ORDER BY ${tablePkFragment}`;
                } else {
                    const orderFieldNames = (options.order || []).map((order)=>{
                        const value = Array.isArray(order) ? order[0] : order;
                        if (value instanceof Utils.Col) {
                            return value.col;
                        }
                        if (value instanceof Utils.Literal) {
                            return value.val;
                        }
                        return value;
                    });
                    const primaryKeyFieldAlreadyPresent = orderFieldNames.some((fieldName)=>fieldName === (primaryKey.col || primaryKey));
                    if (!primaryKeyFieldAlreadyPresent) {
                        fragment += options.order && !isSubQuery ? ", " : " ORDER BY ";
                        fragment += tablePkFragment;
                    }
                }
            }
            if (options.offset || options.limit) {
                fragment += ` OFFSET ${this.escape(offset)} ROWS`;
            }
            if (options.limit) {
                fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
            }
        }
        return fragment;
    }
    booleanValue(value) {
        return value ? 1 : 0;
    }
    quoteIdentifier(identifier, force) {
        return `[${identifier.replace(/[[\]']+/g, "")}]`;
    }
}
function wrapSingleQuote(identifier) {
    return Utils.addTicks(Utils.removeTicks(identifier, "'"), "'");
}
module.exports = MSSQLQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
class MSSqlQueryInterface extends QueryInterface {
    async removeColumn(tableName, attributeName, options) {
        options = __spreadValues({
            raw: true
        }, options || {});
        const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);
        const [results0] = await this.sequelize.query(findConstraintSql, options);
        if (results0.length) {
            const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);
            await this.sequelize.query(dropConstraintSql, options);
        }
        const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);
        const [results] = await this.sequelize.query(findForeignKeySql, options);
        if (results.length) {
            const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);
            await this.sequelize.query(dropForeignKeySql, options);
        }
        const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);
        const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);
        if (result.length) {
            const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);
            await this.sequelize.query(dropConstraintSql, options);
        }
        const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);
        return this.sequelize.query(removeSql, options);
    }
    async upsert(tableName, insertValues, updateValues, where, options) {
        const model = options.model;
        const wheres = [];
        options = __spreadValues({}, options);
        if (!Utils.isWhereEmpty(where)) {
            wheres.push(where);
        }
        let indexes = Object.values(model.uniqueKeys).map((item)=>item.fields);
        indexes = indexes.concat(Object.values(model._indexes).filter((item)=>item.unique).map((item)=>item.fields));
        const attributes = Object.keys(insertValues);
        for (const index of indexes){
            if (_.intersection(attributes, index).length === index.length) {
                where = {};
                for (const field of index){
                    where[field] = insertValues[field];
                }
                wheres.push(where);
            }
        }
        where = {
            [Op.or]: wheres
        };
        options.type = QueryTypes.UPSERT;
        options.raw = true;
        const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
        return await this.sequelize.query(sql, options);
    }
}
exports.MSSqlQueryInterface = MSSqlQueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mssql/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mssql;
const { MSSqlQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/query-interface.js [app-route] (ecmascript)");
class MssqlDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);
    }
}
MssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    DEFAULT: true,
    "DEFAULT VALUES": true,
    "LIMIT ON UPDATE": true,
    "ORDER NULLS": false,
    lock: false,
    transactions: true,
    migrations: false,
    returnValues: {
        output: true
    },
    schemas: true,
    autoIncrement: {
        identityInsert: true,
        defaultValue: false,
        update: false
    },
    constraints: {
        restrict: false,
        default: true
    },
    index: {
        collate: false,
        length: false,
        parser: false,
        type: true,
        using: false,
        where: true
    },
    NUMERIC: true,
    tmpTableTrigger: true
});
MssqlDialect.prototype.defaultVersion = "12.0.2000";
MssqlDialect.prototype.Query = Query;
MssqlDialect.prototype.name = "mssql";
MssqlDialect.prototype.TICK_CHAR = '"';
MssqlDialect.prototype.TICK_CHAR_LEFT = "[";
MssqlDialect.prototype.TICK_CHAR_RIGHT = "]";
MssqlDialect.prototype.DataTypes = DataTypes;
module.exports = MssqlDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const SequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mysql;
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const debug = logger.debugContext("connection:mysql");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("mysql");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 3306;
        super(dialect, sequelize);
        this.lib = this._loadDialectModule("mysql2");
        this.refreshTypeParser(DataTypes);
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    static _typecast(field, next) {
        if (parserStore.get(field.type)) {
            return parserStore.get(field.type)(field, this.sequelize.options, next);
        }
        return next();
    }
    async connect(config) {
        const connectionConfig = __spreadValues({
            host: config.host,
            port: config.port,
            user: config.username,
            flags: "-FOUND_ROWS",
            password: config.password,
            database: config.database,
            timezone: this.sequelize.options.timezone,
            typeCast: ConnectionManager._typecast.bind(this),
            bigNumberStrings: false,
            supportBigNumbers: true
        }, config.dialectOptions);
        try {
            const connection = await new Promise((resolve, reject)=>{
                const connection2 = this.lib.createConnection(connectionConfig);
                const errorHandler = (e)=>{
                    connection2.removeListener("connect", connectHandler);
                    connection2.removeListener("error", connectHandler);
                    reject(e);
                };
                const connectHandler = ()=>{
                    connection2.removeListener("error", errorHandler);
                    resolve(connection2);
                };
                connection2.on("error", errorHandler);
                connection2.once("connect", connectHandler);
            });
            debug("connection acquired");
            connection.on("error", (error)=>{
                switch(error.code){
                    case "ESOCKET":
                    case "ECONNRESET":
                    case "EPIPE":
                    case "PROTOCOL_CONNECTION_LOST":
                        this.pool.destroy(connection);
                }
            });
            if (!this.sequelize.config.keepDefaultTimezone) {
                let tzOffset = this.sequelize.options.timezone;
                tzOffset = /\//.test(tzOffset) ? momentTz.tz(tzOffset).format("Z") : tzOffset;
                await promisify((cb)=>connection.query(`SET time_zone = '${tzOffset}'`, cb))();
            }
            return connection;
        } catch (err) {
            switch(err.code){
                case "ECONNREFUSED":
                    throw new SequelizeErrors.ConnectionRefusedError(err);
                case "ER_ACCESS_DENIED_ERROR":
                    throw new SequelizeErrors.AccessDeniedError(err);
                case "ENOTFOUND":
                    throw new SequelizeErrors.HostNotFoundError(err);
                case "EHOSTUNREACH":
                    throw new SequelizeErrors.HostNotReachableError(err);
                case "EINVAL":
                    throw new SequelizeErrors.InvalidConnectionError(err);
                default:
                    throw new SequelizeErrors.ConnectionError(err);
            }
        }
    }
    async disconnect(connection) {
        if (connection._closing) {
            debug("connection tried to disconnect but was already at CLOSED state");
            return;
        }
        return await promisify((callback)=>connection.end(callback))();
    }
    validate(connection) {
        return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;
const debug = logger.debugContext("sql:mysql");
class Query extends AbstractQuery {
    constructor(connection, sequelize, options){
        super(connection, sequelize, __spreadValues({
            showWarnings: false
        }, options));
    }
    static formatBindParameters(sql, values, dialect) {
        const bindParam = [];
        const replacementFunc = (match, key, values_)=>{
            if (values_[key] !== void 0) {
                bindParam.push(values_[key]);
                return "?";
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        return [
            sql,
            bindParam.length > 0 ? bindParam : void 0
        ];
    }
    async run(sql, parameters) {
        this.sql = sql;
        const { connection, options } = this;
        const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;
        const complete = this._logQuery(sql, debug, parameters);
        if (parameters) {
            debug("parameters(%j)", parameters);
        }
        let results;
        const errForStack = new Error();
        try {
            if (parameters && parameters.length) {
                results = await new Promise((resolve, reject)=>{
                    connection.execute(sql, parameters, (error, result)=>error ? reject(error) : resolve(result)).setMaxListeners(100);
                });
            } else {
                results = await new Promise((resolve, reject)=>{
                    connection.query({
                        sql
                    }, (error, result)=>error ? reject(error) : resolve(result)).setMaxListeners(100);
                });
            }
        } catch (error) {
            if (options.transaction && error.errno === ER_DEADLOCK) {
                try {
                    await options.transaction.rollback();
                } catch (error_) {}
                options.transaction.finished = "rollback";
            }
            error.sql = sql;
            error.parameters = parameters;
            throw this.formatError(error, errForStack.stack);
        } finally{
            complete();
        }
        if (showWarnings && results && results.warningStatus > 0) {
            await this.logWarnings(results);
        }
        return this.formatResults(results);
    }
    formatResults(data) {
        let result = this.instance;
        if (this.isInsertQuery(data)) {
            this.handleInsertQuery(data);
            if (!this.instance) {
                if (data.constructor.name === "ResultSetHeader" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {
                    const startId = data[this.getInsertIdField()];
                    result = [];
                    for(let i = startId; i < startId + data.affectedRows; i++){
                        result.push({
                            [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i
                        });
                    }
                } else {
                    result = data[this.getInsertIdField()];
                }
            }
        }
        if (this.isSelectQuery()) {
            return this.handleSelectQuery(data);
        }
        if (this.isShowTablesQuery()) {
            return this.handleShowTablesQuery(data);
        }
        if (this.isDescribeQuery()) {
            result = {};
            for (const _result of data){
                const enumRegex = /^enum/i;
                result[_result.Field] = {
                    type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, "ENUM") : _result.Type.toUpperCase(),
                    allowNull: _result.Null === "YES",
                    defaultValue: _result.Default,
                    primaryKey: _result.Key === "PRI",
                    autoIncrement: Object.prototype.hasOwnProperty.call(_result, "Extra") && _result.Extra.toLowerCase() === "auto_increment",
                    comment: _result.Comment ? _result.Comment : null
                };
            }
            return result;
        }
        if (this.isShowIndexesQuery()) {
            return this.handleShowIndexesQuery(data);
        }
        if (this.isCallQuery()) {
            return data[0];
        }
        if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
            return data.affectedRows;
        }
        if (this.isVersionQuery()) {
            return data[0].version;
        }
        if (this.isForeignKeysQuery()) {
            return data;
        }
        if (this.isUpsertQuery()) {
            return [
                result,
                data.affectedRows === 1
            ];
        }
        if (this.isInsertQuery() || this.isUpdateQuery()) {
            return [
                result,
                data.affectedRows
            ];
        }
        if (this.isShowConstraintsQuery()) {
            return data;
        }
        if (this.isRawQuery()) {
            return [
                data,
                data
            ];
        }
        return result;
    }
    async logWarnings(results) {
        const warningResults = await this.run("SHOW WARNINGS");
        const warningMessage = `MySQL Warnings (${this.connection.uuid || "default"}): `;
        const messages = [];
        for (const _warningRow of warningResults){
            if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== "function") {
                continue;
            }
            for (const _warningResult of _warningRow){
                if (Object.prototype.hasOwnProperty.call(_warningResult, "Message")) {
                    messages.push(_warningResult.Message);
                } else {
                    for (const _objectKey of _warningResult.keys()){
                        messages.push([
                            _objectKey,
                            _warningResult[_objectKey]
                        ].join(": "));
                    }
                }
            }
        }
        this.sequelize.log(warningMessage + messages.join("; "), this.options);
        return results;
    }
    formatError(err, errStack) {
        const errCode = err.errno || err.code;
        switch(errCode){
            case ER_DUP_ENTRY:
                {
                    const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?$/);
                    let fields = {};
                    let message = "Validation error";
                    const values = match ? match[1].split("-") : void 0;
                    const fieldKey = match ? match[2].split(".").pop() : void 0;
                    const fieldVal = match ? match[1] : void 0;
                    const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];
                    if (uniqueKey) {
                        if (uniqueKey.msg) message = uniqueKey.msg;
                        fields = _.zipObject(uniqueKey.fields, values);
                    } else {
                        fields[fieldKey] = fieldVal;
                    }
                    const errors = [];
                    _.forOwn(fields, (value, field)=>{
                        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
                    });
                    return new sequelizeErrors.UniqueConstraintError({
                        message,
                        errors,
                        parent: err,
                        fields,
                        stack: errStack
                    });
                }
            case ER_ROW_IS_REFERENCED:
            case ER_NO_REFERENCED_ROW:
                {
                    const match = err.message.match(/CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/);
                    const quoteChar = match ? match[1] : "`";
                    const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;
                    return new sequelizeErrors.ForeignKeyConstraintError({
                        reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? "parent" : "child",
                        table: match ? match[4] : void 0,
                        fields,
                        value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,
                        index: match ? match[2] : void 0,
                        parent: err,
                        stack: errStack
                    });
                }
            default:
                return new sequelizeErrors.DatabaseError(err, {
                    stack: errStack
                });
        }
    }
    handleShowIndexesQuery(data) {
        data = data.reduce((acc, item)=>{
            if (!(item.Key_name in acc)) {
                acc[item.Key_name] = item;
                item.fields = [];
            }
            acc[item.Key_name].fields[item.Seq_in_index - 1] = {
                attribute: item.Column_name,
                length: item.Sub_part || void 0,
                order: item.Collation === "A" ? "ASC" : void 0
            };
            delete item.column_name;
            return acc;
        }, {});
        return _.map(data, (item)=>({
                primary: item.Key_name === "PRIMARY",
                fields: item.fields,
                name: item.Key_name,
                tableName: item.Table,
                unique: item.Non_unique !== 1,
                type: item.Index_type
            }));
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/mysql/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").mysql;
const { MySQLQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query-interface.js [app-route] (ecmascript)");
class MysqlDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);
    }
    canBackslashEscape() {
        return true;
    }
}
MysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "VALUES ()": true,
    "LIMIT ON UPDATE": true,
    lock: true,
    forShare: "LOCK IN SHARE MODE",
    settingIsolationLevelDuringTransaction: false,
    inserts: {
        ignoreDuplicates: " IGNORE",
        updateOnDuplicate: " ON DUPLICATE KEY UPDATE"
    },
    index: {
        collate: false,
        length: true,
        parser: true,
        type: true,
        using: 1
    },
    constraints: {
        dropConstraint: false,
        check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: true,
    JSON: true,
    REGEXP: true
});
MysqlDialect.prototype.defaultVersion = "5.7.0";
MysqlDialect.prototype.Query = Query;
MysqlDialect.prototype.QueryGenerator = QueryGenerator;
MysqlDialect.prototype.DataTypes = DataTypes;
MysqlDialect.prototype.name = "mysql";
MysqlDialect.prototype.TICK_CHAR = "`";
MysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;
MysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;
module.exports = MysqlDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    OracleConnectionManager: ()=>OracleConnectionManager
});
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const SequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("oracle");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const debug = logger.debugContext("connection:oracle");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").oracle;
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
class OracleConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        super(dialect, sequelize);
        this.sequelize = sequelize;
        this.sequelize.config.port = this.sequelize.config.port || 1521;
        this.lib = this._loadDialectModule("oracledb");
        this.extendLib();
        this.refreshTypeParser(DataTypes);
    }
    extendLib() {
        if (this.sequelize.config && "dialectOptions" in this.sequelize.config) {
            const dialectOptions = this.sequelize.config.dialectOptions;
            if (dialectOptions && "maxRows" in dialectOptions) {
                this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;
            }
            if (dialectOptions && "fetchAsString" in dialectOptions) {
                this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;
            } else {
                this.lib.fetchAsString = [
                    this.lib.CLOB
                ];
            }
        }
        this.lib.fetchAsBuffer = [
            this.lib.BLOB
        ];
    }
    buildConnectString(config) {
        if (!config.host || config.host.length === 0) return config.database;
        let connectString = config.host;
        if (config.port && config.port > 0) {
            connectString += `:${config.port}`;
        } else {
            connectString += ":1521";
        }
        if (config.database && config.database.length > 0) {
            connectString += `/${config.database}`;
        }
        return connectString;
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    async connect(config) {
        const connectionConfig = __spreadValues({
            user: config.username,
            password: config.password,
            externalAuth: config.externalAuth,
            stmtCacheSize: 0,
            connectString: this.buildConnectString(config)
        }, config.dialectOptions);
        try {
            const connection = await this.lib.getConnection(connectionConfig);
            this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;
            debug("connection acquired");
            connection.on("error", (error)=>{
                switch(error.code){
                    case "ESOCKET":
                    case "ECONNRESET":
                    case "EPIPE":
                    case "PROTOCOL_CONNECTION_LOST":
                        this.pool.destroy(connection);
                }
            });
            return connection;
        } catch (err) {
            let errorCode = err.message.split(":");
            errorCode = errorCode[0];
            switch(errorCode){
                case "ORA-12560":
                case "ORA-12154":
                case "ORA-12505":
                case "ORA-12514":
                case "NJS-511":
                case "NJS-516":
                case "NJS-517":
                case "NJS-520":
                    throw new SequelizeErrors.ConnectionRefusedError(err);
                case "ORA-28000":
                case "ORA-28040":
                case "ORA-01017":
                case "NJS-506":
                    throw new SequelizeErrors.AccessDeniedError(err);
                case "ORA-12541":
                case "NJS-503":
                case "NJS-508":
                case "NJS-507":
                    throw new SequelizeErrors.HostNotReachableError(err);
                case "NJS-512":
                case "NJS-515":
                case "NJS-518":
                case "NJS-519":
                    throw new SequelizeErrors.InvalidConnectionError(err);
                case "ORA-12170":
                case "NJS-510":
                    throw new SequelizeErrors.ConnectionTimedOutError(err);
                default:
                    throw new SequelizeErrors.ConnectionError(err);
            }
        }
    }
    async disconnect(connection) {
        if (!connection.isHealthy()) {
            debug("connection tried to disconnect but was already at CLOSED state");
            return;
        }
        return await promisify((callback)=>connection.close(callback))();
    }
    validate(connection) {
        return connection && connection.isHealthy();
    }
} //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    OracleQuery: ()=>OracleQuery
});
const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const SequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("oracle");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("sql:oracle");
class OracleQuery extends AbstractQuery {
    constructor(connection, sequelize, options){
        super(connection, sequelize, options);
        this.options = _.extend({
            logging: console.log,
            plain: false,
            raw: false
        }, options || {});
        this.checkLoggingOption();
        this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;
    }
    getInsertIdField() {
        return "id";
    }
    getExecOptions() {
        const execOpts = {
            outFormat: this.outFormat,
            autoCommit: this.autoCommit
        };
        const oracledb = this.sequelize.connectionManager.lib;
        if (this.model && this.isSelectQuery()) {
            const fInfo = {};
            const keys = Object.keys(this.model.tableAttributes);
            for (const key of keys){
                const keyValue = this.model.tableAttributes[key];
                if (keyValue.type.key === "DECIMAL") {
                    fInfo[key] = {
                        type: oracledb.STRING
                    };
                }
                if (keyValue.type.key === "BIGINT") {
                    fInfo[key] = {
                        type: oracledb.STRING
                    };
                }
            }
            if ("TURBOPACK compile-time truthy", 1) {
                execOpts.fetchInfo = fInfo;
            }
        }
        return execOpts;
    }
    _convertBindAttributes(bindingDictionary, oracledb) {
        if (this.model && this.options[bindingDictionary]) {
            const keys = Object.keys(this.model.tableAttributes);
            for (const key of keys){
                const keyValue = this.model.tableAttributes[key];
                if (keyValue.type.key === "BIGINT") {
                    const oldBinding = this.options[bindingDictionary][key];
                    if (oldBinding) {
                        this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {
                            type: oracledb.STRING,
                            maxSize: 1e7
                        });
                    }
                }
            }
        }
    }
    async run(sql, parameters) {
        const oracledb = this.sequelize.connectionManager.lib;
        const complete = this._logQuery(sql, debug, parameters);
        const outParameters = [];
        const bindParameters = [];
        const bindDef = [];
        if (!sql.match(/END;$/)) {
            this.sql = sql.replace(/; *$/, "");
        } else {
            this.sql = sql;
        }
        if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {
            this._convertBindAttributes("outBindAttributes", oracledb);
            outParameters.push(...Object.values(this.options.outBindAttributes));
            if (this.isUpsertQuery()) {
                outParameters.push({
                    dir: oracledb.BIND_OUT
                });
            }
        }
        this.bindParameters = outParameters;
        if (Array.isArray(parameters) || _.isPlainObject(parameters)) {
            if (this.options.executeMany) {
                this._convertBindAttributes("inbindAttributes", oracledb);
                bindDef.push(...Object.values(this.options.inbindAttributes));
                bindDef.push(...outParameters);
                this.bindParameters = parameters;
            } else if (this.isRawQuery()) {
                this.bindParameters = parameters;
            } else {
                Object.values(parameters).forEach((value)=>{
                    bindParameters.push(value);
                });
                bindParameters.push(...outParameters);
                Object.assign(this.bindParameters, bindParameters);
            }
        }
        if (this.sql.startsWith("BEGIN TRANSACTION")) {
            this.autocommit = false;
            return Promise.resolve();
        }
        if (this.sql.startsWith("SET AUTOCOMMIT ON")) {
            this.autocommit = true;
            return Promise.resolve();
        }
        if (this.sql.startsWith("SET AUTOCOMMIT OFF")) {
            this.autocommit = false;
            return Promise.resolve();
        }
        if (this.sql.startsWith("DECLARE x NUMBER")) {
            if (this.autoCommit === void 0) {
                if (this.connection.uuid) {
                    this.autoCommit = false;
                } else {
                    this.autoCommit = true;
                }
            }
            try {
                await this.connection.execute(this.sql, this.bindParameters, {
                    autoCommit: this.autoCommit
                });
                return Object.create(null);
            } catch (error) {
                throw this.formatError(error);
            } finally{
                complete();
            }
        }
        if (this.sql.startsWith("BEGIN")) {
            if (this.autoCommit === void 0) {
                if (this.connection.uuid) {
                    this.autoCommit = false;
                } else {
                    this.autoCommit = true;
                }
            }
            try {
                const result = await this.connection.execute(this.sql, this.bindParameters, {
                    outFormat: this.outFormat,
                    autoCommit: this.autoCommit
                });
                if (!Array.isArray(result.outBinds)) {
                    return [
                        result.outBinds
                    ];
                }
                return result.outBinds;
            } catch (error) {
                throw this.formatError(error);
            } finally{
                complete();
            }
        }
        if (this.sql.startsWith("COMMIT TRANSACTION")) {
            try {
                await this.connection.commit();
                return Object.create(null);
            } catch (error) {
                throw this.formatError(error);
            } finally{
                complete();
            }
        }
        if (this.sql.startsWith("ROLLBACK TRANSACTION")) {
            try {
                await this.connection.rollback();
                return Object.create(null);
            } catch (error) {
                throw this.formatError(error);
            } finally{
                complete();
            }
        }
        if (this.sql.startsWith("SET TRANSACTION")) {
            try {
                await this.connection.execute(this.sql, [], {
                    autoCommit: false
                });
                return Object.create(null);
            } catch (error) {
                throw this.formatError(error);
            } finally{
                complete();
            }
        }
        if (this.autoCommit === void 0) {
            if (this.connection.uuid) {
                this.autoCommit = false;
            } else {
                this.autoCommit = true;
            }
        }
        if ("inputParameters" in this.options && this.options.inputParameters !== null) {
            Object.assign(this.bindParameters, this.options.inputParameters);
        }
        const execOpts = this.getExecOptions();
        if (this.options.executeMany && bindDef.length > 0) {
            execOpts.bindDefs = bindDef;
        }
        const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);
        try {
            const result = await executePromise;
            return this.formatResults(result);
        } catch (error) {
            throw this.formatError(error);
        } finally{
            complete();
        }
    }
    static formatBindParameters(sql, values, dialect) {
        const replacementFunc = (match, key, values2)=>{
            if (values2[key] !== void 0) {
                return `:${key}`;
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        return [
            sql,
            values
        ];
    }
    _getAttributeMap(attrsMap, rawAttributes) {
        attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key)=>{
            const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);
            mp[catalogKey] = key;
            return mp;
        }, {}));
    }
    _processRows(rows) {
        let result = rows;
        let attrsMap = {};
        if (this.sequelize.options.quoteIdentifiers === false) {
            attrsMap = _.reduce(this.options.attributes, (mp, v)=>{
                if (typeof v === "object") {
                    v = v[1];
                }
                const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);
                mp[catalogv] = v;
                return mp;
            }, {});
            if (this.model) {
                this._getAttributeMap(attrsMap, this.model.rawAttributes);
            }
            if (this.options.aliasesMapping) {
                const obj = Object.fromEntries(this.options.aliasesMapping);
                rows = rows.map((row)=>_.toPairs(row).reduce((acc, [key, value])=>{
                        const mapping = Object.values(obj).find((element)=>{
                            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);
                            return catalogElement === key;
                        });
                        if (mapping) acc[mapping || key] = value;
                        return acc;
                    }, {}));
            }
            result = rows.map((row)=>{
                return _.mapKeys(row, (value, key)=>{
                    const targetAttr = attrsMap[key];
                    if (typeof targetAttr === "string" && targetAttr !== key) {
                        return targetAttr;
                    }
                    return key;
                });
            });
        }
        if (this.model) {
            result = result.map((row)=>{
                return _.mapValues(row, (value, key)=>{
                    if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {
                        let typeid = this.model.rawAttributes[key].type.toLocaleString();
                        if (this.model.rawAttributes[key].type.key === "JSON") {
                            value = JSON.parse(value);
                        }
                        if (typeid.indexOf("(") > -1 && this.model.rawAttributes[key].type.key !== "BOOLEAN") {
                            typeid = typeid.substr(0, typeid.indexOf("("));
                        }
                        const parse = parserStore.get(typeid);
                        if (value !== null & !!parse) {
                            value = parse(value);
                        }
                    }
                    return value;
                });
            });
        }
        return result;
    }
    formatResults(data) {
        let result = this.instance;
        if (this.isInsertQuery(data)) {
            let insertData;
            if (data.outBinds) {
                const keys = Object.keys(this.options.outBindAttributes);
                insertData = data.outBinds;
                if (this.instance) {
                    insertData = [
                        insertData
                    ];
                }
                const res = insertData.map((row)=>{
                    const obj = {};
                    row.forEach((element, index)=>{
                        obj[keys[index]] = element[0];
                    });
                    return obj;
                });
                insertData = res;
                if (!this.instance) {
                    result = res;
                }
            }
            this.handleInsertQuery(insertData);
            return [
                result,
                data.rowsAffected
            ];
        }
        if (this.isShowTablesQuery()) {
            result = this.handleShowTablesQuery(data.rows);
        } else if (this.isDescribeQuery()) {
            result = {};
            const table = Object.keys(this.sequelize.models);
            const modelAttributes = {};
            if (this.sequelize.models && table.length > 0) {
                this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);
            }
            data.rows.forEach((_result)=>{
                if (_result.Default) {
                    _result.Default = _result.Default.replace("('", "").replace("')", "").replace(/'/g, "");
                }
                if (!(modelAttributes[_result.COLUMN_NAME] in result)) {
                    let key = modelAttributes[_result.COLUMN_NAME];
                    if (!key) {
                        key = _result.COLUMN_NAME;
                    }
                    result[key] = {
                        type: _result.DATA_TYPE.toUpperCase(),
                        allowNull: _result.NULLABLE === "N" ? false : true,
                        defaultValue: void 0,
                        primaryKey: _result.CONSTRAINT_TYPE === "P"
                    };
                }
            });
        } else if (this.isShowIndexesQuery()) {
            result = this.handleShowIndexesQuery(data.rows);
        } else if (this.isSelectQuery()) {
            const rows = data.rows;
            const result2 = this._processRows(rows);
            return this.handleSelectQuery(result2);
        } else if (this.isCallQuery()) {
            result = data.rows[0];
        } else if (this.isUpdateQuery()) {
            result = [
                result,
                data.rowsAffected
            ];
        } else if (this.isBulkUpdateQuery()) {
            result = data.rowsAffected;
        } else if (this.isBulkDeleteQuery()) {
            result = data.rowsAffected;
        } else if (this.isVersionQuery()) {
            const version = data.rows[0].VERSION_FULL;
            if (version) {
                const versions = version.split(".");
                result = `${versions[0]}.${versions[1]}.${versions[2]}`;
            } else {
                result = "0.0.0";
            }
        } else if (this.isForeignKeysQuery()) {
            result = data.rows;
        } else if (this.isUpsertQuery()) {
            data = data.outBinds;
            const keys = Object.keys(this.options.outBindAttributes);
            const obj = {};
            for(const k in keys){
                obj[keys[k]] = data[k];
            }
            obj.isUpdate = data[data.length - 1];
            data = obj;
            result = [
                {
                    isNewRecord: data.isUpdate,
                    value: data
                },
                data.isUpdate == 0
            ];
        } else if (this.isShowConstraintsQuery()) {
            result = this.handleShowConstraintsQuery(data);
        } else if (this.isRawQuery()) {
            if (data && data.rows) {
                return [
                    data.rows,
                    data.metaData
                ];
            }
            return [
                data,
                data
            ];
        }
        return result;
    }
    handleShowConstraintsQuery(data) {
        return data.rows.map((result)=>{
            const constraint = {};
            for(const key in result){
                constraint[_.camelCase(key)] = result[key].toLowerCase();
            }
            return constraint;
        });
    }
    handleShowTablesQuery(results) {
        return results.map((resultSet)=>{
            return {
                tableName: resultSet.TABLE_NAME,
                schema: resultSet.TABLE_SCHEMA
            };
        });
    }
    formatError(err) {
        let match;
        match = err.message.match(/unique constraint ([\s\S]*) violated/);
        if (match && match.length > 1) {
            match[1] = match[1].replace("(", "").replace(")", "").split(".")[1];
            const errors = [];
            let fields = [], message = "Validation error", uniqueKey = null;
            if (this.model) {
                const uniqueKeys = Object.keys(this.model.uniqueKeys);
                const currKey = uniqueKeys.find((key)=>{
                    return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `"${match[1].toUpperCase()}"`;
                });
                if (currKey) {
                    uniqueKey = this.model.uniqueKeys[currKey];
                    fields = uniqueKey.fields;
                }
                if (uniqueKey && !!uniqueKey.msg) {
                    message = uniqueKey.msg;
                }
                fields.forEach((field)=>{
                    errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, null));
                });
            }
            return new SequelizeErrors.UniqueConstraintError({
                message,
                errors,
                err,
                fields
            });
        }
        match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);
        if (match && match.length > 0) {
            return new SequelizeErrors.ForeignKeyConstraintError({
                fields: null,
                index: match[1],
                parent: err
            });
        }
        match = err.message.match(/ORA-02443/);
        if (match && match.length > 0) {
            return new SequelizeErrors.UnknownConstraintError(match[1]);
        }
        return new SequelizeErrors.DatabaseError(err);
    }
    isShowIndexesQuery() {
        return this.sql.indexOf("SELECT i.index_name,i.table_name, i.column_name, u.uniqueness") > -1;
    }
    isSelectCountQuery() {
        return this.sql.toUpperCase().indexOf("SELECT COUNT(") > -1;
    }
    handleShowIndexesQuery(data) {
        const acc = [];
        data.forEach((indexRecord)=>{
            if (!acc[indexRecord.INDEX_NAME]) {
                acc[indexRecord.INDEX_NAME] = {
                    unique: indexRecord.UNIQUENESS === "UNIQUE" ? true : false,
                    primary: indexRecord.CONSTRAINT_TYPE === "P",
                    name: indexRecord.INDEX_NAME.toLowerCase(),
                    tableName: indexRecord.TABLE_NAME.toLowerCase(),
                    type: void 0
                };
                acc[indexRecord.INDEX_NAME].fields = [];
            }
            acc[indexRecord.INDEX_NAME].fields.push({
                attribute: indexRecord.COLUMN_NAME,
                length: void 0,
                order: indexRecord.DESCEND,
                collate: void 0
            });
        });
        const returnIndexes = [];
        const accKeys = Object.keys(acc);
        for (const accKey of accKeys){
            const columns = {};
            columns.fields = acc[accKey].fields;
            if (acc[accKey].name.match(/sys_c[0-9]*/)) {
                acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;
            }
            returnIndexes.push(acc[accKey]);
        }
        return returnIndexes;
    }
    handleInsertQuery(results, metaData) {
        if (this.instance && results.length > 0) {
            if ("pkReturnVal" in results[0]) {
                results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;
                delete results[0].pkReturnVal;
            }
            const autoIncrementField = this.model.autoIncrementAttribute;
            let autoIncrementFieldAlias = null, id = null;
            if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0) autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;
            id = id || results && results[0][this.getInsertIdField()];
            id = id || metaData && metaData[this.getInsertIdField()];
            id = id || results && results[0][autoIncrementField];
            id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];
            this.instance[autoIncrementField] = id;
        }
    }
} //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    OracleQueryGenerator: ()=>OracleQueryGenerator
});
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Transaction = __turbopack_context__.r("[project]/node_modules/sequelize/lib/transaction.js [app-route] (ecmascript)");
const ORACLE_RESERVED_WORDS = [
    "ACCESS",
    "ADD",
    "ALL",
    "ALTER",
    "AND",
    "ANY",
    "ARRAYLEN",
    "AS",
    "ASC",
    "AUDIT",
    "BETWEEN",
    "BY",
    "CHAR",
    "CHECK",
    "CLUSTER",
    "COLUMN",
    "COMMENT",
    "COMPRESS",
    "CONNECT",
    "CREATE",
    "CURRENT",
    "DATE",
    "DECIMAL",
    "DEFAULT",
    "DELETE",
    "DESC",
    "DISTINCT",
    "DROP",
    "ELSE",
    "EXCLUSIVE",
    "EXISTS",
    "FILE",
    "FLOAT",
    "FOR",
    "FROM",
    "GRANT",
    "GROUP",
    "HAVING",
    "IDENTIFIED",
    "IMMEDIATE",
    "IN",
    "INCREMENT",
    "INDEX",
    "INITIAL",
    "INSERT",
    "INTEGER",
    "INTERSECT",
    "INTO",
    "IS",
    "LEVEL",
    "LIKE",
    "LOCK",
    "LONG",
    "MAXEXTENTS",
    "MINUS",
    "MODE",
    "MODIFY",
    "NOAUDIT",
    "NOCOMPRESS",
    "NOT",
    "NOTFOUND",
    "NOWAIT",
    "NULL",
    "NUMBER",
    "OF",
    "OFFLINE",
    "ON",
    "ONLINE",
    "OPTION",
    "OR",
    "ORDER",
    "PCTFREE",
    "PRIOR",
    "PRIVILEGES",
    "PUBLIC",
    "RAW",
    "RENAME",
    "RESOURCE",
    "REVOKE",
    "ROW",
    "ROWID",
    "ROWLABEL",
    "ROWNUM",
    "ROWS",
    "SELECT",
    "SESSION",
    "SET",
    "SHARE",
    "SIZE",
    "SMALLINT",
    "SQLBUF",
    "START",
    "SUCCESSFUL",
    "SYNONYM",
    "SYSDATE",
    "TABLE",
    "THEN",
    "TO",
    "TRIGGER",
    "UID",
    "UNION",
    "UNIQUE",
    "UPDATE",
    "USER",
    "VALIDATE",
    "VALUES",
    "VARCHAR",
    "VARCHAR2",
    "VIEW",
    "WHENEVER",
    "WHERE",
    "WITH"
];
const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
class OracleQueryGenerator extends AbstractQueryGenerator {
    constructor(options){
        super(options);
    }
    getCatalogName(value) {
        if (value) {
            if (this.options.quoteIdentifiers === false) {
                const quotedValue = this.quoteIdentifier(value);
                if (quotedValue === value) {
                    value = value.toUpperCase();
                }
            }
        }
        return value;
    }
    getSchemaNameAndTableName(table) {
        const tableName = this.getCatalogName(table.tableName || table);
        const schemaName = this.getCatalogName(table.schema);
        return [
            tableName,
            schemaName
        ];
    }
    createSchema(schema) {
        const quotedSchema = this.quoteIdentifier(schema);
        return [
            "DECLARE",
            "USER_FOUND BOOLEAN := FALSE;",
            "BEGIN",
            " BEGIN",
            "   EXECUTE IMMEDIATE ",
            this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),
            ";",
            "   EXCEPTION WHEN OTHERS THEN",
            "     IF SQLCODE != -1920 THEN",
            "       RAISE;",
            "     ELSE",
            "       USER_FOUND := TRUE;",
            "     END IF;",
            " END;",
            " IF NOT USER_FOUND THEN",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT "CONNECT" TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),
            ";",
            "    EXECUTE IMMEDIATE ",
            this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),
            ";",
            " END IF;",
            "END;"
        ].join(" ");
    }
    showSchemasQuery() {
        return `SELECT USERNAME AS "schema_name" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;
    }
    dropSchema(schema) {
        return [
            "BEGIN",
            "EXECUTE IMMEDIATE ",
            this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),
            ";",
            "EXCEPTION WHEN OTHERS THEN",
            "  IF SQLCODE != -1918 THEN",
            "    RAISE;",
            "  END IF;",
            "END;"
        ].join(" ");
    }
    versionQuery() {
        return "SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'";
    }
    createTableQuery(tableName, attributes, options) {
        const primaryKeys = [], foreignKeys = Object.create(null), attrStr = [], checkStr = [];
        const values = {
            table: this.quoteTable(tableName)
        };
        for(let attr in attributes){
            if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
            const dataType = attributes[attr];
            attr = this.quoteIdentifier(attr);
            if (dataType.includes("PRIMARY KEY")) {
                primaryKeys.push(attr);
                if (dataType.includes("REFERENCES")) {
                    const match = dataType.match(/^(.+) (REFERENCES.*)$/);
                    attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, "")}`);
                    foreignKeys[attr] = match[2];
                } else {
                    attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, "").trim()}`);
                }
            } else if (dataType.includes("REFERENCES")) {
                const match = dataType.match(/^(.+) (REFERENCES.*)$/);
                attrStr.push(`${attr} ${match[1]}`);
                foreignKeys[attr] = match[2];
            } else {
                attrStr.push(`${attr} ${dataType}`);
            }
        }
        values["attributes"] = attrStr.join(", ");
        const pkString = primaryKeys.map((pk)=>this.quoteIdentifier(pk)).join(", ");
        if (pkString.length > 0) {
            values.attributes += `,PRIMARY KEY (${pkString})`;
        }
        for(const fkey in foreignKeys){
            if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;
            if (foreignKeys[fkey].indexOf("ON DELETE NO ACTION") > -1) {
                foreignKeys[fkey] = foreignKeys[fkey].replace("ON DELETE NO ACTION", "");
            }
            values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
        }
        if (checkStr.length > 0) {
            values.attributes += `, ${checkStr.join(", ")}`;
        }
        if (options && options.indexes && options.indexes.length > 0) {
            const idxToDelete = [];
            options.indexes.forEach((index, idx)=>{
                if ("unique" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {
                    const fields = index.fields.map((field)=>{
                        if (typeof field === "string") {
                            return field;
                        }
                        return field.attribute;
                    });
                    let canContinue = true;
                    if (options.uniqueKeys) {
                        const keys = Object.keys(options.uniqueKeys);
                        for(let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++){
                            const currUnique = options.uniqueKeys[keys[fieldIdx]];
                            if (currUnique.fields.length === fields.length) {
                                for(let i = 0; i < currUnique.fields.length; i++){
                                    const field = currUnique.fields[i];
                                    if (_.includes(fields, field)) {
                                        canContinue = false;
                                    } else {
                                        canContinue = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (canContinue) {
                            const indexName = "name" in index ? index.name : "";
                            const constraintToAdd = {
                                name: indexName,
                                fields
                            };
                            if (!("uniqueKeys" in options)) {
                                options.uniqueKeys = {};
                            }
                            options.uniqueKeys[indexName] = constraintToAdd;
                            idxToDelete.push(idx);
                        } else {
                            idxToDelete.push(idx);
                        }
                    }
                }
            });
            idxToDelete.forEach((idx)=>{
                options.indexes.splice(idx, 1);
            });
        }
        if (options && !!options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns, indexName)=>{
                let canBeUniq = false;
                primaryKeys.forEach((primaryKey)=>{
                    primaryKey = primaryKey.replace(/"/g, "");
                    if (!_.includes(columns.fields, primaryKey)) {
                        canBeUniq = true;
                    }
                });
                columns.fields.forEach((field)=>{
                    let currField = "";
                    if (!_.isString(field)) {
                        currField = field.attribute.replace(/[.,"\s]/g, "");
                    } else {
                        currField = field.replace(/[.,"\s]/g, "");
                    }
                    if (currField in attributes) {
                        if (attributes[currField].toUpperCase().indexOf("UNIQUE") > -1 && canBeUniq) {
                            const attrToReplace = attributes[currField].replace("UNIQUE", "");
                            values.attributes = values.attributes.replace(attributes[currField], attrToReplace);
                        }
                    }
                });
                if (canBeUniq) {
                    const index = options.uniqueKeys[columns.name];
                    delete options.uniqueKeys[columns.name];
                    indexName = indexName.replace(/[.,\s]/g, "");
                    columns.name = indexName;
                    options.uniqueKeys[indexName] = index;
                    if (indexName.length === 0) {
                        values.attributes += `,UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                    } else {
                        values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                    }
                }
            });
        }
        const query = Utils.joinSQLFragments([
            "CREATE TABLE",
            values.table,
            `(${values.attributes})`
        ]);
        return Utils.joinSQLFragments([
            "BEGIN",
            "EXECUTE IMMEDIATE",
            `${this.escape(query)};`,
            "EXCEPTION WHEN OTHERS THEN",
            "IF SQLCODE != -955 THEN",
            "RAISE;",
            "END IF;",
            "END;"
        ]);
    }
    tableExistsQuery(table) {
        const [tableName, schemaName] = this.getSchemaNameAndTableName(table);
        return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : "USER"}`;
    }
    describeTableQuery(tableName, schema) {
        const currTableName = this.getCatalogName(tableName.tableName || tableName);
        schema = this.getCatalogName(schema);
        return [
            "SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ",
            "FROM all_tab_columns atc ",
            "LEFT OUTER JOIN ",
            "(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ",
            "ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ",
            schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : "WHERE atc.OWNER = USER ",
            `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,
            "ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC"
        ].join("");
    }
    renameTableQuery(before, after) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(before),
            "RENAME TO",
            this.quoteTable(after)
        ]);
    }
    showConstraintsQuery(table) {
        const tableName = this.getCatalogName(table.tableName || table);
        return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;
    }
    showTablesQuery() {
        return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS "schema_name" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;
    }
    dropTableQuery(tableName) {
        return Utils.joinSQLFragments([
            "BEGIN ",
            "EXECUTE IMMEDIATE 'DROP TABLE",
            this.quoteTable(tableName),
            "CASCADE CONSTRAINTS PURGE';",
            "EXCEPTION WHEN OTHERS THEN",
            " IF SQLCODE != -942 THEN",
            "   RAISE;",
            " END IF;",
            "END;"
        ]);
    }
    addIndexQuery(tableName, attributes, options, rawTablename) {
        if (typeof tableName !== "string" && attributes.name) {
            attributes.name = `${tableName.schema}.${attributes.name}`;
        }
        return super.addIndexQuery(tableName, attributes, options, rawTablename);
    }
    addConstraintQuery(tableName, options) {
        options = options || {};
        if (options.onUpdate) {
            delete options.onUpdate;
        }
        if (options.onDelete && options.onDelete.toUpperCase() === "NO ACTION") {
            delete options.onDelete;
        }
        const constraintSnippet = this.getConstraintSnippet(tableName, options);
        tableName = this.quoteTable(tableName);
        return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;
    }
    addColumnQuery(table, key, dataType) {
        dataType.field = key;
        const attribute = Utils.joinSQLFragments([
            this.quoteIdentifier(key),
            this.attributeToSQL(dataType, {
                attributeName: key,
                context: "addColumn"
            })
        ]);
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(table),
            "ADD",
            attribute
        ]);
    }
    removeColumnQuery(tableName, attributeName) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP COLUMN",
            this.quoteIdentifier(attributeName),
            ";"
        ]);
    }
    _alterForeignKeyConstraint(definition, table, attributeName) {
        const [tableName, schemaName] = this.getSchemaNameAndTableName(table);
        const attributeNameConstant = this.escape(this.getCatalogName(attributeName));
        const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : "USER";
        const tableNameConstant = this.escape(this.getCatalogName(tableName));
        const getConsNameQuery = [
            "SELECT constraint_name INTO cons_name",
            "FROM (",
            "  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns",
            "  FROM all_cons_columns cc, all_constraints c",
            "  WHERE cc.owner = c.owner",
            "  AND cc.table_name = c.table_name",
            "  AND cc.constraint_name = c.constraint_name",
            "  AND c.constraint_type = 'R'",
            "  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name",
            ")",
            "WHERE owner =",
            schemaNameConstant,
            "AND table_name =",
            tableNameConstant,
            "AND cons_columns =",
            attributeNameConstant,
            ";"
        ].join(" ");
        const secondQuery = Utils.joinSQLFragments([
            `ALTER TABLE ${this.quoteIdentifier(tableName)}`,
            "ADD FOREIGN KEY",
            `(${this.quoteIdentifier(attributeName)})`,
            definition.replace(/.+?(?=REFERENCES)/, "")
        ]);
        return [
            "BEGIN",
            getConsNameQuery,
            "EXCEPTION",
            "WHEN NO_DATA_FOUND THEN",
            " CONS_NAME := NULL;",
            "END;",
            "IF CONS_NAME IS NOT NULL THEN",
            ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT "'||CONS_NAME||'"';`,
            "END IF;",
            `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`
        ].join(" ");
    }
    _modifyQuery(definition, table, attributeName) {
        definition = definition.startsWith("BLOB") ? definition.replace("BLOB ", "") : definition;
        const query = Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(table),
            "MODIFY",
            this.quoteIdentifier(attributeName),
            definition
        ]);
        const secondQuery = query.replace("NOT NULL", "").replace("NULL", "");
        return [
            "BEGIN",
            `EXECUTE IMMEDIATE ${this.escape(query)};`,
            "EXCEPTION",
            "WHEN OTHERS THEN",
            " IF SQLCODE = -1442 OR SQLCODE = -1451 THEN",
            `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,
            " ELSE",
            "   RAISE;",
            " END IF;",
            "END;"
        ].join(" ");
    }
    changeColumnQuery(table, attributes) {
        const sql = [
            "DECLARE",
            "CONS_NAME VARCHAR2(200);",
            "BEGIN"
        ];
        for(const attributeName in attributes){
            if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;
            const definition = attributes[attributeName];
            if (definition.match(/REFERENCES/)) {
                sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));
            } else {
                sql.push(this._modifyQuery(definition, table, attributeName));
            }
        }
        sql.push("END;");
        return sql.join(" ");
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const newName = Object.keys(attributes)[0];
        return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;
    }
    populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {
        const oracledb = this.sequelize.connectionManager.lib;
        const outBindAttributes = Object.create(null);
        const outbind = [];
        const outbindParam = this.bindParam(outbind, inbindLength);
        returningModelAttributes.forEach((element, index)=>{
            if (element.startsWith('"')) {
                element = element.substring(1, element.length - 1);
            }
            outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {
                dir: oracledb.BIND_OUT
            });
            const returnAttribute = `${this.format(void 0, void 0, {
                context: "INSERT"
            }, outbindParam)}`;
            returnAttributes.push(returnAttribute);
        });
        options.outBindAttributes = outBindAttributes;
    }
    upsertQuery(tableName, insertValues, updateValues, where, model, options) {
        const rawAttributes = model.rawAttributes;
        const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);
        options.bind = updateQuery.bind;
        const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);
        const sql = [
            "DECLARE ",
            "BEGIN ",
            updateQuery.query ? [
                updateQuery.query,
                "; ",
                " IF ( SQL%ROWCOUNT = 0 ) THEN ",
                insertQuery.query,
                " :isUpdate := 0; ",
                "ELSE ",
                " :isUpdate := 1; ",
                " END IF; "
            ].join("") : [
                insertQuery.query,
                " :isUpdate := 0; ",
                "EXCEPTION WHEN OTHERS THEN",
                " IF SQLCODE != -1 THEN",
                "   RAISE;",
                " END IF;"
            ].join(""),
            "END;"
        ];
        const query = sql.join("");
        const result = {
            query
        };
        if (options.bindParam !== false) {
            result.bind = updateQuery.bind || insertQuery.bind;
        }
        return result;
    }
    bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
        options = options || {};
        options.executeMany = true;
        fieldMappedAttributes = fieldMappedAttributes || {};
        const tuples = [];
        const allColumns = {};
        const inBindBindDefMap = {};
        const outBindBindDefMap = {};
        const oracledb = this.sequelize.connectionManager.lib;
        for (const fieldValueHash of fieldValueHashes){
            _.forOwn(fieldValueHash, (value, key)=>{
                allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;
            });
        }
        let inBindPosition;
        for (const fieldValueHash of fieldValueHashes){
            const tuple = [];
            const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;
            const tempBindPositions = Object.keys(allColumns).map((key)=>{
                if (allColumns[key] === true) {
                    if (fieldValueHash[key] !== null) {
                        throw Error("For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!");
                    }
                    return "DEFAULT";
                }
                return this.format(fieldValueHash[key], fieldMappedAttributes[key], {
                    context: "INSERT"
                }, inbindParam);
            });
            if (!inBindPosition) {
                inBindPosition = tempBindPositions;
            }
            tuples.push(tuple);
        }
        const returnColumn = [];
        const returnColumnBindPositions = [];
        const insertColumns = [];
        for (const key of Object.keys(allColumns)){
            if (fieldMappedAttributes[key]) {
                const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);
                if (allColumns[key]) {
                    bindDef.dir = oracledb.BIND_OUT;
                    outBindBindDefMap[key] = bindDef;
                    returnColumn.push(this.quoteIdentifier(key));
                    returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);
                } else {
                    bindDef.dir = oracledb.BIND_IN;
                    inBindBindDefMap[key] = bindDef;
                }
            }
            insertColumns.push(this.quoteIdentifier(key));
        }
        let query = Utils.joinSQLFragments([
            "INSERT",
            "INTO",
            this.quoteTable(tableName),
            `(${insertColumns.join(",")})`,
            "VALUES",
            `(${inBindPosition})`
        ]);
        if (returnColumn.length > 0) {
            options.outBindAttributes = outBindBindDefMap;
            query = Utils.joinSQLFragments([
                query,
                "RETURNING",
                `${returnColumn.join(",")}`,
                "INTO",
                `${returnColumnBindPositions}`
            ]);
        }
        const result = {
            query
        };
        result.bind = tuples;
        options.inbindAttributes = inBindBindDefMap;
        return result;
    }
    truncateTableQuery(tableName) {
        return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
    }
    deleteQuery(tableName, where, options, model) {
        options = options || {};
        const table = tableName;
        where = this.getWhereConditions(where, null, model, options);
        let queryTmpl;
        if (options.limit) {
            const whereTmpl = where ? ` AND ${where}` : "";
            queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;
        } else {
            const whereTmpl = where ? ` WHERE ${where}` : "";
            queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;
        }
        return queryTmpl;
    }
    showIndexesQuery(table) {
        const [tableName, owner] = this.getSchemaNameAndTableName(table);
        const sql = [
            "SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ",
            "FROM all_ind_columns i ",
            "INNER JOIN all_indexes u ",
            "ON (u.table_name = i.table_name AND u.index_name = i.index_name) ",
            "LEFT OUTER JOIN all_constraints c ",
            "ON (c.table_name = i.table_name AND c.index_name = i.index_name) ",
            `WHERE i.table_name = ${this.escape(tableName)}`,
            " AND u.table_owner = ",
            owner ? this.escape(owner) : "USER",
            " ORDER BY index_name, column_position"
        ];
        return sql.join("");
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return `DROP INDEX ${this.quoteIdentifier(indexName)}`;
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        attribute.onUpdate = "";
        if (attribute.references) {
            if (attribute.Model && attribute.Model.tableName === attribute.references.model) {
                this.sequelize.log("Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query");
                attribute.onDelete = "";
            }
        }
        let template;
        template = attribute.type.toSql ? attribute.type.toSql() : "";
        if (attribute.type instanceof DataTypes.JSON) {
            template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;
            return template;
        }
        if (Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
        }
        if (attribute.allowNull === false) {
            template += " NOT NULL";
        }
        if (attribute.type instanceof DataTypes.ENUM) {
            if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
            template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, (value)=>{
                return this.escape(value);
            }).join(", ")}))`;
            return template;
        }
        if (attribute.type instanceof DataTypes.BOOLEAN) {
            template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;
            return template;
        }
        if (attribute.autoIncrement) {
            template = " NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY";
        } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {
            template = attribute.type.toSql();
        } else if (attribute.type) {
            let unsignedTemplate = "";
            if (attribute.type._unsigned) {
                attribute.type._unsigned = false;
                unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;
            }
            template = attribute.type.toString();
            if (attribute.type && attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
                template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
            }
            if (!attribute.autoIncrement) {
                if (attribute.allowNull === false) {
                    template += " NOT NULL";
                } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {
                    template += " NULL";
                }
            }
            template += unsignedTemplate;
        } else {
            template = "";
        }
        if (attribute.unique === true && !attribute.primaryKey) {
            template += " UNIQUE";
        }
        if (attribute.primaryKey) {
            template += " PRIMARY KEY";
        }
        if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
            template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
            if (attribute.references.key) {
                template += ` (${this.quoteIdentifier(attribute.references.key)})`;
            } else {
                template += ` (${this.quoteIdentifier("id")})`;
            }
            if (attribute.onDelete && attribute.onDelete.toUpperCase() !== "NO ACTION") {
                template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
            }
        }
        return template;
    }
    attributesToSQL(attributes, options) {
        const result = {};
        for(const key in attributes){
            const attribute = attributes[key];
            const attributeName = attribute.field || key;
            result[attributeName] = this.attributeToSQL(attribute, __spreadValues({
                attributeName
            }, options));
        }
        return result;
    }
    createTrigger() {
        throwMethodUndefined("createTrigger");
    }
    dropTrigger() {
        throwMethodUndefined("dropTrigger");
    }
    renameTrigger() {
        throwMethodUndefined("renameTrigger");
    }
    createFunction() {
        throwMethodUndefined("createFunction");
    }
    dropFunction() {
        throwMethodUndefined("dropFunction");
    }
    renameFunction() {
        throwMethodUndefined("renameFunction");
    }
    getConstraintsOnColumn(table, column) {
        const [tableName, schemaName] = this.getSchemaNameAndTableName(table);
        column = this.getCatalogName(column);
        const sql = [
            "SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ",
            this.escape(tableName),
            " and OWNER = ",
            table.schema ? this.escape(schemaName) : "USER",
            " and COLUMN_NAME = ",
            this.escape(column),
            " AND POSITION IS NOT NULL ORDER BY POSITION"
        ].join("");
        return sql;
    }
    getForeignKeysQuery(table) {
        const [tableName, schemaName] = this.getSchemaNameAndTableName(table);
        const sql = [
            'SELECT DISTINCT  a.table_name "tableName", a.constraint_name "constraintName", a.owner "owner",  a.column_name "columnName",',
            ' b.table_name "referencedTableName", b.column_name "referencedColumnName"',
            " FROM all_cons_columns a",
            " JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name",
            " JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name",
            " WHERE c.constraint_type  = 'R'",
            " AND a.table_name = ",
            this.escape(tableName),
            " AND a.owner = ",
            table.schema ? this.escape(schemaName) : "USER",
            " ORDER BY a.table_name, a.constraint_name"
        ].join("");
        return sql;
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return this.dropConstraintQuery(tableName, foreignKey);
    }
    getPrimaryKeyConstraintQuery(table) {
        const [tableName, schemaName] = this.getSchemaNameAndTableName(table);
        const sql = [
            "SELECT cols.column_name, atc.identity_column ",
            "FROM all_constraints cons, all_cons_columns cols ",
            "INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )",
            "WHERE cols.table_name = ",
            this.escape(tableName),
            "AND cols.owner = ",
            table.schema ? this.escape(schemaName) : "USER ",
            "AND cons.constraint_type = 'P' ",
            "AND cons.constraint_name = cols.constraint_name ",
            "AND cons.owner = cols.owner ",
            "ORDER BY cols.table_name, cols.position"
        ].join("");
        return sql;
    }
    dropConstraintQuery(tableName, constraintName) {
        return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;
    }
    setIsolationLevelQuery(value, options) {
        if (options.parent) {
            return;
        }
        switch(value){
            case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
            case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
                return "SET TRANSACTION ISOLATION LEVEL READ COMMITTED;";
            case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
                return "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;";
            default:
                throw new Error(`isolation level "${value}" is not supported`);
        }
    }
    getAliasToken() {
        return "";
    }
    startTransactionQuery(transaction) {
        if (transaction.parent) {
            return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;
        }
        return "BEGIN TRANSACTION";
    }
    commitTransactionQuery(transaction) {
        if (transaction.parent) {
            return;
        }
        return "COMMIT TRANSACTION";
    }
    rollbackTransactionQuery(transaction) {
        if (transaction.parent) {
            return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;
        }
        return "ROLLBACK TRANSACTION";
    }
    handleSequelizeMethod(smth, tableName, factory, options, prepend) {
        let str;
        if (smth instanceof Utils.Json) {
            if (smth.conditions) {
                const conditions = this.parseConditionObject(smth.conditions).map((condition)=>`${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);
                return conditions.join(" AND ");
            }
            if (smth.path) {
                if (this._checkValidJsonStatement(smth.path)) {
                    str = smth.path;
                } else {
                    const paths = _.toPath(smth.path);
                    const column = paths.shift();
                    str = this.jsonPathExtractionQuery(column, paths);
                }
                if (smth.value) {
                    str += util.format(" = %s", this.escape(smth.value));
                }
                return str;
            }
        }
        if (smth instanceof Utils.Cast) {
            if (smth.val instanceof Utils.SequelizeMethod) {
                str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);
                if (smth.type === "boolean") {
                    str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;
                    return `CAST(${str} AS NUMBER)`;
                }
                if (smth.type === "timestamptz" && /json_value\(/.test(str)) {
                    str = str.slice(0, -1);
                    return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;
                }
            }
        }
        return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
    }
    _checkValidJsonStatement(stmt) {
        if (typeof stmt !== "string") {
            return false;
        }
        let currentIndex = 0;
        let openingBrackets = 0;
        let closingBrackets = 0;
        let hasJsonFunction = false;
        let hasInvalidToken = false;
        while(currentIndex < stmt.length){
            const string = stmt.substr(currentIndex);
            const functionMatches = JSON_FUNCTION_REGEX.exec(string);
            if (functionMatches) {
                currentIndex += functionMatches[0].indexOf("(");
                hasJsonFunction = true;
                continue;
            }
            const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
            if (operatorMatches) {
                currentIndex += operatorMatches[0].length;
                hasJsonFunction = true;
                continue;
            }
            const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
            if (tokenMatches) {
                const capturedToken = tokenMatches[1];
                if (capturedToken === "(") {
                    openingBrackets++;
                } else if (capturedToken === ")") {
                    closingBrackets++;
                } else if (capturedToken === ";") {
                    hasInvalidToken = true;
                    break;
                }
                currentIndex += tokenMatches[0].length;
                continue;
            }
            break;
        }
        if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
            throw new Error(`Invalid json statement: ${stmt}`);
        }
        return hasJsonFunction;
    }
    jsonPathExtractionQuery(column, path) {
        let paths = _.toPath(path);
        const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);
        paths = paths.map((subPath)=>{
            return /\D/.test(subPath) ? Utils.addTicks(subPath, '"') : subPath;
        });
        const pathStr = this.escape([
            "$"
        ].concat(paths).join(".").replace(/\.(\d+)(?:(?=\.)|$)/g, (__, digit)=>`[${digit}]`));
        return `json_value(${quotedColumn},${pathStr})`;
    }
    addLimitAndOffset(options, model) {
        let fragment = "";
        const offset = options.offset || 0, isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
        let orders = {};
        if (options.order) {
            orders = this.getQueryOrders(options, model, isSubQuery);
        }
        if (options.limit || options.offset) {
            if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {
                const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;
                fragment += ` ORDER BY ${tablePkFragment}`;
            }
            if (options.offset || options.limit) {
                fragment += ` OFFSET ${this.escape(offset)} ROWS`;
            }
            if (options.limit) {
                fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
            }
        }
        return fragment;
    }
    booleanValue(value) {
        return value ? 1 : 0;
    }
    quoteIdentifier(identifier, force = false) {
        const optForceQuote = force;
        const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
        const rawIdentifier = Utils.removeTicks(identifier, '"');
        const regExp = /^(([\w][\w\d_]*))$/g;
        if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {
            return rawIdentifier;
        }
        return Utils.addTicks(rawIdentifier, '"');
    }
    bindParam(bind, posOffset = 0) {
        return (value)=>{
            bind.push(value);
            return `:${bind.length + posOffset}`;
        };
    }
    authTestQuery() {
        return "SELECT 1+1 AS result FROM DUAL";
    }
}
function throwMethodUndefined(methodName) {
    throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
} //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
__export(exports, {
    OracleQueryInterface: ()=>OracleQueryInterface
});
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
class OracleQueryInterface extends QueryInterface {
    async upsert(tableName, insertValues, updateValues, where, options) {
        options = __spreadValues({}, options);
        const model = options.model;
        const primaryKeys = Object.values(model.primaryKeys).map((item)=>item.field);
        const uniqueKeys = Object.values(model.uniqueKeys).filter((c)=>c.fields.length > 0).map((c)=>c.fields);
        const indexKeys = Object.values(model._indexes).filter((c)=>c.unique && c.fields.length > 0).map((c)=>c.fields);
        options.type = QueryTypes.UPSERT;
        options.updateOnDuplicate = Object.keys(updateValues);
        options.upsertKeys = [];
        for (const field of options.updateOnDuplicate){
            const uniqueKey = uniqueKeys.find((fields)=>fields.includes(field));
            if (uniqueKey) {
                options.upsertKeys = uniqueKey;
                break;
            }
            const indexKey = indexKeys.find((fields)=>fields.includes(field));
            if (indexKey) {
                options.upsertKeys = indexKey;
                break;
            }
        }
        if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {
            options.upsertKeys = primaryKeys;
        }
        options.upsertKeys = _.uniq(options.upsertKeys);
        let whereHasNull = false;
        primaryKeys.forEach((element)=>{
            if (where[element] === null) {
                whereHasNull = true;
            }
        });
        if (whereHasNull === true) {
            where = options.upsertKeys.reduce((result, attribute)=>{
                result[attribute] = insertValues[attribute];
                return result;
            }, {});
        }
        const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
        if (sql.bind) {
            options.bind = void 0;
        }
        return await this.sequelize.query(sql, options);
    }
} //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/oracle/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { AbstractDialect } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const { OracleConnectionManager } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/connection-manager.js [app-route] (ecmascript)");
const { OracleQuery } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/query.js [app-route] (ecmascript)");
const { OracleQueryGenerator } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").oracle;
const { OracleQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/query-interface.js [app-route] (ecmascript)");
class OracleDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new OracleConnectionManager(this, sequelize);
        this.connectionManager.initPools();
        this.queryGenerator = new OracleQueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new OracleQueryInterface(sequelize, this.queryGenerator);
    }
}
OracleDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "VALUES ()": true,
    "LIMIT ON UPDATE": true,
    IGNORE: " IGNORE",
    lock: true,
    lockOuterJoinFailure: true,
    forShare: "FOR UPDATE",
    skipLocked: true,
    index: {
        collate: false,
        length: false,
        parser: false,
        type: false,
        using: false
    },
    constraints: {
        restrict: false
    },
    returnValues: false,
    returnIntoValues: true,
    "ORDER NULLS": true,
    schemas: true,
    updateOnDuplicate: false,
    indexViaAlter: false,
    NUMERIC: true,
    JSON: true,
    upserts: true,
    bulkDefault: true,
    topLevelOrderByRequired: true,
    GEOMETRY: false
});
OracleDialect.prototype.defaultVersion = "18.0.0";
OracleDialect.prototype.Query = OracleQuery;
OracleDialect.prototype.queryGenerator = OracleQueryGenerator;
OracleDialect.prototype.DataTypes = DataTypes;
OracleDialect.prototype.name = "oracle";
OracleDialect.prototype.TICK_CHAR = '"';
OracleDialect.prototype.TICK_CHAR_LEFT = OracleDialect.prototype.TICK_CHAR;
OracleDialect.prototype.TICK_CHAR_RIGHT = OracleDialect.prototype.TICK_CHAR;
module.exports = OracleDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("connection:pg");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const dataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const momentTz = __turbopack_context__.r("[project]/node_modules/moment-timezone/index.js [app-route] (ecmascript)");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 5432;
        super(dialect, sequelize);
        const pgLib = this._loadDialectModule("pg");
        this.lib = this.sequelize.config.native ? pgLib.native : pgLib;
        this._clearDynamicOIDs();
        this._clearTypeParser();
        this.refreshTypeParser(dataTypes.postgres);
    }
    _refreshTypeParser(dataType) {
        const arrayParserBuilder = (parser2)=>{
            return (value)=>this.lib.types.arrayParser.create(value, parser2).parse();
        };
        const rangeParserBuilder = (parser2)=>{
            return (value)=>dataType.parse(value, {
                    parser: parser2
                });
        };
        if (dataType.key.toLowerCase() === "range") {
            for(const name in this.nameOidMap){
                const entry = this.nameOidMap[name];
                if (!entry.rangeOid) continue;
                const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));
                const arrayRangeParser = arrayParserBuilder(rangeParser);
                this.oidParserMap.set(entry.rangeOid, rangeParser);
                if (!entry.arrayRangeOid) continue;
                this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);
            }
            return;
        }
        const parser = (value)=>dataType.parse(value);
        const arrayParser = arrayParserBuilder(parser);
        if (dataType.key.toLowerCase() === "enum") {
            this.enumOids.oids.forEach((oid)=>{
                this.oidParserMap.set(oid, parser);
            });
            this.enumOids.arrayOids.forEach((arrayOid)=>{
                this.oidParserMap.set(arrayOid, arrayParser);
            });
            return;
        }
        dataType.types.postgres.forEach((name)=>{
            if (!this.nameOidMap[name]) return;
            this.oidParserMap.set(this.nameOidMap[name].oid, parser);
            if (!this.nameOidMap[name].arrayOid) return;
            this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);
        });
    }
    _clearTypeParser() {
        this.oidParserMap = /* @__PURE__ */ new Map();
    }
    getTypeParser(oid, ...args) {
        if (this.oidParserMap.get(oid)) return this.oidParserMap.get(oid);
        return this.lib.types.getTypeParser(oid, ...args);
    }
    async connect(config) {
        config.user = config.username;
        const connectionConfig = _.pick(config, [
            "user",
            "password",
            "host",
            "database",
            "port"
        ]);
        connectionConfig.types = {
            getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)
        };
        if (config.dialectOptions) {
            _.merge(connectionConfig, _.pick(config.dialectOptions, [
                "application_name",
                "ssl",
                "client_encoding",
                "binary",
                "keepAlive",
                "statement_timeout",
                "query_timeout",
                "connectionTimeoutMillis",
                "idle_in_transaction_session_timeout",
                "lock_timeout",
                "options",
                "stream"
            ]));
        }
        const connection = await new Promise((resolve, reject)=>{
            let responded = false;
            const connection2 = new this.lib.Client(connectionConfig);
            const parameterHandler = (message)=>{
                switch(message.parameterName){
                    case "server_version":
                        if (this.sequelize.options.databaseVersion === 0) {
                            const version = semver.coerce(message.parameterValue).version;
                            this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;
                        }
                        break;
                    case "standard_conforming_strings":
                        connection2["standard_conforming_strings"] = message.parameterValue;
                        break;
                }
            };
            const endHandler = ()=>{
                debug("connection timeout");
                if (!responded) {
                    reject(new sequelizeErrors.ConnectionTimedOutError(new Error("Connection timed out")));
                }
            };
            connection2.once("end", endHandler);
            if (!this.sequelize.config.native) {
                connection2.connection.on("parameterStatus", parameterHandler);
            }
            connection2.connect((err)=>{
                responded = true;
                if (!this.sequelize.config.native) {
                    connection2.connection.removeListener("parameterStatus", parameterHandler);
                }
                if (err) {
                    if (err.code) {
                        switch(err.code){
                            case "ECONNREFUSED":
                                reject(new sequelizeErrors.ConnectionRefusedError(err));
                                break;
                            case "ENOTFOUND":
                                reject(new sequelizeErrors.HostNotFoundError(err));
                                break;
                            case "EHOSTUNREACH":
                                reject(new sequelizeErrors.HostNotReachableError(err));
                                break;
                            case "EINVAL":
                                reject(new sequelizeErrors.InvalidConnectionError(err));
                                break;
                            default:
                                reject(new sequelizeErrors.ConnectionError(err));
                                break;
                        }
                    } else {
                        reject(new sequelizeErrors.ConnectionError(err));
                    }
                } else {
                    debug("connection acquired");
                    connection2.removeListener("end", endHandler);
                    resolve(connection2);
                }
            });
        });
        connection.on("error", (error)=>{
            connection._invalid = true;
            debug(`connection error ${error.code || error.message}`);
            this.pool.destroy(connection);
        });
        let query = "";
        if (this.sequelize.options.standardConformingStrings !== false && connection["standard_conforming_strings"] !== "on") {
            query += "SET standard_conforming_strings=on;";
        }
        if (this.sequelize.options.clientMinMessages !== void 0) {
            console.warn('Usage of "options.clientMinMessages" is deprecated and will be removed in v7.');
            console.warn('Please use the sequelize option "dialectOptions.clientMinMessages" instead.');
        }
        if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === "ignore" || this.sequelize.options.clientMinMessages === false)) {
            const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || "warning";
            query += `SET client_min_messages TO ${clientMinMessages};`;
        }
        if (!this.sequelize.config.keepDefaultTimezone) {
            const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);
            if (isZone) {
                query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;
            } else {
                query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;
            }
        }
        if (query) {
            await connection.query(query);
        }
        if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {
            await this._refreshDynamicOIDs(connection);
        }
        return connection;
    }
    async disconnect(connection) {
        if (connection._ending) {
            debug("connection tried to disconnect but was already at ENDING state");
            return;
        }
        return await promisify((callback)=>connection.end(callback))();
    }
    validate(connection) {
        return !connection._invalid && !connection._ending;
    }
    async _refreshDynamicOIDs(connection) {
        const databaseVersion = this.sequelize.options.databaseVersion;
        const supportedVersion = "8.3.0";
        if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {
            return;
        }
        const results = await (connection || this.sequelize).query("WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));");
        let result = Array.isArray(results) ? results.pop() : results;
        if (Array.isArray(result)) {
            if (result[0].command === "SET") {
                result = result.pop();
            }
        }
        const newNameOidMap = {};
        const newEnumOids = {
            oids: [],
            arrayOids: []
        };
        for (const row of result.rows){
            if (row.typtype === "e") {
                newEnumOids.oids.push(row.oid);
                if (row.typarray) newEnumOids.arrayOids.push(row.typarray);
                continue;
            }
            newNameOidMap[row.typname] = {
                oid: row.oid
            };
            if (row.typarray) newNameOidMap[row.typname].arrayOid = row.typarray;
            if (row.rngtypid) {
                newNameOidMap[row.typname].rangeOid = row.rngtypid;
                if (row.rngtyparray) newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;
            }
        }
        this.nameOidMap = newNameOidMap;
        this.enumOids = newEnumOids;
        this.refreshTypeParser(dataTypes.postgres);
    }
    _clearDynamicOIDs() {
        this.nameOidMap = {};
        this.enumOids = {
            oids: [],
            arrayOids: []
        };
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("sql:pg");
class Query extends AbstractQuery {
    static formatBindParameters(sql, values, dialect) {
        const stringReplaceFunc = (value)=>typeof value === "string" ? value.replace(/\0/g, "\\0") : value;
        let bindParam;
        if (Array.isArray(values)) {
            bindParam = values.map(stringReplaceFunc);
            sql = AbstractQuery.formatBindParameters(sql, values, dialect, {
                skipValueReplace: true
            })[0];
        } else {
            bindParam = [];
            let i = 0;
            const seen = {};
            const replacementFunc = (match, key, values2)=>{
                if (seen[key] !== void 0) {
                    return seen[key];
                }
                if (values2[key] !== void 0) {
                    i = i + 1;
                    bindParam.push(stringReplaceFunc(values2[key]));
                    seen[key] = `$${i}`;
                    return `$${i}`;
                }
                return void 0;
            };
            sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        }
        return [
            sql,
            bindParam
        ];
    }
    async run(sql, parameters) {
        const { connection } = this;
        if (!_.isEmpty(this.options.searchPath)) {
            sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;
        }
        if (this.sequelize.options.minifyAliases && this.options.includeAliases) {
            _.toPairs(this.options.includeAliases).sort((a, b)=>b[1].length - a[1].length).forEach(([alias, original])=>{
                const reg = new RegExp(_.escapeRegExp(original), "g");
                sql = sql.replace(reg, alias);
            });
        }
        this.sql = sql;
        const query = parameters && parameters.length ? new Promise((resolve, reject)=>connection.query(sql, parameters, (error, result)=>error ? reject(error) : resolve(result))) : new Promise((resolve, reject)=>connection.query(sql, (error, result)=>error ? reject(error) : resolve(result)));
        const complete = this._logQuery(sql, debug, parameters);
        let queryResult;
        const errForStack = new Error();
        try {
            queryResult = await query;
        } catch (error) {
            if (error.code === "ECONNRESET" || /Unable to set non-blocking to true/i.test(error) || /SSL SYSCALL error: EOF detected/i.test(error) || /Local: Authentication failure/i.test(error) || error.message === "Query read timeout") {
                connection._invalid = true;
            }
            error.sql = sql;
            error.parameters = parameters;
            throw this.formatError(error, errForStack.stack);
        }
        complete();
        let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r)=>allRows.concat(r.rows || []), []) : queryResult.rows;
        const rowCount = Array.isArray(queryResult) ? queryResult.reduce((count, r)=>Number.isFinite(r.rowCount) ? count + r.rowCount : count, 0) : queryResult.rowCount || 0;
        if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {
            rows = rows.map((row)=>_.toPairs(row).reduce((acc, [key, value])=>{
                    const mapping = this.options.aliasesMapping.get(key);
                    acc[mapping || key] = value;
                    return acc;
                }, {}));
        }
        const isTableNameQuery = sql.startsWith("SELECT table_name FROM information_schema.tables");
        const isRelNameQuery = sql.startsWith("SELECT relname FROM pg_class WHERE oid IN");
        if (isRelNameQuery) {
            return rows.map((row)=>({
                    name: row.relname,
                    tableName: row.relname.split("_")[0]
                }));
        }
        if (isTableNameQuery) {
            return rows.map((row)=>Object.values(row));
        }
        if (rows[0] && rows[0].sequelize_caught_exception !== void 0) {
            if (rows[0].sequelize_caught_exception !== null) {
                throw this.formatError({
                    sql,
                    parameters,
                    code: "23505",
                    detail: rows[0].sequelize_caught_exception
                });
            }
            for (const row of rows){
                delete row.sequelize_caught_exception;
            }
        }
        if (this.isShowIndexesQuery()) {
            for (const row of rows){
                const attributes = /ON .*? (?:USING .*?\s)?\(([^]*)\)/gi.exec(row.definition)[1].split(",");
                const columns = _.zipObject(row.column_indexes, this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names));
                delete row.column_indexes;
                delete row.column_names;
                let field;
                let attribute;
                row.fields = row.indkey.split(" ").map((indKey, index)=>{
                    field = columns[indKey];
                    if (!field) {
                        return null;
                    }
                    attribute = attributes[index];
                    return {
                        attribute: field,
                        collate: attribute.match(/COLLATE "(.*?)"/) ? /COLLATE "(.*?)"/.exec(attribute)[1] : void 0,
                        order: attribute.includes("DESC") ? "DESC" : attribute.includes("ASC") ? "ASC" : void 0,
                        length: void 0
                    };
                }).filter((n)=>n !== null);
                delete row.columns;
            }
            return rows;
        }
        if (this.isForeignKeysQuery()) {
            const result = [];
            for (const row of rows){
                let defParts;
                if (row.condef !== void 0 && (defParts = row.condef.match(/FOREIGN KEY \((.+)\) REFERENCES (.+)\((.+)\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {
                    row.id = row.constraint_name;
                    row.table = defParts[2];
                    row.from = defParts[1];
                    row.to = defParts[3];
                    let i;
                    for(i = 5; i <= 8; i += 3){
                        if (/(UPDATE|DELETE)/.test(defParts[i])) {
                            row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];
                        }
                    }
                }
                result.push(row);
            }
            return result;
        }
        if (this.isSelectQuery()) {
            let result = rows;
            if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
                const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k)=>{
                    m[k.toLowerCase()] = k;
                    return m;
                }, {});
                result = rows.map((row)=>{
                    return _.mapKeys(row, (value, key)=>{
                        const targetAttr = attrsMap[key];
                        if (typeof targetAttr === "string" && targetAttr !== key) {
                            return targetAttr;
                        }
                        return key;
                    });
                });
            }
            return this.handleSelectQuery(result);
        }
        if (QueryTypes.DESCRIBE === this.options.type) {
            const result = {};
            for (const row of rows){
                result[row.Field] = {
                    type: row.Type.toUpperCase(),
                    allowNull: row.Null === "YES",
                    defaultValue: row.Default,
                    comment: row.Comment,
                    special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],
                    primaryKey: row.Constraint === "PRIMARY KEY"
                };
                if (result[row.Field].type === "BOOLEAN") {
                    result[row.Field].defaultValue = ({
                        "false": false,
                        "true": true
                    })[result[row.Field].defaultValue];
                    if (result[row.Field].defaultValue === void 0) {
                        result[row.Field].defaultValue = null;
                    }
                }
                if (typeof result[row.Field].defaultValue === "string") {
                    result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, "");
                    if (result[row.Field].defaultValue.includes("::")) {
                        const split = result[row.Field].defaultValue.split("::");
                        if (split[1].toLowerCase() !== "regclass)") {
                            result[row.Field].defaultValue = split[0];
                        }
                    }
                }
            }
            return result;
        }
        if (this.isVersionQuery()) {
            return rows[0].server_version;
        }
        if (this.isShowOrDescribeQuery()) {
            return rows;
        }
        if (QueryTypes.BULKUPDATE === this.options.type) {
            if (!this.options.returning) {
                return parseInt(rowCount, 10);
            }
            return this.handleSelectQuery(rows);
        }
        if (QueryTypes.BULKDELETE === this.options.type) {
            return parseInt(rowCount, 10);
        }
        if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
            if (this.instance && this.instance.dataValues) {
                if (this.isInsertQuery() && !this.isUpsertQuery() && rowCount === 0) {
                    throw new sequelizeErrors.EmptyResultError();
                }
                for(const key in rows[0]){
                    if (Object.prototype.hasOwnProperty.call(rows[0], key)) {
                        const record = rows[0][key];
                        const attr = _.find(this.model.rawAttributes, (attribute)=>attribute.fieldName === key || attribute.field === key);
                        this.instance.dataValues[attr && attr.fieldName || key] = record;
                    }
                }
            }
            if (this.isUpsertQuery()) {
                return [
                    this.instance,
                    null
                ];
            }
            return [
                this.instance || rows && (this.options.plain && rows[0] || rows) || void 0,
                rowCount
            ];
        }
        if (this.isRawQuery()) {
            return [
                rows,
                queryResult
            ];
        }
        return rows;
    }
    formatError(err, errStack) {
        let match;
        let table;
        let index;
        let fields;
        let errors;
        let message;
        const code = err.code || err.sqlState;
        const errMessage = err.message || err.messagePrimary;
        const errDetail = err.detail || err.messageDetail;
        switch(code){
            case "23503":
                index = errMessage.match(/violates foreign key constraint "(.+?)"/);
                index = index ? index[1] : void 0;
                table = errMessage.match(/on table "(.+?)"/);
                table = table ? table[1] : void 0;
                return new sequelizeErrors.ForeignKeyConstraintError({
                    message: errMessage,
                    fields: null,
                    index,
                    table,
                    parent: err,
                    stack: errStack
                });
            case "23505":
                if (errDetail && (match = errDetail.replace(/"/g, "").match(/Key \((.*?)\)=\((.*?)\)/))) {
                    fields = _.zipObject(match[1].split(", "), match[2].split(", "));
                    errors = [];
                    message = "Validation error";
                    _.forOwn(fields, (value, field)=>{
                        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
                    });
                    if (this.model && this.model.uniqueKeys) {
                        _.forOwn(this.model.uniqueKeys, (constraint)=>{
                            if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {
                                message = constraint.msg;
                                return false;
                            }
                        });
                    }
                    return new sequelizeErrors.UniqueConstraintError({
                        message,
                        errors,
                        parent: err,
                        fields,
                        stack: errStack
                    });
                }
                return new sequelizeErrors.UniqueConstraintError({
                    message: errMessage,
                    parent: err,
                    stack: errStack
                });
            case "23P01":
                match = errDetail.match(/Key \((.*?)\)=\((.*?)\)/);
                if (match) {
                    fields = _.zipObject(match[1].split(", "), match[2].split(", "));
                }
                message = "Exclusion constraint error";
                return new sequelizeErrors.ExclusionConstraintError({
                    message,
                    constraint: err.constraint,
                    fields,
                    table: err.table,
                    parent: err,
                    stack: errStack
                });
            case "42704":
                if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {
                    message = "Unknown constraint error";
                    index = errMessage.match(/(?:constraint|index) "(.+?)"/i);
                    index = index ? index[1] : void 0;
                    table = errMessage.match(/relation "(.+?)"/i);
                    table = table ? table[1] : void 0;
                    throw new sequelizeErrors.UnknownConstraintError({
                        message,
                        constraint: index,
                        fields,
                        table,
                        parent: err,
                        stack: errStack
                    });
                }
            default:
                return new sequelizeErrors.DatabaseError(err, {
                    stack: errStack
                });
        }
    }
    isForeignKeysQuery() {
        return /SELECT conname as constraint_name, pg_catalog\.pg_get_constraintdef\(r\.oid, true\) as condef FROM pg_catalog\.pg_constraint r WHERE r\.conrelid = \(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\) AND r\.contype = 'f' ORDER BY 1;/.test(this.sql);
    }
    getInsertIdField() {
        return "id";
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const semver = __turbopack_context__.r("[project]/node_modules/semver/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const POSTGRES_RESERVED_WORDS = "all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with".split(",");
class PostgresQueryGenerator extends AbstractQueryGenerator {
    setSearchPath(searchPath) {
        return `SET search_path to ${searchPath};`;
    }
    createDatabaseQuery(databaseName, options) {
        options = __spreadValues({
            encoding: null,
            collate: null
        }, options);
        const values = {
            database: this.quoteTable(databaseName),
            encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : "",
            collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : "",
            ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : "",
            template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ""
        };
        return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
    }
    dropDatabaseQuery(databaseName) {
        return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
    }
    createSchema(schema) {
        const databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);
        if (databaseVersion && semver.gte(databaseVersion, "9.2.0")) {
            return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;
        }
        return `CREATE SCHEMA ${this.quoteIdentifier(schema)};`;
    }
    dropSchema(schema) {
        return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;
    }
    showSchemasQuery() {
        return "SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';";
    }
    versionQuery() {
        return "SHOW SERVER_VERSION";
    }
    createTableQuery(tableName, attributes, options) {
        options = __spreadValues({}, options);
        const databaseVersion = _.get(this, "sequelize.options.databaseVersion", 0);
        const attrStr = [];
        let comments = "";
        let columnComments = "";
        const quotedTable = this.quoteTable(tableName);
        if (options.comment && typeof options.comment === "string") {
            comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
        }
        for(const attr in attributes){
            const quotedAttr = this.quoteIdentifier(attr);
            const i = attributes[attr].indexOf("COMMENT ");
            if (i !== -1) {
                const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
                columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
                attributes[attr] = attributes[attr].substring(0, i);
            }
            const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
            attrStr.push(`${quotedAttr} ${dataType}`);
        }
        let attributesClause = attrStr.join(", ");
        if (options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns)=>{
                if (columns.customIndex) {
                    attributesClause += `, UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                }
            });
        }
        const pks = _.reduce(attributes, (acc, attribute, key)=>{
            if (attribute.includes("PRIMARY KEY")) {
                acc.push(this.quoteIdentifier(key));
            }
            return acc;
        }, []).join(",");
        if (pks.length > 0) {
            attributesClause += `, PRIMARY KEY (${pks})`;
        }
        return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, "9.1.0") ? "IF NOT EXISTS " : ""}${quotedTable} (${attributesClause})${comments}${columnComments};`;
    }
    dropTableQuery(tableName, options) {
        options = options || {};
        return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? " CASCADE" : ""};`;
    }
    showTablesQuery() {
        const schema = this.options.schema || "public";
        return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;
    }
    tableExistsQuery(tableName) {
        const table = tableName.tableName || tableName;
        const schema = tableName.schema || "public";
        return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;
    }
    describeTableQuery(tableName, schema) {
        schema = schema || this.options.schema || "public";
        return `SELECT pk.constraint_type as "Constraint",c.column_name as "Field", c.column_default as "Default",c.is_nullable as "Null", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as "Type", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS "special", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS "Comment" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;
    }
    _checkValidJsonStatement(stmt) {
        if (typeof stmt !== "string") {
            return false;
        }
        const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
        const jsonOperatorRegex = /^\s*(->>?|#>>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
        const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
        let currentIndex = 0;
        let openingBrackets = 0;
        let closingBrackets = 0;
        let hasJsonFunction = false;
        let hasInvalidToken = false;
        while(currentIndex < stmt.length){
            const string = stmt.substr(currentIndex);
            const functionMatches = jsonFunctionRegex.exec(string);
            if (functionMatches) {
                currentIndex += functionMatches[0].indexOf("(");
                hasJsonFunction = true;
                continue;
            }
            const operatorMatches = jsonOperatorRegex.exec(string);
            if (operatorMatches) {
                currentIndex += operatorMatches[0].length;
                hasJsonFunction = true;
                continue;
            }
            const tokenMatches = tokenCaptureRegex.exec(string);
            if (tokenMatches) {
                const capturedToken = tokenMatches[1];
                if (capturedToken === "(") {
                    openingBrackets++;
                } else if (capturedToken === ")") {
                    closingBrackets++;
                } else if (capturedToken === ";") {
                    hasInvalidToken = true;
                    break;
                }
                currentIndex += tokenMatches[0].length;
                continue;
            }
            break;
        }
        hasInvalidToken |= openingBrackets !== closingBrackets;
        if (hasJsonFunction && hasInvalidToken) {
            throw new Error(`Invalid json statement: ${stmt}`);
        }
        return hasJsonFunction;
    }
    handleSequelizeMethod(smth, tableName, factory, options, prepend) {
        if (smth instanceof Utils.Json) {
            if (smth.conditions) {
                const conditions = this.parseConditionObject(smth.conditions).map((condition)=>`${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);
                return conditions.join(" AND ");
            }
            if (smth.path) {
                let str;
                if (this._checkValidJsonStatement(smth.path)) {
                    str = smth.path;
                } else {
                    const paths = _.toPath(smth.path);
                    const column = paths.shift();
                    str = this.jsonPathExtractionQuery(column, paths);
                }
                if (smth.value) {
                    str += util.format(" = %s", this.escape(smth.value));
                }
                return str;
            }
        }
        return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
    }
    addColumnQuery(table, key, attribute) {
        const dbDataType = this.attributeToSQL(attribute, {
            context: "addColumn",
            table,
            key
        });
        const dataType = attribute.type || attribute;
        const definition = this.dataTypeMapping(table, key, dbDataType);
        const quotedKey = this.quoteIdentifier(key);
        const quotedTable = this.quoteTable(this.extractTableDetails(table));
        let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;
        if (dataType instanceof DataTypes.ENUM) {
            query = this.pgEnum(table, key, dataType) + query;
        } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {
            query = this.pgEnum(table, key, dataType.type) + query;
        }
        return query;
    }
    removeColumnQuery(tableName, attributeName) {
        const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
        const quotedAttributeName = this.quoteIdentifier(attributeName);
        return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
    }
    changeColumnQuery(tableName, attributes) {
        const query = (subQuery)=>`ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
        const sql = [];
        for(const attributeName in attributes){
            let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
            let attrSql = "";
            if (definition.includes("NOT NULL")) {
                attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);
                definition = definition.replace("NOT NULL", "").trim();
            } else if (!definition.includes("REFERENCES")) {
                attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
            }
            if (definition.includes("DEFAULT")) {
                attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);
                definition = definition.replace(/(DEFAULT[^;]+)/, "").trim();
            } else if (!definition.includes("REFERENCES")) {
                attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
            }
            if (attributes[attributeName].startsWith("ENUM(")) {
                attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
                definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, {
                    schema: false
                }));
                definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
            }
            if (definition.match(/UNIQUE;*$/)) {
                definition = definition.replace(/UNIQUE;*$/, "");
                attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace("ALTER COLUMN", "");
            }
            if (definition.includes("REFERENCES")) {
                definition = definition.replace(/.+?(?=REFERENCES)/, "");
                attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace("ALTER COLUMN", "");
            } else {
                attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
            }
            sql.push(attrSql);
        }
        return sql.join("");
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const attrString = [];
        for(const attributeName in attributes){
            attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
        }
        return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(", ")};`;
    }
    fn(fnName, tableName, parameters, body, returns, language) {
        fnName = fnName || "testfunc";
        language = language || "plpgsql";
        returns = returns ? `RETURNS ${returns}` : "";
        parameters = parameters || "";
        return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
    }
    truncateTableQuery(tableName, options = {}) {
        return [
            `TRUNCATE ${this.quoteTable(tableName)}`,
            options.restartIdentity ? " RESTART IDENTITY" : "",
            options.cascade ? " CASCADE" : ""
        ].join("");
    }
    deleteQuery(tableName, where, options = {}, model) {
        const table = this.quoteTable(tableName);
        let whereClause = this.getWhereConditions(where, null, model, options);
        const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : "";
        let primaryKeys = "";
        let primaryKeysSelection = "";
        if (whereClause) {
            whereClause = ` WHERE ${whereClause}`;
        }
        if (options.limit) {
            if (!model) {
                throw new Error("Cannot LIMIT delete without a model.");
            }
            const pks = Object.values(model.primaryKeys).map((pk)=>this.quoteIdentifier(pk.field)).join(",");
            primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
            primaryKeysSelection = pks;
            return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
        }
        return `DELETE FROM ${table}${whereClause}`;
    }
    showIndexesQuery(tableName) {
        let schemaJoin = "";
        let schemaWhere = "";
        if (typeof tableName !== "string") {
            schemaJoin = ", pg_namespace s";
            schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;
            tableName = tableName.tableName;
        }
        return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;
    }
    showConstraintsQuery(tableName) {
        return [
            'SELECT constraint_catalog AS "constraintCatalog",',
            'constraint_schema AS "constraintSchema",',
            'constraint_name AS "constraintName",',
            'table_catalog AS "tableCatalog",',
            'table_schema AS "tableSchema",',
            'table_name AS "tableName",',
            'constraint_type AS "constraintType",',
            'is_deferrable AS "isDeferrable",',
            'initially_deferred AS "initiallyDeferred"',
            "from INFORMATION_SCHEMA.table_constraints",
            `WHERE table_name='${tableName}';`
        ].join(" ");
    }
    removeIndexQuery(tableName, indexNameOrAttributes, options) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return [
            "DROP INDEX",
            options && options.concurrently && "CONCURRENTLY",
            `IF EXISTS ${this.quoteIdentifiers(indexName)}`
        ].filter(Boolean).join(" ");
    }
    addLimitAndOffset(options) {
        let fragment = "";
        if (options.limit != null) {
            fragment += " LIMIT " + this.escape(options.limit);
        }
        if (options.offset != null) {
            fragment += " OFFSET " + this.escape(options.offset);
        }
        return fragment;
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        let type;
        if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {
            const enumType = attribute.type.type || attribute.type;
            let values = attribute.values;
            if (enumType.values && !attribute.values) {
                values = enumType.values;
            }
            if (Array.isArray(values) && values.length > 0) {
                type = `ENUM(${values.map((value)=>this.escape(value)).join(", ")})`;
                if (attribute.type instanceof DataTypes.ARRAY) {
                    type += "[]";
                }
            } else {
                throw new Error("Values for ENUM haven't been defined.");
            }
        }
        if (!type) {
            type = attribute.type;
        }
        let sql = type.toString();
        if (Object.prototype.hasOwnProperty.call(attribute, "allowNull") && !attribute.allowNull) {
            sql += " NOT NULL";
        }
        if (attribute.autoIncrement) {
            if (attribute.autoIncrementIdentity) {
                sql += " GENERATED BY DEFAULT AS IDENTITY";
            } else {
                sql += " SERIAL";
            }
        }
        if (Utils.defaultValueSchemable(attribute.defaultValue)) {
            sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
        }
        if (attribute.unique === true) {
            sql += " UNIQUE";
        }
        if (attribute.primaryKey) {
            sql += " PRIMARY KEY";
        }
        if (attribute.references) {
            let referencesTable = this.quoteTable(attribute.references.model);
            let schema;
            if (options.schema) {
                schema = options.schema;
            } else if ((!attribute.references.model || typeof attribute.references.model == "string") && options.table && options.table.schema) {
                schema = options.table.schema;
            }
            if (schema) {
                referencesTable = this.quoteTable(this.addSchema({
                    tableName: referencesTable,
                    _schema: schema
                }));
            }
            let referencesKey;
            if (!options.withoutForeignKeyConstraints) {
                if (attribute.references.key) {
                    referencesKey = this.quoteIdentifiers(attribute.references.key);
                } else {
                    referencesKey = this.quoteIdentifier("id");
                }
                sql += ` REFERENCES ${referencesTable} (${referencesKey})`;
                if (attribute.onDelete) {
                    sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
                }
                if (attribute.onUpdate) {
                    sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
                }
                if (attribute.references.deferrable) {
                    sql += ` ${attribute.references.deferrable.toString(this)}`;
                }
            }
        }
        if (attribute.comment && typeof attribute.comment === "string") {
            if (options && [
                "addColumn",
                "changeColumn"
            ].includes(options.context)) {
                const quotedAttr = this.quoteIdentifier(options.key);
                const escapedCommentText = this.escape(attribute.comment);
                sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
            } else {
                sql += ` COMMENT ${attribute.comment}`;
            }
        }
        return sql;
    }
    deferConstraintsQuery(options) {
        return options.deferrable.toString(this);
    }
    setConstraintQuery(columns, type) {
        let columnFragment = "ALL";
        if (columns) {
            columnFragment = columns.map((column)=>this.quoteIdentifier(column)).join(", ");
        }
        return `SET CONSTRAINTS ${columnFragment} ${type}`;
    }
    setDeferredQuery(columns) {
        return this.setConstraintQuery(columns, "DEFERRED");
    }
    setImmediateQuery(columns) {
        return this.setConstraintQuery(columns, "IMMEDIATE");
    }
    attributesToSQL(attributes, options) {
        const result = {};
        for(const key in attributes){
            const attribute = attributes[key];
            result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({
                key
            }, options));
        }
        return result;
    }
    createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
        const decodedEventType = this.decodeTriggerEventType(eventType);
        const eventSpec = this.expandTriggerEventSpec(fireOnSpec);
        const expandedOptions = this.expandOptions(optionsArray);
        const paramList = this._expandFunctionParamList(functionParams);
        return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ""} EXECUTE PROCEDURE ${functionName}(${paramList});`;
    }
    dropTrigger(tableName, triggerName) {
        return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;
    }
    renameTrigger(tableName, oldTriggerName, newTriggerName) {
        return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;
    }
    createFunction(functionName, params, returnType, language, body, optionsArray, options) {
        if (!functionName || !returnType || !language || !body) throw new Error("createFunction missing some parameters. Did you pass functionName, returnType, language and body?");
        const paramList = this._expandFunctionParamList(params);
        const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : "";
        const expandedOptionsArray = this.expandOptions(optionsArray);
        const statement = options && options.force ? "CREATE OR REPLACE FUNCTION" : "CREATE FUNCTION";
        return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;
    }
    dropFunction(functionName, params) {
        if (!functionName) throw new Error("requires functionName");
        const paramList = this._expandFunctionParamList(params);
        return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;
    }
    renameFunction(oldFunctionName, params, newFunctionName) {
        const paramList = this._expandFunctionParamList(params);
        return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;
    }
    pgEscapeAndQuote(val) {
        return this.quoteIdentifier(Utils.removeTicks(this.escape(val), "'"));
    }
    _expandFunctionParamList(params) {
        if (params === void 0 || !Array.isArray(params)) {
            throw new Error("_expandFunctionParamList: function parameters array required, including an empty one for no arguments");
        }
        const paramList = [];
        params.forEach((curParam)=>{
            const paramDef = [];
            if (curParam.type) {
                if (curParam.direction) {
                    paramDef.push(curParam.direction);
                }
                if (curParam.name) {
                    paramDef.push(curParam.name);
                }
                paramDef.push(curParam.type);
            } else {
                throw new Error("function or trigger used with a parameter without any type");
            }
            const joined = paramDef.join(" ");
            if (joined) paramList.push(joined);
        });
        return paramList.join(", ");
    }
    _expandFunctionVariableList(variables) {
        if (!Array.isArray(variables)) {
            throw new Error("_expandFunctionVariableList: function variables must be an array");
        }
        const variableDefinitions = [];
        variables.forEach((variable)=>{
            if (!variable.name || !variable.type) {
                throw new Error("function variable must have a name and type");
            }
            let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;
            if (variable.default) {
                variableDefinition += ` := ${variable.default}`;
            }
            variableDefinition += ";";
            variableDefinitions.push(variableDefinition);
        });
        return variableDefinitions.join(" ");
    }
    expandOptions(options) {
        return options === void 0 || _.isEmpty(options) ? "" : options.join(" ");
    }
    decodeTriggerEventType(eventSpecifier) {
        const EVENT_DECODER = {
            "after": "AFTER",
            "before": "BEFORE",
            "instead_of": "INSTEAD OF",
            "after_constraint": "AFTER"
        };
        if (!EVENT_DECODER[eventSpecifier]) {
            throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);
        }
        return EVENT_DECODER[eventSpecifier];
    }
    triggerEventTypeIsConstraint(eventSpecifier) {
        return eventSpecifier === "after_constraint" ? "CONSTRAINT " : "";
    }
    expandTriggerEventSpec(fireOnSpec) {
        if (_.isEmpty(fireOnSpec)) {
            throw new Error("no table change events specified to trigger on");
        }
        return _.map(fireOnSpec, (fireValue, fireKey)=>{
            const EVENT_MAP = {
                "insert": "INSERT",
                "update": "UPDATE",
                "delete": "DELETE",
                "truncate": "TRUNCATE"
            };
            if (!EVENT_MAP[fireValue]) {
                throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);
            }
            let eventSpec = EVENT_MAP[fireValue];
            if (eventSpec === "UPDATE") {
                if (Array.isArray(fireValue) && fireValue.length > 0) {
                    eventSpec += ` OF ${fireValue.join(", ")}`;
                }
            }
            return eventSpec;
        }).join(" OR ");
    }
    pgEnumName(tableName, attr, options) {
        options = options || {};
        const tableDetails = this.extractTableDetails(tableName, options);
        let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '"');
        if (options.schema !== false && tableDetails.schema) {
            enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
        }
        return enumName;
    }
    pgListEnums(tableName, attrName, options) {
        let enumName = "";
        const tableDetails = this.extractTableDetails(tableName, options);
        if (tableDetails.tableName && attrName) {
            enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, {
                schema: false
            }).replace(/"/g, "'")}`;
        }
        return `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;
    }
    pgEnum(tableName, attr, dataType, options) {
        const enumName = this.pgEnumName(tableName, attr, options);
        let values;
        if (dataType.values) {
            values = `ENUM(${dataType.values.map((value)=>this.escape(value)).join(", ")})`;
        } else {
            values = dataType.toString().match(/^ENUM\(.+\)/)[0];
        }
        let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;
        if (!!options && options.force === true) {
            sql = this.pgEnumDrop(tableName, attr) + sql;
        }
        return sql;
    }
    pgEnumAdd(tableName, attr, value, options) {
        const enumName = this.pgEnumName(tableName, attr);
        let sql = `ALTER TYPE ${enumName} ADD VALUE `;
        if (semver.gte(this.sequelize.options.databaseVersion, "9.3.0")) {
            sql += "IF NOT EXISTS ";
        }
        sql += this.escape(value);
        if (options.before) {
            sql += ` BEFORE ${this.escape(options.before)}`;
        } else if (options.after) {
            sql += ` AFTER ${this.escape(options.after)}`;
        }
        return sql;
    }
    pgEnumDrop(tableName, attr, enumName) {
        enumName = enumName || this.pgEnumName(tableName, attr);
        return `DROP TYPE IF EXISTS ${enumName}; `;
    }
    fromArray(text) {
        text = text.replace(/^{/, "").replace(/}$/, "");
        let matches = text.match(/("(?:\\.|[^"\\\\])*"|[^,]*)(?:\s*,\s*|\s*$)/ig);
        if (matches.length < 1) {
            return [];
        }
        matches = matches.map((m)=>m.replace(/",$/, "").replace(/,$/, "").replace(/(^"|"$)/g, ""));
        return matches.slice(0, -1);
    }
    dataTypeMapping(tableName, attr, dataType) {
        if (dataType.includes("PRIMARY KEY")) {
            dataType = dataType.replace("PRIMARY KEY", "");
        }
        if (dataType.includes("SERIAL")) {
            if (dataType.includes("BIGINT")) {
                dataType = dataType.replace("SERIAL", "BIGSERIAL");
                dataType = dataType.replace("BIGINT", "");
            } else if (dataType.includes("SMALLINT")) {
                dataType = dataType.replace("SERIAL", "SMALLSERIAL");
                dataType = dataType.replace("SMALLINT", "");
            } else {
                dataType = dataType.replace("INTEGER", "");
            }
            dataType = dataType.replace("NOT NULL", "");
        }
        if (dataType.startsWith("ENUM(")) {
            dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
        }
        return dataType;
    }
    getForeignKeysQuery(tableName) {
        return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;
    }
    _getForeignKeyReferencesQueryPrefix() {
        return "SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name ";
    }
    getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
        return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ""}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ""}`;
    }
    getForeignKeyReferenceQuery(table, columnName) {
        const tableName = table.tableName || table;
        const schema = table.schema;
        return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : ""}`;
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;
    }
    quoteIdentifier(identifier, force) {
        const optForceQuote = force || false;
        const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
        const rawIdentifier = Utils.removeTicks(identifier, '"');
        if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(".") || identifier.includes("->") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {
            return Utils.addTicks(rawIdentifier, '"');
        }
        return rawIdentifier;
    }
}
module.exports = PostgresQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Deferrable = __turbopack_context__.r("[project]/node_modules/sequelize/lib/deferrable.js [app-route] (ecmascript)");
class PostgresQueryInterface extends QueryInterface {
    async ensureEnums(tableName, attributes, options, model) {
        const keys = Object.keys(attributes);
        const keyLen = keys.length;
        let sql = "";
        let promises = [];
        let i = 0;
        for(i = 0; i < keyLen; i++){
            const attribute = attributes[keys[i]];
            const type = attribute.type;
            if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {
                sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);
                promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
                    plain: true,
                    raw: true,
                    type: QueryTypes.SELECT
                })));
            }
        }
        const results = await Promise.all(promises);
        promises = [];
        let enumIdx = 0;
        const addEnumValue = (field, value, relativeValue, position = "before", spliceStart = promises.length)=>{
            const valueOptions = __spreadValues({}, options);
            valueOptions.before = null;
            valueOptions.after = null;
            switch(position){
                case "after":
                    valueOptions.after = relativeValue;
                    break;
                case "before":
                default:
                    valueOptions.before = relativeValue;
                    break;
            }
            promises.splice(spliceStart, 0, ()=>{
                return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);
            });
        };
        for(i = 0; i < keyLen; i++){
            const attribute = attributes[keys[i]];
            const type = attribute.type;
            const enumType = type.type || type;
            const field = attribute.field || keys[i];
            if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {
                if (!results[enumIdx]) {
                    promises.push(()=>{
                        return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), {
                            raw: true
                        }));
                    });
                } else if (!!results[enumIdx] && !!model) {
                    const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);
                    const vals = enumType.values;
                    let lastOldEnumValue;
                    let rightestPosition = -1;
                    for(let oldIndex = 0; oldIndex < enumVals.length; oldIndex++){
                        const enumVal = enumVals[oldIndex];
                        const newIdx = vals.indexOf(enumVal);
                        lastOldEnumValue = enumVal;
                        if (newIdx === -1) {
                            continue;
                        }
                        const newValuesBefore = vals.slice(0, newIdx);
                        const promisesLength = promises.length;
                        for(let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--){
                            if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {
                                break;
                            }
                            addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, "before", promisesLength);
                        }
                        if (newIdx > rightestPosition) {
                            rightestPosition = newIdx;
                        }
                    }
                    if (lastOldEnumValue && rightestPosition < vals.length - 1) {
                        const remainingEnumValues = vals.slice(rightestPosition + 1);
                        for(let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--){
                            addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, "after");
                        }
                    }
                    enumIdx++;
                }
            }
        }
        const result = await promises.reduce(async (promise, asyncFunction)=>await asyncFunction(await promise), Promise.resolve());
        if (promises.length) {
            await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();
        }
        return result;
    }
    async getForeignKeyReferencesForTable(table, options) {
        const queryOptions = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.FOREIGNKEYS
        });
        const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database, table.schema);
        const result = await this.sequelize.query(query, queryOptions);
        return result.map((fkMeta)=>{
            const _a = Utils.camelizeObjectKeys(fkMeta), { initiallyDeferred, isDeferrable } = _a, remaining = __objRest(_a, [
                "initiallyDeferred",
                "isDeferrable"
            ]);
            return __spreadProps(__spreadValues({}, remaining), {
                deferrable: isDeferrable === "NO" ? Deferrable.NOT : initiallyDeferred === "NO" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED
            });
        });
    }
    async dropEnum(enumName, options) {
        options = options || {};
        return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), {
            raw: true
        }));
    }
    async dropAllEnums(options) {
        options = options || {};
        const enums = await this.pgListEnums(null, options);
        return await Promise.all(enums.map((result)=>this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), {
                raw: true
            }))));
    }
    async pgListEnums(tableName, options) {
        options = options || {};
        const sql = this.queryGenerator.pgListEnums(tableName);
        return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            plain: false,
            raw: true,
            type: QueryTypes.SELECT
        }));
    }
    async dropTable(tableName, options) {
        await super.dropTable(tableName, options);
        const promises = [];
        const instanceTable = this.sequelize.modelManager.getModel(tableName, {
            attribute: "tableName"
        });
        if (!instanceTable) {
            return;
        }
        const getTableName = (!options || !options.schema || options.schema === "public" ? "" : `${options.schema}_`) + tableName;
        const keys = Object.keys(instanceTable.rawAttributes);
        const keyLen = keys.length;
        for(let i = 0; i < keyLen; i++){
            if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {
                const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);
                options.supportsSearchPath = false;
                promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
                    raw: true
                })));
            }
        }
        await Promise.all(promises);
    }
}
exports.PostgresQueryInterface = PostgresQueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/postgres/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").postgres;
const { PostgresQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/query-interface.js [app-route] (ecmascript)");
class PostgresDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);
    }
    canBackslashEscape() {
        return !this.sequelize.options.standardConformingStrings;
    }
}
PostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "DEFAULT VALUES": true,
    EXCEPTION: true,
    "ON DUPLICATE KEY": false,
    "ORDER NULLS": true,
    returnValues: {
        returning: true
    },
    bulkDefault: true,
    schemas: true,
    lock: true,
    lockOf: true,
    lockKey: true,
    lockOuterJoinFailure: true,
    skipLocked: true,
    forShare: "FOR SHARE",
    index: {
        concurrently: true,
        using: 2,
        where: true,
        functionBased: true,
        operator: true
    },
    inserts: {
        onConflictDoNothing: " ON CONFLICT DO NOTHING",
        updateOnDuplicate: " ON CONFLICT DO UPDATE SET",
        conflictFields: true,
        onConflictWhere: true
    },
    NUMERIC: true,
    ARRAY: true,
    RANGE: true,
    GEOMETRY: true,
    REGEXP: true,
    GEOGRAPHY: true,
    JSON: true,
    JSONB: true,
    HSTORE: true,
    TSVECTOR: true,
    deferrableConstraints: true,
    searchPath: true,
    escapeStringConstants: true
});
PostgresDialect.prototype.defaultVersion = "9.5.0";
PostgresDialect.prototype.Query = Query;
PostgresDialect.prototype.DataTypes = DataTypes;
PostgresDialect.prototype.name = "postgres";
PostgresDialect.prototype.TICK_CHAR = '"';
PostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;
PostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;
module.exports = PostgresDialect;
module.exports.default = PostgresDialect;
module.exports.PostgresDialect = PostgresDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("connection:sqlite");
const dataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").sqlite;
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("sqlite");
const { promisify } = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        super(dialect, sequelize);
        if (this.sequelize.options.host === "localhost") {
            delete this.sequelize.options.host;
        }
        this.connections = {};
        this.lib = this._loadDialectModule("sqlite3");
        this.refreshTypeParser(dataTypes);
    }
    async _onProcessExit() {
        await Promise.all(Object.getOwnPropertyNames(this.connections).map((connection)=>promisify((callback)=>this.connections[connection].close(callback))()));
        return super._onProcessExit.call(this);
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    async getConnection(options) {
        options = options || {};
        options.uuid = options.uuid || "default";
        if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {
            options.storage = this.sequelize.options.storage;
        } else {
            options.storage = this.sequelize.options.host || ":memory:";
        }
        options.inMemory = options.storage === ":memory:" ? 1 : 0;
        const dialectOptions = this.sequelize.options.dialectOptions;
        const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;
        options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;
        if (this.connections[options.inMemory || options.uuid]) {
            return this.connections[options.inMemory || options.uuid];
        }
        if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {
            fs.mkdirSync(path.dirname(options.storage), {
                recursive: true
            });
        }
        const connection = await new Promise((resolve, reject)=>{
            this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, (err)=>{
                if (err) return reject(new sequelizeErrors.ConnectionError(err));
                debug(`connection acquired ${options.uuid}`);
                resolve(this.connections[options.inMemory || options.uuid]);
            });
        });
        if (this.sequelize.config.password) {
            connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);
        }
        if (this.sequelize.options.foreignKeys !== false) {
            connection.run("PRAGMA FOREIGN_KEYS=ON");
        }
        return connection;
    }
    releaseConnection(connection, force) {
        if (connection.filename === ":memory:" && force !== true) return;
        if (connection.uuid) {
            connection.close();
            debug(`connection released ${connection.uuid}`);
            delete this.connections[connection.uuid];
        }
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("sqlite");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const debug = logger.debugContext("sql:sqlite");
function stringifyIfBigint(value) {
    if (typeof value === "bigint") {
        return value.toString();
    }
    return value;
}
class Query extends AbstractQuery {
    getInsertIdField() {
        return "lastID";
    }
    static formatBindParameters(sql, values, dialect) {
        let bindParam;
        if (Array.isArray(values)) {
            bindParam = {};
            values.forEach((v, i)=>{
                bindParam[`$${i + 1}`] = v;
            });
            sql = AbstractQuery.formatBindParameters(sql, values, dialect, {
                skipValueReplace: true
            })[0];
        } else {
            bindParam = {};
            if (typeof values === "object") {
                for (const k of Object.keys(values)){
                    bindParam[`$${k}`] = values[k];
                }
            }
            sql = AbstractQuery.formatBindParameters(sql, values, dialect, {
                skipValueReplace: true
            })[0];
        }
        return [
            sql,
            bindParam
        ];
    }
    _collectModels(include, prefix) {
        const ret = {};
        if (include) {
            for (const _include of include){
                let key;
                if (!prefix) {
                    key = _include.as;
                } else {
                    key = `${prefix}.${_include.as}`;
                }
                ret[key] = _include.model;
                if (_include.include) {
                    _.merge(ret, this._collectModels(_include.include, key));
                }
            }
        }
        return ret;
    }
    _handleQueryResponse(metaData, columnTypes, err, results, errStack) {
        if (err) {
            err.sql = this.sql;
            throw this.formatError(err, errStack);
        }
        let result = this.instance;
        if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
            this.handleInsertQuery(results, metaData);
            if (!this.instance) {
                if (metaData.constructor.name === "Statement" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {
                    const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
                    result = [];
                    for(let i = startId; i < startId + metaData.changes; i++){
                        result.push({
                            [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i
                        });
                    }
                } else {
                    result = metaData[this.getInsertIdField()];
                }
            }
        }
        if (this.isShowTablesQuery()) {
            return results.map((row)=>row.name);
        }
        if (this.isShowConstraintsQuery()) {
            result = results;
            if (results && results[0] && results[0].sql) {
                result = this.parseConstraintsFromSql(results[0].sql);
            }
            return result;
        }
        if (this.isSelectQuery()) {
            if (this.options.raw) {
                return this.handleSelectQuery(results);
            }
            const prefixes = this._collectModels(this.options.include);
            results = results.map((result2)=>{
                return _.mapValues(result2, (value, name)=>{
                    let model;
                    if (name.includes(".")) {
                        const lastind = name.lastIndexOf(".");
                        model = prefixes[name.substr(0, lastind)];
                        name = name.substr(lastind + 1);
                    } else {
                        model = this.options.model;
                    }
                    const tableName = model.getTableName().toString().replace(/`/g, "");
                    const tableTypes = columnTypes[tableName] || {};
                    if (tableTypes && !(name in tableTypes)) {
                        _.forOwn(model.rawAttributes, (attribute, key)=>{
                            if (name === key && attribute.field) {
                                name = attribute.field;
                                return false;
                            }
                        });
                    }
                    return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;
                });
            });
            return this.handleSelectQuery(results);
        }
        if (this.isShowOrDescribeQuery()) {
            return results;
        }
        if (this.sql.includes("PRAGMA INDEX_LIST")) {
            return this.handleShowIndexesQuery(results);
        }
        if (this.sql.includes("PRAGMA INDEX_INFO")) {
            return results;
        }
        if (this.sql.includes("PRAGMA TABLE_INFO")) {
            result = {};
            let defaultValue;
            for (const _result of results){
                if (_result.dflt_value === null) {
                    defaultValue = void 0;
                } else if (_result.dflt_value === "NULL") {
                    defaultValue = null;
                } else {
                    defaultValue = _result.dflt_value;
                }
                result[_result.name] = {
                    type: _result.type,
                    allowNull: _result.notnull === 0,
                    defaultValue,
                    primaryKey: _result.pk !== 0
                };
                if (result[_result.name].type === "TINYINT(1)") {
                    result[_result.name].defaultValue = ({
                        "0": false,
                        "1": true
                    })[result[_result.name].defaultValue];
                }
                if (typeof result[_result.name].defaultValue === "string") {
                    result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, "");
                }
            }
            return result;
        }
        if (this.sql.includes("PRAGMA foreign_keys;")) {
            return results[0];
        }
        if (this.sql.includes("PRAGMA foreign_keys")) {
            return results;
        }
        if (this.sql.includes("PRAGMA foreign_key_list")) {
            return results;
        }
        if ([
            QueryTypes.BULKUPDATE,
            QueryTypes.BULKDELETE
        ].includes(this.options.type)) {
            return metaData.changes;
        }
        if (this.options.type === QueryTypes.VERSION) {
            return results[0].version;
        }
        if (this.options.type === QueryTypes.RAW) {
            return [
                results,
                metaData
            ];
        }
        if (this.isUpsertQuery()) {
            return [
                result,
                null
            ];
        }
        if (this.isUpdateQuery() || this.isInsertQuery()) {
            return [
                result,
                metaData.changes
            ];
        }
        return result;
    }
    async run(sql, parameters) {
        const conn = this.connection;
        this.sql = sql;
        const method = this.getDatabaseMethod();
        const complete = this._logQuery(sql, debug, parameters);
        return new Promise((resolve, reject)=>conn.serialize(async ()=>{
                const columnTypes = {};
                const errForStack = new Error();
                const executeSql = ()=>{
                    if (sql.startsWith("-- ")) {
                        return resolve();
                    }
                    const query = this;
                    function afterExecute(executionError, results) {
                        try {
                            complete();
                            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));
                            return;
                        } catch (error) {
                            reject(error);
                        }
                    }
                    if (!parameters) parameters = [];
                    if (_.isPlainObject(parameters)) {
                        const newParameters = Object.create(null);
                        for (const key of Object.keys(parameters)){
                            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);
                        }
                        parameters = newParameters;
                    } else {
                        parameters = parameters.map(stringifyIfBigint);
                    }
                    conn[method](sql, parameters, afterExecute);
                    return null;
                };
                if (this.getDatabaseMethod() === "all") {
                    let tableNames = [];
                    if (this.options && this.options.tableNames) {
                        tableNames = this.options.tableNames;
                    } else if (/FROM `(.*?)`/i.exec(this.sql)) {
                        tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);
                    }
                    tableNames = tableNames.filter((tableName)=>!(tableName in columnTypes) && tableName !== "sqlite_master");
                    if (!tableNames.length) {
                        return executeSql();
                    }
                    await Promise.all(tableNames.map((tableName)=>new Promise((resolve2)=>{
                            tableName = tableName.replace(/`/g, "");
                            columnTypes[tableName] = {};
                            conn.all(`PRAGMA table_info(\`${tableName}\`)`, (err, results)=>{
                                if (!err) {
                                    for (const result of results){
                                        columnTypes[tableName][result.name] = result.type;
                                    }
                                }
                                resolve2();
                            });
                        })));
                }
                return executeSql();
            }));
    }
    parseConstraintsFromSql(sql) {
        let constraints = sql.split("CONSTRAINT ");
        let referenceTableName, referenceTableKeys, updateAction, deleteAction;
        constraints.splice(0, 1);
        constraints = constraints.map((constraintSql)=>{
            if (constraintSql.includes("REFERENCES")) {
                updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
                deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);
                if (updateAction) {
                    updateAction = updateAction[1];
                }
                if (deleteAction) {
                    deleteAction = deleteAction[1];
                }
                const referencesRegex = /REFERENCES.+\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/;
                const referenceConditions = constraintSql.match(referencesRegex)[0].split(" ");
                referenceTableName = Utils.removeTicks(referenceConditions[1]);
                let columnNames = referenceConditions[2];
                columnNames = columnNames.replace(/\(|\)/g, "").split(", ");
                referenceTableKeys = columnNames.map((column)=>Utils.removeTicks(column));
            }
            const constraintCondition = constraintSql.match(/\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/)[0];
            constraintSql = constraintSql.replace(/\(.+\)/, "");
            const constraint = constraintSql.split(" ");
            if ([
                "PRIMARY",
                "FOREIGN"
            ].includes(constraint[1])) {
                constraint[1] += " KEY";
            }
            return {
                constraintName: Utils.removeTicks(constraint[0]),
                constraintType: constraint[1],
                updateAction,
                deleteAction,
                sql: sql.replace(/"/g, "`"),
                constraintCondition,
                referenceTableName,
                referenceTableKeys
            };
        });
        return constraints;
    }
    applyParsers(type, value) {
        if (type.includes("(")) {
            type = type.substr(0, type.indexOf("("));
        }
        type = type.replace("UNSIGNED", "").replace("ZEROFILL", "");
        type = type.trim().toUpperCase();
        const parse = parserStore.get(type);
        if (value !== null && parse) {
            return parse(value, {
                timezone: this.sequelize.options.timezone
            });
        }
        return value;
    }
    formatError(err, errStack) {
        switch(err.code){
            case "SQLITE_CONSTRAINT_UNIQUE":
            case "SQLITE_CONSTRAINT_PRIMARYKEY":
            case "SQLITE_CONSTRAINT_TRIGGER":
            case "SQLITE_CONSTRAINT_FOREIGNKEY":
            case "SQLITE_CONSTRAINT":
                {
                    if (err.message.includes("FOREIGN KEY constraint failed")) {
                        return new sequelizeErrors.ForeignKeyConstraintError({
                            parent: err,
                            stack: errStack
                        });
                    }
                    let fields = [];
                    let match = err.message.match(/columns (.*?) are/);
                    if (match !== null && match.length >= 2) {
                        fields = match[1].split(", ");
                    } else {
                        match = err.message.match(/UNIQUE constraint failed: (.*)/);
                        if (match !== null && match.length >= 2) {
                            fields = match[1].split(", ").map((columnWithTable)=>columnWithTable.split(".")[1]);
                        }
                    }
                    const errors = [];
                    let message = "Validation error";
                    for (const field of fields){
                        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, this.instance && this.instance[field], this.instance, "not_unique"));
                    }
                    if (this.model) {
                        _.forOwn(this.model.uniqueKeys, (constraint)=>{
                            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {
                                message = constraint.msg;
                                return false;
                            }
                        });
                    }
                    return new sequelizeErrors.UniqueConstraintError({
                        message,
                        errors,
                        parent: err,
                        fields,
                        stack: errStack
                    });
                }
            case "SQLITE_BUSY":
                return new sequelizeErrors.TimeoutError(err, {
                    stack: errStack
                });
            default:
                return new sequelizeErrors.DatabaseError(err, {
                    stack: errStack
                });
        }
    }
    async handleShowIndexesQuery(data) {
        return Promise.all(data.reverse().map(async (item)=>{
            item.fields = [];
            item.primary = false;
            item.unique = !!item.unique;
            item.constraintName = item.name;
            const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
            for (const column of columns){
                item.fields[column.seqno] = {
                    attribute: column.name,
                    length: void 0,
                    order: void 0
                };
            }
            return item;
        }));
    }
    getDatabaseMethod() {
        if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes("CREATE TEMPORARY TABLE".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
            return "run";
        }
        return "all";
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Transaction = __turbopack_context__.r("[project]/node_modules/sequelize/lib/transaction.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const MySqlQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/query-generator.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
class SQLiteQueryGenerator extends MySqlQueryGenerator {
    createSchema() {
        return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
    showSchemasQuery() {
        return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
    versionQuery() {
        return "SELECT sqlite_version() as `version`";
    }
    createTableQuery(tableName, attributes, options) {
        options = options || {};
        const primaryKeys = [];
        const needsMultiplePrimaryKeys = Object.values(attributes).filter((definition)=>definition.includes("PRIMARY KEY")).length > 1;
        const attrArray = [];
        for(const attr in attributes){
            if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
                const dataType = attributes[attr];
                const containsAutoIncrement = dataType.includes("AUTOINCREMENT");
                let dataTypeString = dataType;
                if (dataType.includes("PRIMARY KEY")) {
                    if (dataType.includes("INT")) {
                        dataTypeString = containsAutoIncrement ? "INTEGER PRIMARY KEY AUTOINCREMENT" : "INTEGER PRIMARY KEY";
                        if (dataType.includes(" REFERENCES")) {
                            dataTypeString += dataType.substr(dataType.indexOf(" REFERENCES"));
                        }
                    }
                    if (needsMultiplePrimaryKeys) {
                        primaryKeys.push(attr);
                        if (dataType.includes("NOT NULL")) {
                            dataTypeString = dataType.replace(" PRIMARY KEY", "");
                        } else {
                            dataTypeString = dataType.replace("PRIMARY KEY", "NOT NULL");
                        }
                    }
                }
                attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);
            }
        }
        const table = this.quoteTable(tableName);
        let attrStr = attrArray.join(", ");
        const pkString = primaryKeys.map((pk)=>this.quoteIdentifier(pk)).join(", ");
        if (options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns)=>{
                if (columns.customIndex) {
                    attrStr += `, UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                }
            });
        }
        if (pkString.length > 0) {
            attrStr += `, PRIMARY KEY (${pkString})`;
        }
        const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;
        return this.replaceBooleanDefaults(sql);
    }
    booleanValue(value) {
        return value ? 1 : 0;
    }
    _checkValidJsonStatement(stmt) {
        if (typeof stmt !== "string") {
            return false;
        }
        const jsonFunctionRegex = /^\s*(json(?:_[a-z]+){0,2})\([^)]*\)/i;
        const tokenCaptureRegex = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
        let currentIndex = 0;
        let openingBrackets = 0;
        let closingBrackets = 0;
        let hasJsonFunction = false;
        let hasInvalidToken = false;
        while(currentIndex < stmt.length){
            const string = stmt.substr(currentIndex);
            const functionMatches = jsonFunctionRegex.exec(string);
            if (functionMatches) {
                currentIndex += functionMatches[0].indexOf("(");
                hasJsonFunction = true;
                continue;
            }
            const tokenMatches = tokenCaptureRegex.exec(string);
            if (tokenMatches) {
                const capturedToken = tokenMatches[1];
                if (capturedToken === "(") {
                    openingBrackets++;
                } else if (capturedToken === ")") {
                    closingBrackets++;
                } else if (capturedToken === ";") {
                    hasInvalidToken = true;
                    break;
                }
                currentIndex += tokenMatches[0].length;
                continue;
            }
            break;
        }
        hasInvalidToken |= openingBrackets !== closingBrackets;
        if (hasJsonFunction && hasInvalidToken) {
            throw new Error(`Invalid json statement: ${stmt}`);
        }
        return hasJsonFunction;
    }
    _toJSONValue(value) {
        if (value instanceof Date) {
            return value.toISOString();
        }
        if (Array.isArray(value) && value[0] instanceof Date) {
            return value.map((val)=>val.toISOString());
        }
        return value;
    }
    handleSequelizeMethod(smth, tableName, factory, options, prepend) {
        if (smth instanceof Utils.Json) {
            return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);
        }
        if (smth instanceof Utils.Cast) {
            if (/timestamp/i.test(smth.type)) {
                smth.type = "datetime";
            }
        }
        return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
    }
    addColumnQuery(table, key, dataType) {
        const attributes = {};
        attributes[key] = dataType;
        const fields = this.attributesToSQL(attributes, {
            context: "addColumn"
        });
        const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;
        const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;
        return this.replaceBooleanDefaults(sql);
    }
    showTablesQuery() {
        return "SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';";
    }
    updateQuery(tableName, attrValueHash, where, options, attributes) {
        options = options || {};
        _.defaults(options, this.options);
        attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
        const modelAttributeMap = {};
        const values = [];
        const bind = [];
        const bindParam = options.bindParam || this.bindParam(bind);
        if (attributes) {
            _.each(attributes, (attribute, key)=>{
                modelAttributeMap[key] = attribute;
                if (attribute.field) {
                    modelAttributeMap[attribute.field] = attribute;
                }
            });
        }
        for(const key in attrValueHash){
            const value = attrValueHash[key];
            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
                values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                })}`);
            } else {
                values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                }, bindParam)}`);
            }
        }
        let query;
        const whereOptions = __spreadProps(__spreadValues({}, options), {
            bindParam
        });
        if (options.limit) {
            query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(",")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;
        } else {
            query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(",")} ${this.whereQuery(where, whereOptions)}`;
        }
        return {
            query,
            bind
        };
    }
    truncateTableQuery(tableName, options = {}) {
        return [
            `DELETE FROM ${this.quoteTable(tableName)}`,
            options.restartIdentity ? `; DELETE FROM ${this.quoteTable("sqlite_sequence")} WHERE ${this.quoteIdentifier("name")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), "`"), "'")};` : ""
        ].join("");
    }
    deleteQuery(tableName, where, options = {}, model) {
        _.defaults(options, this.options);
        let whereClause = this.getWhereConditions(where, null, model, options);
        if (whereClause) {
            whereClause = `WHERE ${whereClause}`;
        }
        if (options.limit) {
            whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;
        }
        return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;
    }
    attributesToSQL(attributes) {
        const result = {};
        for(const name in attributes){
            const dataType = attributes[name];
            const fieldName = dataType.field || name;
            if (_.isObject(dataType)) {
                let sql = dataType.type.toString();
                if (Object.prototype.hasOwnProperty.call(dataType, "allowNull") && !dataType.allowNull) {
                    sql += " NOT NULL";
                }
                if (Utils.defaultValueSchemable(dataType.defaultValue)) {
                    sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;
                }
                if (dataType.unique === true) {
                    sql += " UNIQUE";
                }
                if (dataType.primaryKey) {
                    sql += " PRIMARY KEY";
                    if (dataType.autoIncrement) {
                        sql += " AUTOINCREMENT";
                    }
                }
                if (dataType.references) {
                    const referencesTable = this.quoteTable(dataType.references.model);
                    let referencesKey;
                    if (dataType.references.key) {
                        referencesKey = this.quoteIdentifier(dataType.references.key);
                    } else {
                        referencesKey = this.quoteIdentifier("id");
                    }
                    sql += ` REFERENCES ${referencesTable} (${referencesKey})`;
                    if (dataType.onDelete) {
                        sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;
                    }
                    if (dataType.onUpdate) {
                        sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;
                    }
                }
                result[fieldName] = sql;
            } else {
                result[fieldName] = dataType;
            }
        }
        return result;
    }
    showIndexesQuery(tableName) {
        return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;
    }
    showConstraintsQuery(tableName, constraintName) {
        let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;
        if (constraintName) {
            sql += ` AND sql LIKE '%${constraintName}%'`;
        }
        return `${sql};`;
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;
    }
    describeTableQuery(tableName, schema, schemaDelimiter) {
        const table = {
            _schema: schema,
            _schemaDelimiter: schemaDelimiter,
            tableName
        };
        return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;
    }
    describeCreateTableQuery(tableName) {
        return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;
    }
    removeColumnQuery(tableName, attributes) {
        attributes = this.attributesToSQL(attributes);
        let backupTableName;
        if (typeof tableName === "object") {
            backupTableName = {
                tableName: `${tableName.tableName}_backup`,
                schema: tableName.schema
            };
        } else {
            backupTableName = `${tableName}_backup`;
        }
        const quotedTableName = this.quoteTable(tableName);
        const quotedBackupTableName = this.quoteTable(backupTableName);
        const attributeNames = Object.keys(attributes).map((attr)=>this.quoteIdentifier(attr)).join(", ");
        return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;
    }
    _alterConstraintQuery(tableName, attributes, createTableSql) {
        let backupTableName;
        attributes = this.attributesToSQL(attributes);
        if (typeof tableName === "object") {
            backupTableName = {
                tableName: `${tableName.tableName}_backup`,
                schema: tableName.schema
            };
        } else {
            backupTableName = `${tableName}_backup`;
        }
        const quotedTableName = this.quoteTable(tableName);
        const quotedBackupTableName = this.quoteTable(backupTableName);
        const attributeNames = Object.keys(attributes).map((attr)=>this.quoteIdentifier(attr)).join(", ");
        return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;
    }
    renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {
        let backupTableName;
        attributes = this.attributesToSQL(attributes);
        if (typeof tableName === "object") {
            backupTableName = {
                tableName: `${tableName.tableName}_backup`,
                schema: tableName.schema
            };
        } else {
            backupTableName = `${tableName}_backup`;
        }
        const quotedTableName = this.quoteTable(tableName);
        const quotedBackupTableName = this.quoteTable(backupTableName);
        const attributeNamesImport = Object.keys(attributes).map((attr)=>attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(", ");
        const attributeNamesExport = Object.keys(attributes).map((attr)=>this.quoteIdentifier(attr)).join(", ");
        return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;
    }
    startTransactionQuery(transaction) {
        if (transaction.parent) {
            return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;
        }
        return `BEGIN ${transaction.options.type} TRANSACTION;`;
    }
    setIsolationLevelQuery(value) {
        switch(value){
            case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
                return "-- SQLite is not able to choose the isolation level REPEATABLE READ.";
            case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
                return "PRAGMA read_uncommitted = ON;";
            case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
                return "PRAGMA read_uncommitted = OFF;";
            case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
                return "-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.";
            default:
                throw new Error(`Unknown isolation level: ${value}`);
        }
    }
    replaceBooleanDefaults(sql) {
        return sql.replace(/DEFAULT '?false'?/g, "DEFAULT 0").replace(/DEFAULT '?true'?/g, "DEFAULT 1");
    }
    getForeignKeysQuery(tableName) {
        return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;
    }
    tableExistsQuery(tableName) {
        return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;
    }
    quoteIdentifier(identifier, force) {
        return Utils.addTicks(Utils.removeTicks(identifier, "`"), "`");
    }
}
module.exports = SQLiteQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const { cloneDeep } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
class SQLiteQueryInterface extends QueryInterface {
    async removeColumn(tableName, attributeName, options) {
        options = options || {};
        const fields = await this.describeTable(tableName, options);
        delete fields[attributeName];
        const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
        const subQueries = sql.split(";").filter((q)=>q !== "");
        for (const subQuery of subQueries)await this.sequelize.query(`${subQuery};`, __spreadValues({
            raw: true
        }, options));
    }
    async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {
        options = options || {};
        const fields = await this.describeTable(tableName, options);
        Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));
        const sql = this.queryGenerator.removeColumnQuery(tableName, fields);
        const subQueries = sql.split(";").filter((q)=>q !== "");
        for (const subQuery of subQueries)await this.sequelize.query(`${subQuery};`, __spreadValues({
            raw: true
        }, options));
    }
    async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
        options = options || {};
        const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);
        fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);
        delete fields[attrNameBefore];
        const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
        const subQueries = sql.split(";").filter((q)=>q !== "");
        for (const subQuery of subQueries)await this.sequelize.query(`${subQuery};`, __spreadValues({
            raw: true
        }, options));
    }
    async removeConstraint(tableName, constraintName, options) {
        let createTableSql;
        const constraints = await this.showConstraint(tableName, constraintName);
        const constraint = constraints.find((constaint)=>constaint.constraintName === constraintName);
        if (!constraint) {
            throw new sequelizeErrors.UnknownConstraintError({
                message: `Constraint ${constraintName} on table ${tableName} does not exist`,
                constraint: constraintName,
                table: tableName
            });
        }
        createTableSql = constraint.sql;
        constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
        let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;
        if (constraint.constraintType === "FOREIGN KEY") {
            const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);
            constraint.referenceTableKeys = constraint.referenceTableKeys.map((columnName)=>this.queryGenerator.quoteIdentifier(columnName));
            const referenceTableKeys = constraint.referenceTableKeys.join(", ");
            constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;
            constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;
            constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;
        }
        createTableSql = createTableSql.replace(constraintSnippet, "");
        createTableSql += ";";
        const fields = await this.describeTable(tableName, options);
        const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
        const subQueries = sql.split(";").filter((q)=>q !== "");
        for (const subQuery of subQueries)await this.sequelize.query(`${subQuery};`, __spreadValues({
            raw: true
        }, options));
    }
    async addConstraint(tableName, options) {
        if (!options.fields) {
            throw new Error("Fields must be specified through options.fields");
        }
        if (!options.type) {
            throw new Error("Constraint type must be specified through options.type");
        }
        options = cloneDeep(options);
        const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);
        const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
        const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.SELECT,
            raw: true
        }));
        let sql = constraints[0].sql;
        const index = sql.length - 1;
        const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;
        const fields = await this.describeTable(tableName, options);
        sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);
        const subQueries = sql.split(";").filter((q)=>q !== "");
        for (const subQuery of subQueries)await this.sequelize.query(`${subQuery};`, __spreadValues({
            raw: true
        }, options));
    }
    async getForeignKeyReferencesForTable(tableName, options) {
        const database = this.sequelize.config.database;
        const query = this.queryGenerator.getForeignKeysQuery(tableName, database);
        const result = await this.sequelize.query(query, options);
        return result.map((row)=>({
                tableName,
                columnName: row.from,
                referencedTableName: row.table,
                referencedColumnName: row.to,
                tableCatalog: database,
                referencedTableCatalog: database
            }));
    }
    async dropAllTables(options) {
        options = options || {};
        const skip = options.skip || [];
        const tableNames = await this.showAllTables(options);
        await this.sequelize.query("PRAGMA foreign_keys = OFF", options);
        await this._dropAllTables(tableNames, skip, options);
        await this.sequelize.query("PRAGMA foreign_keys = ON", options);
    }
    async describeTable(tableName, options) {
        let schema = null;
        let schemaDelimiter = null;
        if (typeof options === "string") {
            schema = options;
        } else if (typeof options === "object" && options !== null) {
            schema = options.schema || null;
            schemaDelimiter = options.schemaDelimiter || null;
        }
        if (typeof tableName === "object" && tableName !== null) {
            schema = tableName.schema;
            tableName = tableName.tableName;
        }
        const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);
        options = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.DESCRIBE
        });
        const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);
        try {
            const data = await this.sequelize.query(sql, options);
            if (_.isEmpty(data)) {
                throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
            }
            const indexes = await this.sequelize.query(sqlIndexes, options);
            for(const prop in data){
                data[prop].unique = false;
            }
            for (const index of indexes){
                for (const field of index.fields){
                    if (index.unique !== void 0) {
                        data[field.attribute].unique = index.unique;
                    }
                }
            }
            const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);
            for (const foreignKey of foreignKeys){
                data[foreignKey.columnName].references = {
                    model: foreignKey.referencedTableName,
                    key: foreignKey.referencedColumnName
                };
            }
            return data;
        } catch (e) {
            if (e.original && e.original.code === "ER_NO_SUCH_TABLE") {
                throw new Error(`No description found for "${tableName}" table. Check the table name and schema; remember, they _are_ case sensitive.`);
            }
            throw e;
        }
    }
}
exports.SQLiteQueryInterface = SQLiteQueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/sqlite/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").sqlite;
const { SQLiteQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/query-interface.js [app-route] (ecmascript)");
class SqliteDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);
    }
}
SqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    DEFAULT: false,
    "DEFAULT VALUES": true,
    "UNION ALL": false,
    "RIGHT JOIN": false,
    inserts: {
        ignoreDuplicates: " OR IGNORE",
        updateOnDuplicate: " ON CONFLICT DO UPDATE SET",
        conflictFields: true,
        onConflictWhere: true
    },
    index: {
        using: false,
        where: true,
        functionBased: true
    },
    transactionOptions: {
        type: true
    },
    constraints: {
        addConstraint: false,
        dropConstraint: false
    },
    groupedLimit: false,
    JSON: true
});
SqliteDialect.prototype.defaultVersion = "3.8.0";
SqliteDialect.prototype.Query = Query;
SqliteDialect.prototype.DataTypes = DataTypes;
SqliteDialect.prototype.name = "sqlite";
SqliteDialect.prototype.TICK_CHAR = "`";
SqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;
SqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;
module.exports = SqliteDialect;
module.exports.SqliteDialect = SqliteDialect;
module.exports.default = SqliteDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").db2;
const debug = logger.debugContext("connection:db2");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("db2");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 3306;
        super(dialect, sequelize);
        this.lib = this._loadDialectModule("ibm_db");
        this.refreshTypeParser(DataTypes);
    }
    static _typecast(field, next) {
        if (parserStore.get(field.type)) {
            return parserStore.get(field.type)(field, this.sequelize.options, next);
        }
        return next();
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    async connect(config) {
        const connectionConfig = {
            database: config.database,
            hostname: config.host,
            port: config.port,
            uid: config.username,
            pwd: config.password
        };
        if (config.ssl) {
            connectionConfig["security"] = config.ssl;
        }
        if (config.sslcertificate) {
            connectionConfig["SSLServerCertificate"] = config.sslcertificate;
        }
        if (config.dialectOptions) {
            for (const key of Object.keys(config.dialectOptions)){
                connectionConfig[key] = config.dialectOptions[key];
            }
        }
        try {
            const connection = await new Promise((resolve, reject)=>{
                const connection2 = new this.lib.Database();
                connection2.lib = this.lib;
                connection2.open(connectionConfig, (error)=>{
                    if (error) {
                        if (error.message && error.message.includes("SQL30081N")) {
                            return reject(new sequelizeErrors.ConnectionRefusedError(error));
                        }
                        return reject(new sequelizeErrors.ConnectionError(error));
                    }
                    return resolve(connection2);
                });
            });
            return connection;
        } catch (err) {
            throw new sequelizeErrors.ConnectionError(err);
        }
    }
    disconnect(connection) {
        if (connection.connected) {
            connection.close((error)=>{
                if (error) {
                    debug(error);
                } else {
                    debug("connection closed");
                }
            });
        }
        return Promise.resolve();
    }
    validate(connection) {
        return connection && connection.connected;
    }
    _disconnect(connection) {
        return this.dialect.connectionManager.disconnect(connection);
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("db2");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const moment = __turbopack_context__.r("[project]/node_modules/moment/moment.js [app-route] (ecmascript)");
const debug = logger.debugContext("sql:db2");
class Query extends AbstractQuery {
    getInsertIdField() {
        return "id";
    }
    getSQLTypeFromJsType(value) {
        if (Buffer.isBuffer(value)) {
            return {
                ParamType: "INPUT",
                DataType: "BLOB",
                Data: value
            };
        }
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    }
    async _run(connection, sql, parameters) {
        this.sql = sql;
        const benchmark = this.sequelize.options.benchmark || this.options.benchmark;
        let queryBegin;
        if (benchmark) {
            queryBegin = Date.now();
        } else {
            this.sequelize.log(`Executing (${this.connection.uuid || "default"}): ${this.sql}`, this.options);
        }
        const errStack = new Error().stack;
        return new Promise((resolve, reject)=>{
            if (_.startsWith(this.sql, "BEGIN TRANSACTION")) {
                connection.beginTransaction((err)=>{
                    if (err) {
                        reject(this.formatError(err, errStack));
                    } else {
                        resolve(this.formatResults());
                    }
                });
            } else if (_.startsWith(this.sql, "COMMIT TRANSACTION")) {
                connection.commitTransaction((err)=>{
                    if (err) {
                        reject(this.formatError(err, errStack));
                    } else {
                        resolve(this.formatResults());
                    }
                });
            } else if (_.startsWith(this.sql, "ROLLBACK TRANSACTION")) {
                connection.rollbackTransaction((err)=>{
                    if (err) {
                        reject(this.formatError(err, errStack));
                    } else {
                        resolve(this.formatResults());
                    }
                });
            } else if (_.startsWith(this.sql, "SAVE TRANSACTION")) {
                connection.commitTransaction((err)=>{
                    if (err) {
                        reject(this.formatError(err, errStack));
                    } else {
                        connection.beginTransaction((err2)=>{
                            if (err2) {
                                reject(this.formatError(err2, errStack));
                            } else {
                                resolve(this.formatResults());
                            }
                        });
                    }
                }, this.options.transaction.name);
            } else {
                const params = [];
                if (parameters) {
                    _.forOwn(parameters, (value, key)=>{
                        const param = this.getSQLTypeFromJsType(value, key);
                        params.push(param);
                    });
                }
                const SQL = this.sql.toUpperCase();
                let newSql = this.sql;
                if ((this.isSelectQuery() || _.startsWith(SQL, "SELECT ")) && SQL.indexOf(" FROM ", 8) === -1) {
                    if (this.sql.charAt(this.sql.length - 1) === ";") {
                        newSql = this.sql.slice(0, this.sql.length - 1);
                    }
                    newSql += " FROM SYSIBM.SYSDUMMY1;";
                }
                connection.prepare(newSql, (err, stmt)=>{
                    if (err) {
                        reject(this.formatError(err, errStack));
                    }
                    stmt.execute(params, (err2, result, outparams)=>{
                        debug(`executed(${this.connection.uuid || "default"}):${newSql} ${parameters ? util.inspect(parameters, {
                            compact: true,
                            breakLength: Infinity
                        }) : ""}`);
                        if (benchmark) {
                            this.sequelize.log(`Executed (${this.connection.uuid || "default"}): ${newSql} ${parameters ? util.inspect(parameters, {
                                compact: true,
                                breakLength: Infinity
                            }) : ""}`, Date.now() - queryBegin, this.options);
                        }
                        if (err2 && err2.message) {
                            err2 = this.filterSQLError(err2, this.sql, connection);
                            if (err2 === null) {
                                stmt.closeSync();
                                resolve(this.formatResults([], 0));
                            }
                        }
                        if (err2) {
                            err2.sql = sql;
                            stmt.closeSync();
                            reject(this.formatError(err2, errStack, connection, parameters));
                        } else {
                            let data = [];
                            let metadata = [];
                            let affectedRows = 0;
                            if (typeof result === "object") {
                                if (_.startsWith(this.sql, "DELETE FROM ")) {
                                    affectedRows = result.getAffectedRowsSync();
                                } else {
                                    data = result.fetchAllSync();
                                    metadata = result.getColumnMetadataSync();
                                }
                                result.closeSync();
                            }
                            stmt.closeSync();
                            const datalen = data.length;
                            if (datalen > 0) {
                                const coltypes = {};
                                for(let i = 0; i < metadata.length; i++){
                                    coltypes[metadata[i].SQL_DESC_NAME] = metadata[i].SQL_DESC_TYPE_NAME;
                                }
                                for(let i = 0; i < datalen; i++){
                                    for(const column in data[i]){
                                        const parse = parserStore.get(coltypes[column]);
                                        const value = data[i][column];
                                        if (value !== null) {
                                            if (parse) {
                                                data[i][column] = parse(value);
                                            } else if (coltypes[column] === "TIMESTAMP") {
                                                data[i][column] = new Date(moment.utc(value));
                                            } else if (coltypes[column] === "BLOB") {
                                                data[i][column] = new Buffer.from(value);
                                            } else if (coltypes[column].indexOf("FOR BIT DATA") > 0) {
                                                data[i][column] = new Buffer.from(value, "hex");
                                            }
                                        }
                                    }
                                }
                                if (outparams && outparams.length) {
                                    data.unshift(outparams);
                                }
                                resolve(this.formatResults(data, datalen, metadata, connection));
                            } else {
                                resolve(this.formatResults(data, affectedRows));
                            }
                        }
                    });
                });
            }
        });
    }
    async run(sql, parameters) {
        return await this._run(this.connection, sql, parameters);
    }
    static formatBindParameters(sql, values, dialect) {
        let bindParam = {};
        const replacementFunc = (match, key, values2)=>{
            if (values2[key] !== void 0) {
                bindParam[key] = values2[key];
                return "?";
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        if (Array.isArray(values) && typeof values[0] === "object") {
            bindParam = values;
        }
        return [
            sql,
            bindParam
        ];
    }
    filterSQLError(err, sql, connection) {
        if (err.message.search("SQL0204N") != -1 && _.startsWith(sql, "DROP ")) {
            err = null;
        } else if (err.message.search("SQL0443N") != -1) {
            if (this.isDropSchemaQuery()) {
                connection.querySync("DROP TABLE ERRORSCHEMA.ERRORTABLE;");
                connection.querySync(this.sql);
            }
            err = null;
        } else if (err.message.search("SQL0601N") != -1) {
            const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name "(.*)" of type "(.*)"./);
            if (match && match.length > 1 && match[2] === "TABLE") {
                let table;
                const mtarray = match[1].split(".");
                if (mtarray[1]) {
                    table = `"${mtarray[0]}"."${mtarray[1]}"`;
                } else {
                    table = `"${mtarray[0]}"`;
                }
                if (connection.dropTable !== false) {
                    connection.querySync(`DROP TABLE ${table}`);
                    err = connection.querySync(sql);
                } else {
                    err = null;
                }
            } else {
                err = null;
            }
        } else if (err.message.search("SQL0911N") != -1) {
            if (err.message.search('Reason code "2"') != -1) {
                err = null;
            }
        } else if (err.message.search("SQL0605W") != -1) {
            err = null;
        } else if (err.message.search("SQL0668N") != -1 && _.startsWith(sql, "ALTER TABLE ")) {
            connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(" ")[0]}')`);
            err = connection.querySync(sql);
        }
        if (err && err.length === 0) {
            err = null;
        }
        return err;
    }
    formatResults(data, rowCount, metadata, conn) {
        let result = this.instance;
        if (this.isInsertQuery(data, metadata)) {
            this.handleInsertQuery(data, metadata);
            if (!this.instance) {
                if (this.options.plain) {
                    const record = data[0];
                    result = record[Object.keys(record)[0]];
                } else {
                    result = data;
                }
            }
        }
        if (this.isShowTablesQuery()) {
            result = data;
        } else if (this.isDescribeQuery()) {
            result = {};
            for (const _result of data){
                if (_result.Default) {
                    _result.Default = _result.Default.replace("('", "").replace("')", "").replace(/'/g, "");
                }
                result[_result.Name] = {
                    type: _result.Type.toUpperCase(),
                    allowNull: _result.IsNull === "Y" ? true : false,
                    defaultValue: _result.Default,
                    primaryKey: _result.KeySeq > 0,
                    autoIncrement: _result.IsIdentity === "Y" ? true : false,
                    comment: _result.Comment
                };
            }
        } else if (this.isShowIndexesQuery()) {
            result = this.handleShowIndexesQuery(data);
        } else if (this.isSelectQuery()) {
            result = this.handleSelectQuery(data);
        } else if (this.isUpsertQuery()) {
            result = data;
        } else if (this.isDropSchemaQuery()) {
            result = data[0];
            if (conn) {
                const query = "DROP TABLE ERRORSCHEMA.ERRORTABLE";
                conn.querySync(query);
            }
        } else if (this.isCallQuery()) {
            result = data;
        } else if (this.isBulkUpdateQuery()) {
            result = data.length;
        } else if (this.isBulkDeleteQuery()) {
            result = rowCount;
        } else if (this.isVersionQuery()) {
            result = data[0].VERSION;
        } else if (this.isForeignKeysQuery()) {
            result = data;
        } else if (this.isInsertQuery() || this.isUpdateQuery()) {
            result = [
                result,
                rowCount
            ];
        } else if (this.isShowConstraintsQuery()) {
            result = this.handleShowConstraintsQuery(data);
        } else if (this.isRawQuery()) {
            result = [
                data,
                metadata
            ];
        } else {
            result = data;
        }
        return result;
    }
    handleShowTablesQuery(results) {
        return results.map((resultSet)=>{
            return {
                tableName: resultSet.TABLE_NAME,
                schema: resultSet.TABLE_SCHEMA
            };
        });
    }
    handleShowConstraintsQuery(data) {
        return _.remove(data, (constraint)=>{
            return !_.startsWith(constraint.constraintName, "SQL");
        });
    }
    formatError(err, errStack, conn, parameters) {
        let match;
        if (!(err && err.message)) {
            err["message"] = "No error message found.";
        }
        match = err.message.match(/SQL0803N {2}One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by "(\d)+" constrains table "(.*)\.(.*)" from having duplicate values for the index key./);
        if (match && match.length > 0) {
            let uniqueIndexName = "";
            let uniqueKey = "";
            const fields = {};
            let message = err.message;
            const query = `SELECT INDNAME FROM SYSCAT.INDEXES  WHERE IID = ${match[1]} AND TABSCHEMA = '${match[2]}' AND TABNAME = '${match[3]}'`;
            if (!!conn && match.length > 3) {
                uniqueIndexName = conn.querySync(query);
                uniqueIndexName = uniqueIndexName[0]["INDNAME"];
            }
            if (this.model && !!uniqueIndexName) {
                uniqueKey = this.model.uniqueKeys[uniqueIndexName];
            }
            if (!uniqueKey && this.options.fields) {
                uniqueKey = this.options.fields[match[1] - 1];
            }
            if (uniqueKey) {
                if (this.options.where && this.options.where[uniqueKey.column] !== void 0) {
                    fields[uniqueKey.column] = this.options.where[uniqueKey.column];
                } else if (this.options.instance && this.options.instance.dataValues && this.options.instance.dataValues[uniqueKey.column]) {
                    fields[uniqueKey.column] = this.options.instance.dataValues[uniqueKey.column];
                } else if (parameters) {
                    fields[uniqueKey.column] = parameters["0"];
                }
            }
            if (uniqueKey && !!uniqueKey.msg) {
                message = uniqueKey.msg;
            }
            const errors = [];
            _.forOwn(fields, (value, field)=>{
                errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
            });
            return new sequelizeErrors.UniqueConstraintError({
                message,
                errors,
                parent: err,
                fields,
                stack: errStack
            });
        }
        match = err.message.match(/SQL0532N {2}A parent row cannot be deleted because the relationship "(.*)" restricts the deletion/) || err.message.match(/SQL0530N/) || err.message.match(/SQL0531N/);
        if (match && match.length > 0) {
            return new sequelizeErrors.ForeignKeyConstraintError({
                fields: null,
                index: match[1],
                parent: err,
                stack: errStack
            });
        }
        match = err.message.match(/SQL0204N {2}"(.*)" is an undefined name./);
        if (match && match.length > 1) {
            const constraint = match[1];
            let table = err.sql.match(/table "(.+?)"/i);
            table = table ? table[1] : void 0;
            return new sequelizeErrors.UnknownConstraintError({
                message: match[0],
                constraint,
                table,
                parent: err,
                stack: errStack
            });
        }
        return new sequelizeErrors.DatabaseError(err, {
            stack: errStack
        });
    }
    isDropSchemaQuery() {
        let result = false;
        if (_.startsWith(this.sql, "CALL SYSPROC.ADMIN_DROP_SCHEMA")) {
            result = true;
        }
        return result;
    }
    isShowOrDescribeQuery() {
        let result = false;
        result = result || this.sql.toLowerCase().startsWith("select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'");
        result = result || this.sql.toLowerCase().startsWith("select tablename = t.name, name = ind.name,");
        result = result || this.sql.toLowerCase().startsWith("exec sys.sp_helpindex @objname");
        return result;
    }
    isShowIndexesQuery() {
        let result = false;
        result = result || this.sql.toLowerCase().startsWith("exec sys.sp_helpindex @objname");
        result = result || this.sql.startsWith('SELECT NAME AS "name", TBNAME AS "tableName", UNIQUERULE AS "keyType", COLNAMES, INDEXTYPE AS "type" FROM SYSIBM.SYSINDEXES');
        return result;
    }
    handleShowIndexesQuery(data) {
        let currItem;
        const result = [];
        data.forEach((item)=>{
            if (!currItem || currItem.name !== item.Key_name) {
                currItem = {
                    primary: item.keyType === "P",
                    fields: [],
                    name: item.name,
                    tableName: item.tableName,
                    unique: item.keyType === "U",
                    type: item.type
                };
                _.forEach(item.COLNAMES.replace(/\+|-/g, (x)=>{
                    return ` ${x}`;
                }).split(" "), (column)=>{
                    let columnName = column.trim();
                    if (columnName) {
                        columnName = columnName.replace(/\+|-/, "");
                        currItem.fields.push({
                            attribute: columnName,
                            length: void 0,
                            order: column.indexOf("-") === -1 ? "ASC" : "DESC",
                            collate: void 0
                        });
                    }
                });
                result.push(currItem);
            }
        });
        return result;
    }
    handleInsertQuery(results, metaData) {
        if (this.instance) {
            const autoIncrementAttribute = this.model.autoIncrementAttribute;
            let id = null;
            let autoIncrementAttributeAlias = null;
            if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0) autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;
            id = id || results && results[0][this.getInsertIdField()];
            id = id || metaData && metaData[this.getInsertIdField()];
            id = id || results && results[0][autoIncrementAttribute];
            id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];
            this.instance[autoIncrementAttribute] = id;
        }
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const randomBytes = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)").randomBytes;
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const throwMethodUndefined = function(methodName) {
    throw new Error(`The method "${methodName}" is not defined! Please add it to your sql dialect.`);
};
class Db2QueryGenerator extends AbstractQueryGenerator {
    constructor(options){
        super(options);
        this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {
            [Op.regexp]: "REGEXP_LIKE",
            [Op.notRegexp]: "NOT REGEXP_LIKE"
        });
        this.autoGenValue = 1;
    }
    createSchema(schema) {
        return [
            "CREATE SCHEMA",
            this.quoteIdentifier(schema),
            ";"
        ].join(" ");
    }
    dropSchema(schema) {
        const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;
        const sql = {
            query
        };
        sql.bind = [
            {
                ParamType: "INOUT",
                Data: "ERRORSCHEMA"
            },
            {
                ParamType: "INOUT",
                Data: "ERRORTABLE"
            }
        ];
        return sql;
    }
    showSchemasQuery() {
        return `SELECT SCHEMANAME AS "schema_name" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;
    }
    versionQuery() {
        return "select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A";
    }
    createTableQuery(tableName, attributes, options) {
        const query = "CREATE TABLE <%= table %> (<%= attributes %>)", primaryKeys = [], foreignKeys = {}, attrStr = [], commentTemplate = " -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;";
        let commentStr = "";
        for(const attr in attributes){
            if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
                let dataType = attributes[attr];
                let match;
                if (dataType.includes("COMMENT ")) {
                    const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
                    if (commentMatch && commentMatch.length > 2) {
                        const commentText = commentMatch[2].replace(/COMMENT/, "").trim();
                        commentStr += _.template(commentTemplate, this._templateSettings)({
                            table: this.quoteIdentifier(tableName),
                            comment: this.escape(commentText),
                            column: this.quoteIdentifier(attr)
                        });
                        dataType = commentMatch[1];
                    }
                }
                if (_.includes(dataType, "PRIMARY KEY")) {
                    primaryKeys.push(attr);
                    if (_.includes(dataType, "REFERENCES")) {
                        match = dataType.match(/^(.+) (REFERENCES.*)$/);
                        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, "")}`);
                        foreignKeys[attr] = match[2];
                    } else {
                        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, "")}`);
                    }
                } else if (_.includes(dataType, "REFERENCES")) {
                    match = dataType.match(/^(.+) (REFERENCES.*)$/);
                    attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
                    foreignKeys[attr] = match[2];
                } else {
                    if (options && options.uniqueKeys) {
                        for(const ukey in options.uniqueKeys){
                            if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, "NOT NULL")) {
                                dataType += " NOT NULL";
                                break;
                            }
                        }
                    }
                    attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
                }
            }
        }
        const values = {
            table: this.quoteTable(tableName),
            attributes: attrStr.join(", ")
        }, pkString = primaryKeys.map((pk)=>{
            return this.quoteIdentifier(pk);
        }).join(", ");
        if (options && options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns, indexName)=>{
                if (columns.customIndex) {
                    if (!_.isString(indexName)) {
                        indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
                    }
                    values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                }
            });
        }
        if (pkString.length > 0) {
            values.attributes += `, PRIMARY KEY (${pkString})`;
        }
        for(const fkey in foreignKeys){
            if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
                values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
            }
        }
        return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;
    }
    describeTableQuery(tableName, schema) {
        let sql = [
            'SELECT NAME AS "Name", TBNAME AS "Table", TBCREATOR AS "Schema",',
            'TRIM(COLTYPE) AS "Type", LENGTH AS "Length", SCALE AS "Scale",',
            'NULLS AS "IsNull", DEFAULT AS "Default", COLNO AS "Colno",',
            'IDENTITY AS "IsIdentity", KEYSEQ AS "KeySeq", REMARKS AS "Comment"',
            "FROM",
            "SYSIBM.SYSCOLUMNS",
            "WHERE TBNAME =",
            wrapSingleQuote(tableName)
        ].join(" ");
        if (schema) {
            sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;
        } else {
            sql += " AND TBCREATOR = USER";
        }
        return `${sql};`;
    }
    renameTableQuery(before, after) {
        const query = "RENAME TABLE <%= before %> TO <%= after %>;";
        return _.template(query, this._templateSettings)({
            before: this.quoteTable(before),
            after: this.quoteTable(after)
        });
    }
    showTablesQuery() {
        return `SELECT TABNAME AS "tableName", TRIM(TABSCHEMA) AS "tableSchema" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;
    }
    tableExistsQuery(table) {
        const tableName = table.tableName || table;
        const schemaName = table.schema || this.sequelize.config.username.toUpperCase();
        return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;
    }
    dropTableQuery(tableName) {
        const query = "DROP TABLE <%= table %>";
        const values = {
            table: this.quoteTable(tableName)
        };
        return `${_.template(query, this._templateSettings)(values).trim()};`;
    }
    addColumnQuery(table, key, dataType) {
        dataType.field = key;
        const query = "ALTER TABLE <%= table %> ADD <%= attribute %>;", attribute = _.template("<%= key %> <%= definition %>", this._templateSettings)({
            key: this.quoteIdentifier(key),
            definition: this.attributeToSQL(dataType, {
                context: "addColumn"
            })
        });
        return _.template(query, this._templateSettings)({
            table: this.quoteTable(table),
            attribute
        });
    }
    removeColumnQuery(tableName, attributeName) {
        const query = "ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;";
        return _.template(query, this._templateSettings)({
            tableName: this.quoteTable(tableName),
            attributeName: this.quoteIdentifier(attributeName)
        });
    }
    changeColumnQuery(tableName, attributes) {
        const query = "ALTER TABLE <%= tableName %> <%= query %>;";
        const attrString = [], constraintString = [];
        for(const attributeName in attributes){
            const attrValue = attributes[attributeName];
            let defs = [
                attrValue
            ];
            if (Array.isArray(attrValue)) {
                defs = attrValue;
            }
            for(let i = 0; i < defs.length; i++){
                const definition = defs[i];
                if (definition.match(/REFERENCES/)) {
                    constraintString.push(_.template("<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>", this._templateSettings)({
                        fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),
                        attrName: this.quoteIdentifier(attributeName),
                        definition: definition.replace(/.+?(?=REFERENCES)/, "")
                    }));
                } else if (_.startsWith(definition, "DROP ")) {
                    attrString.push(_.template("<%= attrName %> <%= definition %>", this._templateSettings)({
                        attrName: this.quoteIdentifier(attributeName),
                        definition
                    }));
                } else {
                    attrString.push(_.template("<%= attrName %> SET <%= definition %>", this._templateSettings)({
                        attrName: this.quoteIdentifier(attributeName),
                        definition
                    }));
                }
            }
        }
        let finalQuery = "";
        if (attrString.length) {
            finalQuery += `ALTER COLUMN ${attrString.join(" ALTER COLUMN ")}`;
            finalQuery += constraintString.length ? " " : "";
        }
        if (constraintString.length) {
            finalQuery += `ADD CONSTRAINT ${constraintString.join(" ADD CONSTRAINT ")}`;
        }
        return _.template(query, this._templateSettings)({
            tableName: this.quoteTable(tableName),
            query: finalQuery
        });
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const query = "ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;", newName = Object.keys(attributes)[0];
        return _.template(query, this._templateSettings)({
            tableName: this.quoteTable(tableName),
            before: this.quoteIdentifier(attrBefore),
            after: this.quoteIdentifier(newName)
        });
    }
    addConstraintQuery(tableName, options) {
        options = options || {};
        if (options.onUpdate && options.onUpdate.toUpperCase() === "CASCADE") {
            delete options.onUpdate;
        }
        const constraintSnippet = this.getConstraintSnippet(tableName, options);
        if (typeof tableName === "string") {
            tableName = this.quoteIdentifiers(tableName);
        } else {
            tableName = this.quoteTable(tableName);
        }
        return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;
    }
    bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
        options = options || {};
        attributes = attributes || {};
        let query = "INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;";
        if (options.returning) {
            query = "SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);";
        }
        const emptyQuery = "INSERT INTO <%= table %>", tuples = [], allAttributes = [], allQueries = [];
        let outputFragment;
        const valuesForEmptyQuery = [];
        if (options.returning) {
            outputFragment = "";
        }
        _.forEach(attrValueHashes, (attrValueHash)=>{
            const fields = Object.keys(attrValueHash);
            const firstAttr = attributes[fields[0]];
            if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {
                valuesForEmptyQuery.push(`(${this.autoGenValue++})`);
                return;
            }
            _.forOwn(attrValueHash, (value, key)=>{
                if (allAttributes.indexOf(key) === -1) {
                    if (value === null && attributes[key] && attributes[key].autoIncrement) return;
                    allAttributes.push(key);
                }
            });
        });
        if (valuesForEmptyQuery.length > 0) {
            allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(",")}`);
        }
        if (allAttributes.length > 0) {
            _.forEach(attrValueHashes, (attrValueHash)=>{
                tuples.push(`(${allAttributes.map((key)=>this.escape(attrValueHash[key]), void 0, {
                    context: "INSERT"
                }).join(",")})`);
            });
            allQueries.push(query);
        }
        const replacements = {
            table: this.quoteTable(tableName),
            attributes: allAttributes.map((attr)=>this.quoteIdentifier(attr)).join(","),
            tuples,
            output: outputFragment
        };
        const generatedQuery = _.template(allQueries.join(";"), this._templateSettings)(replacements);
        return generatedQuery;
    }
    updateQuery(tableName, attrValueHash, where, options, attributes) {
        const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
        options = options || {};
        _.defaults(options, this.options);
        if (!options.limit) {
            sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;
            return sql;
        }
        attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);
        const modelAttributeMap = {};
        const values = [];
        const bind = [];
        const bindParam = options.bindParam || this.bindParam(bind);
        if (attributes) {
            _.each(attributes, (attribute, key)=>{
                modelAttributeMap[key] = attribute;
                if (attribute.field) {
                    modelAttributeMap[attribute.field] = attribute;
                }
            });
        }
        for(const key in attrValueHash){
            const value = attrValueHash[key];
            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {
                values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                })}`);
            } else {
                values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {
                    context: "UPDATE"
                }, bindParam)}`);
            }
        }
        let query;
        const whereOptions = _.defaults({
            bindParam
        }, options);
        query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(",")}`;
        query = `SELECT * FROM FINAL TABLE (${query});`;
        return {
            query,
            bind
        };
    }
    upsertQuery(tableName, insertValues, updateValues, where, model) {
        const targetTableAlias = this.quoteTable(`${tableName}_target`);
        const sourceTableAlias = this.quoteTable(`${tableName}_source`);
        const primaryKeysAttrs = [];
        const identityAttrs = [];
        const uniqueAttrs = [];
        const tableNameQuoted = this.quoteTable(tableName);
        for(const key in model.rawAttributes){
            if (model.rawAttributes[key].primaryKey) {
                primaryKeysAttrs.push(model.rawAttributes[key].field || key);
            }
            if (model.rawAttributes[key].unique) {
                uniqueAttrs.push(model.rawAttributes[key].field || key);
            }
            if (model.rawAttributes[key].autoIncrement) {
                identityAttrs.push(model.rawAttributes[key].field || key);
            }
        }
        for (const index of model._indexes){
            if (index.unique && index.fields) {
                for (const field of index.fields){
                    const fieldName = typeof field === "string" ? field : field.name || field.attribute;
                    if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {
                        uniqueAttrs.push(fieldName);
                    }
                }
            }
        }
        const updateKeys = Object.keys(updateValues);
        const insertKeys = Object.keys(insertValues);
        const insertKeysQuoted = insertKeys.map((key)=>this.quoteIdentifier(key)).join(", ");
        const insertValuesEscaped = insertKeys.map((key)=>this.escape(insertValues[key])).join(", ");
        const sourceTableQuery = `VALUES(${insertValuesEscaped})`;
        let joinCondition;
        const clauses = where[Op.or].filter((clause)=>{
            let valid = true;
            for(const key in clause){
                if (!clause[key]) {
                    valid = false;
                    break;
                }
            }
            return valid;
        });
        const getJoinSnippet = (array)=>{
            return array.map((key)=>{
                key = this.quoteIdentifier(key);
                return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
            });
        };
        if (clauses.length === 0) {
            throw new Error("Primary Key or Unique key should be passed to upsert query");
        } else {
            for(const key in clauses){
                const keys = Object.keys(clauses[key]);
                if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {
                    joinCondition = getJoinSnippet(primaryKeysAttrs).join(" AND ");
                    break;
                }
            }
            if (!joinCondition) {
                joinCondition = getJoinSnippet(uniqueAttrs).join(" AND ");
            }
        }
        const filteredUpdateClauses = updateKeys.filter((key)=>{
            if (identityAttrs.indexOf(key) === -1) {
                return true;
            }
            return false;
        }).map((key)=>{
            const value = this.escape(updateValues[key]);
            key = this.quoteIdentifier(key);
            return `${targetTableAlias}.${key} = ${value}`;
        }).join(", ");
        const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : "";
        const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
        let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
        query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;
        return query;
    }
    truncateTableQuery(tableName) {
        return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;
    }
    deleteQuery(tableName, where, options = {}, model) {
        const table = this.quoteTable(tableName);
        const query = "DELETE FROM <%= table %><%= where %><%= limit %>";
        where = this.getWhereConditions(where, null, model, options);
        let limit = "";
        if (options.offset > 0) {
            limit = ` OFFSET ${this.escape(options.offset)} ROWS`;
        }
        if (options.limit) {
            limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
        }
        const replacements = {
            limit,
            table,
            where
        };
        if (replacements.where) {
            replacements.where = ` WHERE ${replacements.where}`;
        }
        return _.template(query, this._templateSettings)(replacements);
    }
    showIndexesQuery(tableName) {
        let sql = 'SELECT NAME AS "name", TBNAME AS "tableName", UNIQUERULE AS "keyType", COLNAMES, INDEXTYPE AS "type" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';
        let schema = void 0;
        if (_.isObject(tableName)) {
            schema = tableName.schema;
            tableName = tableName.tableName;
        }
        if (schema) {
            sql = `${sql} AND TBCREATOR = <%= schemaName %>`;
        }
        sql = `${sql} ORDER BY NAME;`;
        return _.template(sql, this._templateSettings)({
            tableName: wrapSingleQuote(tableName),
            schemaName: wrapSingleQuote(schema)
        });
    }
    showConstraintsQuery(tableName, constraintName) {
        let sql = `SELECT CONSTNAME AS "constraintName", TRIM(TABSCHEMA) AS "schemaName", TABNAME AS "tableName" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;
        if (constraintName) {
            sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;
        }
        return `${sql} ORDER BY CONSTNAME;`;
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        const sql = "DROP INDEX <%= indexName %>";
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        const values = {
            tableName: this.quoteIdentifiers(tableName),
            indexName: this.quoteIdentifiers(indexName)
        };
        return _.template(sql, this._templateSettings)(values);
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        let template;
        let changeNull = 1;
        if (attribute.type instanceof DataTypes.ENUM) {
            if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;
            template = attribute.type.toSql();
            template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value)=>{
                return this.escape(value);
            }).join(", ")}))`;
        } else {
            template = attribute.type.toString();
        }
        if (options && options.context === "changeColumn" && attribute.type) {
            template = `DATA TYPE ${template}`;
        } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {
            template += " NOT NULL";
            changeNull = 0;
        }
        if (attribute.autoIncrement) {
            let initialValue = 1;
            if (attribute.initialAutoIncrement) {
                initialValue = attribute.initialAutoIncrement;
            }
            template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;
        }
        if (attribute.type !== "TEXT" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
        }
        if (attribute.unique === true) {
            template += " UNIQUE";
        }
        if (attribute.primaryKey) {
            template += " PRIMARY KEY";
        }
        if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {
            if (options && options.context === "addColumn" && options.foreignKey) {
                const attrName = this.quoteIdentifier(options.foreignKey);
                const fkName = `${options.tableName}_${attrName}_fidx`;
                template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
            }
            template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
            if (attribute.references.key) {
                template += ` (${this.quoteIdentifier(attribute.references.key)})`;
            } else {
                template += ` (${this.quoteIdentifier("id")})`;
            }
            if (attribute.onDelete) {
                template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
            }
            if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != "CASCADE") {
                template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
            }
        }
        if (options && options.context === "changeColumn" && changeNull === 1 && attribute.allowNull !== void 0) {
            template = [
                template
            ];
            if (attribute.allowNull) {
                template.push("DROP NOT NULL");
            } else {
                template.push("NOT NULL");
            }
        }
        if (attribute.comment && typeof attribute.comment === "string") {
            template += ` COMMENT ${attribute.comment}`;
        }
        return template;
    }
    attributesToSQL(attributes, options) {
        const result = {}, existingConstraints = [];
        let key, attribute;
        for(key in attributes){
            attribute = attributes[key];
            if (attribute.references) {
                if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {
                    attribute.onDelete = "";
                    attribute.onUpdate = "";
                } else if (attribute.unique && attribute.unique === true) {
                    attribute.onDelete = "";
                    attribute.onUpdate = "";
                } else {
                    existingConstraints.push(attribute.references.model.toString());
                }
            }
            if (key && !attribute.field && typeof attribute === "object") attribute.field = key;
            result[attribute.field || key] = this.attributeToSQL(attribute, options);
        }
        return result;
    }
    createTrigger() {
        throwMethodUndefined("createTrigger");
    }
    dropTrigger() {
        throwMethodUndefined("dropTrigger");
    }
    renameTrigger() {
        throwMethodUndefined("renameTrigger");
    }
    createFunction() {
        throwMethodUndefined("createFunction");
    }
    dropFunction() {
        throwMethodUndefined("dropFunction");
    }
    renameFunction() {
        throwMethodUndefined("renameFunction");
    }
    _getForeignKeysQuerySQL(condition) {
        return `SELECT R.CONSTNAME AS "constraintName", TRIM(R.TABSCHEMA) AS "constraintSchema", R.TABNAME AS "tableName", TRIM(R.TABSCHEMA) AS "tableSchema", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS "columnName", TRIM(R.REFTABSCHEMA) AS "referencedTableSchema", R.REFTABNAME AS "referencedTableName", TRIM(R.PK_COLNAMES) AS "referencedColumnName" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;
    }
    getForeignKeysQuery(table, schemaName) {
        const tableName = table.tableName || table;
        schemaName = table.schema || schemaName;
        let sql = "";
        if (tableName) {
            sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;
        }
        if (schemaName) {
            sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;
        }
        return this._getForeignKeysQuerySQL(sql);
    }
    getForeignKeyQuery(table, columnName) {
        const tableName = table.tableName || table;
        const schemaName = table.schema;
        let sql = "";
        if (tableName) {
            sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;
        }
        if (schemaName) {
            sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;
        }
        if (columnName) {
            sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;
        }
        return this._getForeignKeysQuerySQL(sql);
    }
    getPrimaryKeyConstraintQuery(table, attributeName) {
        const tableName = wrapSingleQuote(table.tableName || table);
        return [
            'SELECT TABNAME AS "tableName",',
            'COLNAME AS "columnName",',
            'CONSTNAME AS "constraintName"',
            "FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'",
            `AND COLNAME = ${wrapSingleQuote(attributeName)}`,
            `AND TABNAME = ${tableName};`
        ].join(" ");
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return _.template("ALTER TABLE <%= table %> DROP <%= key %>", this._templateSettings)({
            table: this.quoteTable(tableName),
            key: this.quoteIdentifier(foreignKey)
        });
    }
    dropConstraintQuery(tableName, constraintName) {
        const sql = "ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;";
        return _.template(sql, this._templateSettings)({
            table: this.quoteTable(tableName),
            constraint: this.quoteIdentifier(constraintName)
        });
    }
    setAutocommitQuery() {
        return "";
    }
    setIsolationLevelQuery() {}
    generateTransactionId() {
        return randomBytes(10).toString("hex");
    }
    startTransactionQuery(transaction) {
        if (transaction.parent) {
            return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
        }
        return "BEGIN TRANSACTION;";
    }
    commitTransactionQuery(transaction) {
        if (transaction.parent) {
            return;
        }
        return "COMMIT TRANSACTION;";
    }
    rollbackTransactionQuery(transaction) {
        if (transaction.parent) {
            return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
        }
        return "ROLLBACK TRANSACTION;";
    }
    addLimitAndOffset(options) {
        const offset = options.offset || 0;
        let fragment = "";
        if (offset > 0) {
            fragment += ` OFFSET ${this.escape(offset)} ROWS`;
        }
        if (options.limit) {
            fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
        }
        return fragment;
    }
    booleanValue(value) {
        return value ? 1 : 0;
    }
    addUniqueFields(dataValues, rawAttributes, uniqno) {
        uniqno = uniqno === void 0 ? 1 : uniqno;
        for(const key in rawAttributes){
            if (rawAttributes[key].unique && dataValues[key] === void 0) {
                if (rawAttributes[key].type instanceof DataTypes.DATE) {
                    dataValues[key] = Utils.now("db2");
                } else if (rawAttributes[key].type instanceof DataTypes.STRING) {
                    dataValues[key] = `unique${uniqno++}`;
                } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {
                    dataValues[key] = uniqno++;
                } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {
                    dataValues[key] = new DataTypes.BOOLEAN(false);
                }
            }
        }
        return uniqno;
    }
    quoteIdentifier(identifier, force) {
        return Utils.addTicks(Utils.removeTicks(identifier, '"'), '"');
    }
}
function wrapSingleQuote(identifier) {
    if (identifier) {
        return `'${identifier}'`;
    }
    return "";
}
module.exports = Db2QueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
class Db2QueryInterface extends QueryInterface {
    async getForeignKeyReferencesForTable(tableName, options) {
        const queryOptions = __spreadProps(__spreadValues({}, options), {
            type: QueryTypes.FOREIGNKEYS
        });
        const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());
        return this.sequelize.query(query, queryOptions);
    }
    async upsert(tableName, insertValues, updateValues, where, options) {
        options = __spreadValues({}, options);
        const model = options.model;
        const wheres = [];
        const attributes = Object.keys(insertValues);
        let indexes = [];
        let indexFields;
        options = _.clone(options);
        if (!Utils.isWhereEmpty(where)) {
            wheres.push(where);
        }
        indexes = _.map(model.uniqueKeys, (value)=>{
            return value.fields;
        });
        model._indexes.forEach((value)=>{
            if (value.unique) {
                indexFields = value.fields.map((field)=>{
                    if (_.isPlainObject(field)) {
                        return field.attribute;
                    }
                    return field;
                });
                indexes.push(indexFields);
            }
        });
        for (const index of indexes){
            if (_.intersection(attributes, index).length === index.length) {
                where = {};
                for (const field of index){
                    where[field] = insertValues[field];
                }
                wheres.push(where);
            }
        }
        where = {
            [Op.or]: wheres
        };
        options.type = QueryTypes.UPSERT;
        options.raw = true;
        const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);
        const result = await this.sequelize.query(sql, options);
        return [
            result,
            void 0
        ];
    }
    async createTable(tableName, attributes, options, model) {
        let sql = "";
        options = __spreadValues({}, options);
        if (options && options.uniqueKeys) {
            _.forOwn(options.uniqueKeys, (uniqueKey)=>{
                if (uniqueKey.customIndex === void 0) {
                    uniqueKey.customIndex = true;
                }
            });
        }
        if (model) {
            options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;
        }
        attributes = _.mapValues(attributes, (attribute)=>this.sequelize.normalizeAttribute(attribute));
        if (options.indexes) {
            options.indexes.forEach((fields)=>{
                const fieldArr = fields.fields;
                if (fieldArr.length === 1) {
                    fieldArr.forEach((field)=>{
                        for(const property in attributes){
                            if (field === attributes[property].field) {
                                attributes[property].unique = true;
                            }
                        }
                    });
                }
            });
        }
        if (options.alter) {
            if (options.indexes) {
                options.indexes.forEach((fields)=>{
                    const fieldArr = fields.fields;
                    if (fieldArr.length === 1) {
                        fieldArr.forEach((field)=>{
                            for(const property in attributes){
                                if (field === attributes[property].field && attributes[property].unique) {
                                    attributes[property].unique = false;
                                }
                            }
                        });
                    }
                });
            }
        }
        if (!tableName.schema && (options.schema || !!model && model._schema)) {
            tableName = this.queryGenerator.addSchema({
                tableName,
                _schema: !!model && model._schema || options.schema
            });
        }
        attributes = this.queryGenerator.attributesToSQL(attributes, {
            table: tableName,
            context: "createTable",
            withoutForeignKeyConstraints: options.withoutForeignKeyConstraints
        });
        sql = this.queryGenerator.createTableQuery(tableName, attributes, options);
        return await this.sequelize.query(sql, options);
    }
}
exports.Db2QueryInterface = Db2QueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/db2/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").db2;
const { Db2QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/query-interface.js [app-route] (ecmascript)");
class Db2Dialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new Db2QueryInterface(sequelize, this.queryGenerator);
    }
}
Db2Dialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "DEFAULT": true,
    "DEFAULT VALUES": false,
    "VALUES ()": false,
    "LIMIT ON UPDATE": false,
    "ORDER NULLS": false,
    lock: false,
    transactions: true,
    migrations: false,
    returnValues: false,
    schemas: true,
    finalTable: true,
    autoIncrement: {
        identityInsert: false,
        defaultValue: false,
        update: true
    },
    constraints: {
        restrict: true,
        default: false
    },
    index: {
        collate: false,
        length: false,
        parser: false,
        type: false,
        using: false,
        where: true
    },
    NUMERIC: true,
    tmpTableTrigger: true
});
Db2Dialect.prototype.defaultVersion = "1.0.0";
Db2Dialect.prototype.Query = Query;
Db2Dialect.prototype.name = "db2";
Db2Dialect.prototype.TICK_CHAR = '"';
Db2Dialect.prototype.TICK_CHAR_LEFT = '"';
Db2Dialect.prototype.TICK_CHAR_RIGHT = '"';
Db2Dialect.prototype.DataTypes = DataTypes;
module.exports = Db2Dialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/connection-manager.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
const AbstractConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/connection-manager.js [app-route] (ecmascript)");
const SequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").snowflake;
const debug = logger.debugContext("connection:snowflake");
const parserStore = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/parserStore.js [app-route] (ecmascript)")("snowflake");
class ConnectionManager extends AbstractConnectionManager {
    constructor(dialect, sequelize){
        sequelize.config.port = sequelize.config.port || 3306;
        super(dialect, sequelize);
        this.lib = this._loadDialectModule("snowflake-sdk");
        this.refreshTypeParser(DataTypes);
    }
    _refreshTypeParser(dataType) {
        parserStore.refresh(dataType);
    }
    _clearTypeParser() {
        parserStore.clear();
    }
    static _typecast(field, next) {
        if (parserStore.get(field.type)) {
            return parserStore.get(field.type)(field, this.sequelize.options, next);
        }
        return next();
    }
    async connect(config) {
        const connectionConfig = __spreadValues({
            account: config.host,
            username: config.username,
            password: config.password,
            database: config.database,
            warehouse: config.warehouse,
            role: config.role
        }, config.dialectOptions);
        try {
            const connection = await new Promise((resolve, reject)=>{
                this.lib.createConnection(connectionConfig).connect((err, conn)=>{
                    if (err) {
                        console.log(err);
                        reject(err);
                    } else {
                        resolve(conn);
                    }
                });
            });
            debug("connection acquired");
            if (!this.sequelize.config.keepDefaultTimezone) {
                const tzOffset = this.sequelize.options.timezone === "+00:00" ? "Etc/UTC" : this.sequelize.options.timezone;
                const isNamedTzOffset = /\//.test(tzOffset);
                if (isNamedTzOffset) {
                    await new Promise((resolve, reject)=>{
                        connection.execute({
                            sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,
                            complete (err) {
                                if (err) {
                                    console.log(err);
                                    reject(err);
                                } else {
                                    resolve();
                                }
                            }
                        });
                    });
                } else {
                    throw Error("only support time zone name for snowflake!");
                }
            }
            return connection;
        } catch (err) {
            switch(err.code){
                case "ECONNREFUSED":
                    throw new SequelizeErrors.ConnectionRefusedError(err);
                case "ER_ACCESS_DENIED_ERROR":
                    throw new SequelizeErrors.AccessDeniedError(err);
                case "ENOTFOUND":
                    throw new SequelizeErrors.HostNotFoundError(err);
                case "EHOSTUNREACH":
                    throw new SequelizeErrors.HostNotReachableError(err);
                case "EINVAL":
                    throw new SequelizeErrors.InvalidConnectionError(err);
                default:
                    throw new SequelizeErrors.ConnectionError(err);
            }
        }
    }
    async disconnect(connection) {
        if (!connection.isUp()) {
            debug("connection tried to disconnect but was already at CLOSED state");
            return;
        }
        return new Promise((resolve, reject)=>{
            connection.destroy((err)=>{
                if (err) {
                    console.error(`Unable to disconnect: ${err.message}`);
                    reject(err);
                } else {
                    console.log(`Disconnected connection with id: ${connection.getId()}`);
                    resolve(connection.getId());
                }
            });
        });
    }
    validate(connection) {
        return connection.isUp();
    }
}
module.exports = ConnectionManager;
module.exports.ConnectionManager = ConnectionManager;
module.exports.default = ConnectionManager; //# sourceMappingURL=connection-manager.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const AbstractQuery = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const { logger } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/logger.js [app-route] (ecmascript)");
const ER_DUP_ENTRY = 1062;
const ER_DEADLOCK = 1213;
const ER_ROW_IS_REFERENCED = 1451;
const ER_NO_REFERENCED_ROW = 1452;
const debug = logger.debugContext("sql:snowflake");
class Query extends AbstractQuery {
    static formatBindParameters(sql, values, dialect) {
        const bindParam = [];
        const replacementFunc = (_match, key, values_)=>{
            if (values_[key] !== void 0) {
                bindParam.push(values_[key]);
                return "?";
            }
            return void 0;
        };
        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];
        return [
            sql,
            bindParam.length > 0 ? bindParam : void 0
        ];
    }
    async run(sql, parameters) {
        this.sql = sql;
        const { connection, options } = this;
        const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;
        const complete = this._logQuery(sql, debug, parameters);
        if (parameters) {
            debug("parameters(%j)", parameters);
        }
        let results;
        try {
            results = await new Promise((resolve, reject)=>{
                connection.execute({
                    sqlText: sql,
                    binds: parameters,
                    complete (err, _stmt, rows) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(rows);
                        }
                    }
                });
            });
        } catch (error) {
            if (options.transaction && error.errno === ER_DEADLOCK) {
                try {
                    await options.transaction.rollback();
                } catch (error_) {}
                options.transaction.finished = "rollback";
            }
            error.sql = sql;
            error.parameters = parameters;
            throw this.formatError(error);
        } finally{
            complete();
        }
        if (showWarnings && results && results.warningStatus > 0) {
            await this.logWarnings(results);
        }
        return this.formatResults(results);
    }
    formatResults(data) {
        let result = this.instance;
        if (this.isInsertQuery(data)) {
            this.handleInsertQuery(data);
            if (!this.instance) {
                if (data.constructor.name === "ResultSetHeader" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {
                    const startId = data[this.getInsertIdField()];
                    result = [];
                    for(let i = startId; i < startId + data.affectedRows; i++){
                        result.push({
                            [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i
                        });
                    }
                } else {
                    result = data[this.getInsertIdField()];
                }
            }
        }
        if (this.isSelectQuery()) {
            if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
                const sfAttrMap = _.reduce(this.model.rawAttributes, (m, v, k)=>{
                    m[k.toUpperCase()] = k;
                    return m;
                }, {});
                data = data.map((data2)=>_.reduce(data2, (prev, value, key)=>{
                        if (value !== void 0 && sfAttrMap[key]) {
                            prev[sfAttrMap[key]] = value;
                            delete prev[key];
                        }
                        return prev;
                    }, data2));
            }
            this.options.fieldMap = _.mapKeys(this.options.fieldMap, (v, k)=>{
                return k.toUpperCase();
            });
            return this.handleSelectQuery(data);
        }
        if (this.isShowTablesQuery()) {
            return this.handleShowTablesQuery(data);
        }
        if (this.isDescribeQuery()) {
            result = {};
            for (const _result of data){
                result[_result.Field] = {
                    type: _result.Type.toUpperCase(),
                    allowNull: _result.Null === "YES",
                    defaultValue: _result.Default,
                    primaryKey: _result.Key === "PRI",
                    autoIncrement: Object.prototype.hasOwnProperty.call(_result, "Extra") && _result.Extra.toLowerCase() === "auto_increment",
                    comment: _result.Comment ? _result.Comment : null
                };
            }
            return result;
        }
        if (this.isShowIndexesQuery()) {
            return this.handleShowIndexesQuery(data);
        }
        if (this.isCallQuery()) {
            return data[0];
        }
        if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {
            return data[0]["number of rows updated"];
        }
        if (this.isVersionQuery()) {
            return data[0].version;
        }
        if (this.isForeignKeysQuery()) {
            return data;
        }
        if (this.isUpsertQuery()) {
            return [
                result,
                data.affectedRows === 1
            ];
        }
        if (this.isInsertQuery() || this.isUpdateQuery()) {
            return [
                result,
                data.affectedRows
            ];
        }
        if (this.isShowConstraintsQuery()) {
            return data;
        }
        if (this.isRawQuery()) {
            return [
                data,
                data
            ];
        }
        return result;
    }
    async logWarnings(results) {
        const warningResults = await this.run("SHOW WARNINGS");
        const warningMessage = `Snowflake Warnings (${this.connection.uuid || "default"}): `;
        const messages = [];
        for (const _warningRow of warningResults){
            if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== "function") {
                continue;
            }
            for (const _warningResult of _warningRow){
                if (Object.prototype.hasOwnProperty.call(_warningResult, "Message")) {
                    messages.push(_warningResult.Message);
                } else {
                    for (const _objectKey of _warningResult.keys()){
                        messages.push([
                            _objectKey,
                            _warningResult[_objectKey]
                        ].join(": "));
                    }
                }
            }
        }
        this.sequelize.log(warningMessage + messages.join("; "), this.options);
        return results;
    }
    formatError(err) {
        const errCode = err.errno || err.code;
        switch(errCode){
            case ER_DUP_ENTRY:
                {
                    const match = err.message.match(/Duplicate entry '([\s\S]*)' for key '?((.|\s)*?)'?$/);
                    let fields = {};
                    let message = "Validation error";
                    const values = match ? match[1].split("-") : void 0;
                    const fieldKey = match ? match[2] : void 0;
                    const fieldVal = match ? match[1] : void 0;
                    const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];
                    if (uniqueKey) {
                        if (uniqueKey.msg) message = uniqueKey.msg;
                        fields = _.zipObject(uniqueKey.fields, values);
                    } else {
                        fields[fieldKey] = fieldVal;
                    }
                    const errors = [];
                    _.forOwn(fields, (value, field)=>{
                        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), "unique violation", field, value, this.instance, "not_unique"));
                    });
                    return new sequelizeErrors.UniqueConstraintError({
                        message,
                        errors,
                        parent: err,
                        fields
                    });
                }
            case ER_ROW_IS_REFERENCED:
            case ER_NO_REFERENCED_ROW:
                {
                    const match = err.message.match(/CONSTRAINT ([`"])(.*)\1 FOREIGN KEY \(\1(.*)\1\) REFERENCES \1(.*)\1 \(\1(.*)\1\)/);
                    const quoteChar = match ? match[1] : "`";
                    const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;
                    return new sequelizeErrors.ForeignKeyConstraintError({
                        reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? "parent" : "child",
                        table: match ? match[4] : void 0,
                        fields,
                        value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,
                        index: match ? match[2] : void 0,
                        parent: err
                    });
                }
            default:
                return new sequelizeErrors.DatabaseError(err);
        }
    }
    handleShowIndexesQuery(data) {
        data = data.reduce((acc, item)=>{
            if (!(item.Key_name in acc)) {
                acc[item.Key_name] = item;
                item.fields = [];
            }
            acc[item.Key_name].fields[item.Seq_in_index - 1] = {
                attribute: item.Column_name,
                length: item.Sub_part || void 0,
                order: item.Collation === "A" ? "ASC" : void 0
            };
            delete item.column_name;
            return acc;
        }, {});
        return _.map(data, (item)=>({
                primary: item.Key_name === "PRIMARY",
                fields: item.fields,
                name: item.Key_name,
                tableName: item.Table,
                unique: item.Non_unique !== 1,
                type: item.Index_type
            }));
    }
}
module.exports = Query;
module.exports.Query = Query;
module.exports.default = Query; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/query-generator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const AbstractQueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-generator.js [app-route] (ecmascript)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const JSON_FUNCTION_REGEX = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
const JSON_OPERATOR_REGEX = /^\s*(->>?|@>|<@|\?[|&]?|\|{2}|#-)/i;
const TOKEN_CAPTURE_REGEX = /^\s*((?:([`"'])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;
const FOREIGN_KEY_FIELDS = [
    "CONSTRAINT_NAME as constraint_name",
    "CONSTRAINT_NAME as constraintName",
    "CONSTRAINT_SCHEMA as constraintSchema",
    "CONSTRAINT_SCHEMA as constraintCatalog",
    "TABLE_NAME as tableName",
    "TABLE_SCHEMA as tableSchema",
    "TABLE_SCHEMA as tableCatalog",
    "COLUMN_NAME as columnName",
    "REFERENCED_TABLE_SCHEMA as referencedTableSchema",
    "REFERENCED_TABLE_SCHEMA as referencedTableCatalog",
    "REFERENCED_TABLE_NAME as referencedTableName",
    "REFERENCED_COLUMN_NAME as referencedColumnName"
].join(",");
const SNOWFLAKE_RESERVED_WORDS = "account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with".split(",");
const typeWithoutDefault = /* @__PURE__ */ new Set([
    "BLOB",
    "TEXT",
    "GEOMETRY",
    "JSON"
]);
class SnowflakeQueryGenerator extends AbstractQueryGenerator {
    constructor(options){
        super(options);
        this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {
            [Op.regexp]: "REGEXP",
            [Op.notRegexp]: "NOT REGEXP"
        });
    }
    createDatabaseQuery(databaseName, options) {
        options = __spreadValues({
            charset: null,
            collate: null
        }, options);
        return Utils.joinSQLFragments([
            "CREATE DATABASE IF NOT EXISTS",
            this.quoteIdentifier(databaseName),
            options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,
            options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,
            ";"
        ]);
    }
    dropDatabaseQuery(databaseName) {
        return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;
    }
    createSchema() {
        return "SHOW TABLES";
    }
    showSchemasQuery() {
        return "SHOW TABLES";
    }
    versionQuery() {
        return "SELECT CURRENT_VERSION()";
    }
    createTableQuery(tableName, attributes, options) {
        options = __spreadValues({
            charset: null,
            rowFormat: null
        }, options);
        const primaryKeys = [];
        const foreignKeys = {};
        const attrStr = [];
        for(const attr in attributes){
            if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;
            const dataType = attributes[attr];
            let match;
            if (dataType.includes("PRIMARY KEY")) {
                primaryKeys.push(attr);
                if (dataType.includes("REFERENCES")) {
                    match = dataType.match(/^(.+) (REFERENCES.*)$/);
                    attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace("PRIMARY KEY", "")}`);
                    foreignKeys[attr] = match[2];
                } else {
                    attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
                }
            } else if (dataType.includes("REFERENCES")) {
                match = dataType.match(/^(.+) (REFERENCES.*)$/);
                attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
                foreignKeys[attr] = match[2];
            } else {
                attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
            }
        }
        const table = this.quoteTable(tableName);
        let attributesClause = attrStr.join(", ");
        const pkString = primaryKeys.map((pk)=>this.quoteIdentifier(pk)).join(", ");
        if (options.uniqueKeys) {
            _.each(options.uniqueKeys, (columns, indexName)=>{
                if (columns.customIndex) {
                    if (typeof indexName !== "string") {
                        indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
                    }
                    attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field)=>this.quoteIdentifier(field)).join(", ")})`;
                }
            });
        }
        if (pkString.length > 0) {
            attributesClause += `, PRIMARY KEY (${pkString})`;
        }
        for(const fkey in foreignKeys){
            if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
                attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
            }
        }
        return Utils.joinSQLFragments([
            "CREATE TABLE IF NOT EXISTS",
            table,
            `(${attributesClause})`,
            options.comment && typeof options.comment === "string" && `COMMENT ${this.escape(options.comment)}`,
            options.charset && `DEFAULT CHARSET=${options.charset}`,
            options.collate && `COLLATE ${options.collate}`,
            options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,
            ";"
        ]);
    }
    describeTableQuery(tableName, schema, schemaDelimiter) {
        const table = this.quoteTable(this.addSchema({
            tableName,
            _schema: schema,
            _schemaDelimiter: schemaDelimiter
        }));
        return `SHOW FULL COLUMNS FROM ${table};`;
    }
    showTablesQuery(database) {
        return Utils.joinSQLFragments([
            "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'",
            database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : "AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')",
            ";"
        ]);
    }
    tableExistsQuery(table) {
        const tableName = table.tableName || table;
        const schema = table.schema;
        return Utils.joinSQLFragments([
            "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'",
            `AND TABLE_SCHEMA = ${schema !== void 0 ? this.escape(schema) : "CURRENT_SCHEMA()"}`,
            `AND TABLE_NAME = ${this.escape(tableName)}`,
            ";"
        ]);
    }
    addColumnQuery(table, key, dataType) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(table),
            "ADD",
            this.quoteIdentifier(key),
            this.attributeToSQL(dataType, {
                context: "addColumn",
                tableName: table,
                foreignKey: key
            }),
            ";"
        ]);
    }
    removeColumnQuery(tableName, attributeName) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP",
            this.quoteIdentifier(attributeName),
            ";"
        ]);
    }
    changeColumnQuery(tableName, attributes) {
        const query = (...subQuerys)=>Utils.joinSQLFragments([
                "ALTER TABLE",
                this.quoteTable(tableName),
                "ALTER COLUMN",
                ...subQuerys,
                ";"
            ]);
        const sql = [];
        for(const attributeName in attributes){
            let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
            const attrSql = [];
            if (definition.includes("NOT NULL")) {
                attrSql.push(query(this.quoteIdentifier(attributeName), "SET NOT NULL"));
                definition = definition.replace("NOT NULL", "").trim();
            } else if (!definition.includes("REFERENCES")) {
                attrSql.push(query(this.quoteIdentifier(attributeName), "DROP NOT NULL"));
            }
            if (definition.includes("DEFAULT")) {
                attrSql.push(query(this.quoteIdentifier(attributeName), "SET DEFAULT", definition.match(/DEFAULT ([^;]+)/)[1]));
                definition = definition.replace(/(DEFAULT[^;]+)/, "").trim();
            } else if (!definition.includes("REFERENCES")) {
                attrSql.push(query(this.quoteIdentifier(attributeName), "DROP DEFAULT"));
            }
            if (definition.match(/UNIQUE;*$/)) {
                definition = definition.replace(/UNIQUE;*$/, "");
                attrSql.push(query("ADD UNIQUE (", this.quoteIdentifier(attributeName), ")").replace("ALTER COLUMN", ""));
            }
            if (definition.includes("REFERENCES")) {
                definition = definition.replace(/.+?(?=REFERENCES)/, "");
                attrSql.push(query("ADD FOREIGN KEY (", this.quoteIdentifier(attributeName), ")", definition).replace("ALTER COLUMN", ""));
            } else {
                attrSql.push(query(this.quoteIdentifier(attributeName), "TYPE", definition));
            }
            sql.push(attrSql.join(""));
        }
        return sql.join("");
    }
    renameColumnQuery(tableName, attrBefore, attributes) {
        const attrString = [];
        for(const attrName in attributes){
            const definition = attributes[attrName];
            attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);
        }
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "RENAME COLUMN",
            attrString.join(" to "),
            ";"
        ]);
    }
    handleSequelizeMethod(attr, tableName, factory, options, prepend) {
        if (attr instanceof Utils.Json) {
            if (attr.conditions) {
                const conditions = this.parseConditionObject(attr.conditions).map((condition)=>`${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);
                return conditions.join(" AND ");
            }
            if (attr.path) {
                let str;
                if (this._checkValidJsonStatement(attr.path)) {
                    str = attr.path;
                } else {
                    const paths = _.toPath(attr.path);
                    const column = paths.shift();
                    str = this.jsonPathExtractionQuery(column, paths);
                }
                if (attr.value) {
                    str += util.format(" = %s", this.escape(attr.value));
                }
                return str;
            }
        } else if (attr instanceof Utils.Cast) {
            if (/timestamp/i.test(attr.type)) {
                attr.type = "datetime";
            } else if (attr.json && /boolean/i.test(attr.type)) {
                attr.type = "char";
            } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {
                attr.type = "decimal";
            } else if (/text/i.test(attr.type)) {
                attr.type = "char";
            }
        }
        return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);
    }
    truncateTableQuery(tableName) {
        return Utils.joinSQLFragments([
            "TRUNCATE",
            this.quoteTable(tableName)
        ]);
    }
    deleteQuery(tableName, where, options = {}, model) {
        const table = this.quoteTable(tableName);
        let whereClause = this.getWhereConditions(where, null, model, options);
        const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;
        let primaryKeys = "";
        let primaryKeysSelection = "";
        if (whereClause) {
            whereClause = `WHERE ${whereClause}`;
        }
        if (limit) {
            if (!model) {
                throw new Error("Cannot LIMIT delete without a model.");
            }
            const pks = Object.values(model.primaryKeys).map((pk)=>this.quoteIdentifier(pk.field)).join(",");
            primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;
            primaryKeysSelection = pks;
            return Utils.joinSQLFragments([
                "DELETE FROM",
                table,
                "WHERE",
                primaryKeys,
                "IN (SELECT",
                primaryKeysSelection,
                "FROM",
                table,
                whereClause,
                limit,
                ")",
                ";"
            ]);
        }
        return Utils.joinSQLFragments([
            "DELETE FROM",
            table,
            whereClause,
            ";"
        ]);
    }
    showIndexesQuery() {
        return "SELECT '' FROM DUAL";
    }
    showConstraintsQuery(table, constraintName) {
        const tableName = table.tableName || table;
        const schemaName = table.schema;
        return Utils.joinSQLFragments([
            "SELECT CONSTRAINT_CATALOG AS constraintCatalog,",
            "CONSTRAINT_NAME AS constraintName,",
            "CONSTRAINT_SCHEMA AS constraintSchema,",
            "CONSTRAINT_TYPE AS constraintType,",
            "TABLE_NAME AS tableName,",
            "TABLE_SCHEMA AS tableSchema",
            "from INFORMATION_SCHEMA.TABLE_CONSTRAINTS",
            `WHERE table_name='${tableName}'`,
            constraintName && `AND constraint_name = '${constraintName}'`,
            schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,
            ";"
        ]);
    }
    removeIndexQuery(tableName, indexNameOrAttributes) {
        let indexName = indexNameOrAttributes;
        if (typeof indexName !== "string") {
            indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join("_")}`);
        }
        return Utils.joinSQLFragments([
            "DROP INDEX",
            this.quoteIdentifier(indexName),
            "ON",
            this.quoteTable(tableName),
            ";"
        ]);
    }
    attributeToSQL(attribute, options) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        const attributeString = attribute.type.toString({
            escape: this.escape.bind(this)
        });
        let template = attributeString;
        if (attribute.allowNull === false) {
            template += " NOT NULL";
        }
        if (attribute.autoIncrement) {
            template += " AUTOINCREMENT";
        }
        if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {
            template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
        }
        if (attribute.unique === true) {
            template += " UNIQUE";
        }
        if (attribute.primaryKey) {
            template += " PRIMARY KEY";
        }
        if (attribute.comment) {
            template += ` COMMENT ${this.escape(attribute.comment)}`;
        }
        if (attribute.first) {
            template += " FIRST";
        }
        if (attribute.after) {
            template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
        }
        if (attribute.references) {
            if (options && options.context === "addColumn" && options.foreignKey) {
                const attrName = this.quoteIdentifier(options.foreignKey);
                const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);
                template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
            }
            template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;
            if (attribute.references.key) {
                template += ` (${this.quoteIdentifier(attribute.references.key)})`;
            } else {
                template += ` (${this.quoteIdentifier("id")})`;
            }
            if (attribute.onDelete) {
                template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
            }
            if (attribute.onUpdate) {
                template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
            }
        }
        return template;
    }
    attributesToSQL(attributes, options) {
        const result = {};
        for(const key in attributes){
            const attribute = attributes[key];
            result[attribute.field || key] = this.attributeToSQL(attribute, options);
        }
        return result;
    }
    _checkValidJsonStatement(stmt) {
        if (typeof stmt !== "string") {
            return false;
        }
        let currentIndex = 0;
        let openingBrackets = 0;
        let closingBrackets = 0;
        let hasJsonFunction = false;
        let hasInvalidToken = false;
        while(currentIndex < stmt.length){
            const string = stmt.substr(currentIndex);
            const functionMatches = JSON_FUNCTION_REGEX.exec(string);
            if (functionMatches) {
                currentIndex += functionMatches[0].indexOf("(");
                hasJsonFunction = true;
                continue;
            }
            const operatorMatches = JSON_OPERATOR_REGEX.exec(string);
            if (operatorMatches) {
                currentIndex += operatorMatches[0].length;
                hasJsonFunction = true;
                continue;
            }
            const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);
            if (tokenMatches) {
                const capturedToken = tokenMatches[1];
                if (capturedToken === "(") {
                    openingBrackets++;
                } else if (capturedToken === ")") {
                    closingBrackets++;
                } else if (capturedToken === ";") {
                    hasInvalidToken = true;
                    break;
                }
                currentIndex += tokenMatches[0].length;
                continue;
            }
            break;
        }
        if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {
            throw new Error(`Invalid json statement: ${stmt}`);
        }
        return hasJsonFunction;
    }
    dataTypeMapping(tableName, attr, dataType) {
        if (dataType.includes("PRIMARY KEY")) {
            dataType = dataType.replace("PRIMARY KEY", "");
        }
        if (dataType.includes("SERIAL")) {
            if (dataType.includes("BIGINT")) {
                dataType = dataType.replace("SERIAL", "BIGSERIAL");
                dataType = dataType.replace("BIGINT", "");
            } else if (dataType.includes("SMALLINT")) {
                dataType = dataType.replace("SERIAL", "SMALLSERIAL");
                dataType = dataType.replace("SMALLINT", "");
            } else {
                dataType = dataType.replace("INTEGER", "");
            }
            dataType = dataType.replace("NOT NULL", "");
        }
        return dataType;
    }
    getForeignKeysQuery(table, schemaName) {
        const tableName = table.tableName || table;
        return Utils.joinSQLFragments([
            "SELECT",
            FOREIGN_KEY_FIELDS,
            `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,
            `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,
            "AND REFERENCED_TABLE_NAME IS NOT NULL",
            ";"
        ]);
    }
    getForeignKeyQuery(table, columnName) {
        const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : "";
        const quotedTableName = wrapSingleQuote(table.tableName || table);
        const quotedColumnName = wrapSingleQuote(columnName);
        return Utils.joinSQLFragments([
            "SELECT",
            FOREIGN_KEY_FIELDS,
            "FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE",
            "WHERE (",
            [
                `REFERENCED_TABLE_NAME = ${quotedTableName}`,
                table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,
                `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`
            ],
            ") OR (",
            [
                `TABLE_NAME = ${quotedTableName}`,
                table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,
                `AND COLUMN_NAME = ${quotedColumnName}`,
                "AND REFERENCED_TABLE_NAME IS NOT NULL"
            ],
            ")"
        ]);
    }
    dropForeignKeyQuery(tableName, foreignKey) {
        return Utils.joinSQLFragments([
            "ALTER TABLE",
            this.quoteTable(tableName),
            "DROP FOREIGN KEY",
            this.quoteIdentifier(foreignKey),
            ";"
        ]);
    }
    addLimitAndOffset(options) {
        let fragment = [];
        if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {
            fragment = fragment.concat([
                " LIMIT ",
                this.escape(options.limit),
                " OFFSET ",
                this.escape(options.offset)
            ]);
        } else if (options.limit !== null && options.limit !== void 0) {
            fragment = [
                " LIMIT ",
                this.escape(options.limit)
            ];
        }
        return fragment.join("");
    }
    quoteIdentifier(identifier, force) {
        const optForceQuote = force || false;
        const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;
        const rawIdentifier = Utils.removeTicks(identifier, '"');
        if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(".") || identifier.includes("->") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {
            return Utils.addTicks(rawIdentifier, '"');
        }
        return rawIdentifier;
    }
}
function wrapSingleQuote(identifier) {
    return Utils.addTicks(identifier, "'");
}
module.exports = SnowflakeQueryGenerator; //# sourceMappingURL=query-generator.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/query-interface.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
class SnowflakeQueryInterface extends QueryInterface {
    async removeColumn(tableName, columnName, options) {
        options = options || {};
        const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {
            tableName,
            schema: this.sequelize.config.database
        }, columnName), __spreadValues({
            raw: true
        }, options));
        if (results.length && results[0].constraint_name !== "PRIMARY") {
            await Promise.all(results.map((constraint)=>this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({
                    raw: true
                }, options))));
        }
        return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({
            raw: true
        }, options));
    }
    async upsert(tableName, insertValues, updateValues, where, options) {
        options = __spreadValues({}, options);
        options.type = QueryTypes.UPSERT;
        options.updateOnDuplicate = Object.keys(updateValues);
        const model = options.model;
        const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);
        return await this.sequelize.query(sql, options);
    }
    async removeConstraint(tableName, constraintName, options) {
        const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {
            tableName,
            schema: this.sequelize.config.database
        }, constraintName);
        const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {
            type: this.sequelize.QueryTypes.SHOWCONSTRAINTS
        }));
        const constraint = constraints[0];
        let query;
        if (!constraint || !constraint.constraintType) {
            throw new sequelizeErrors.UnknownConstraintError({
                message: `Constraint ${constraintName} on table ${tableName} does not exist`,
                constraint: constraintName,
                table: tableName
            });
        }
        if (constraint.constraintType === "FOREIGN KEY") {
            query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);
        } else {
            query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);
        }
        return await this.sequelize.query(query, options);
    }
}
exports.SnowflakeQueryInterface = SnowflakeQueryInterface; //# sourceMappingURL=query-interface.js.map
}),
"[project]/node_modules/sequelize/lib/dialects/snowflake/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const AbstractDialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/index.js [app-route] (ecmascript)");
const ConnectionManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/connection-manager.js [app-route] (ecmascript)");
const Query = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/query.js [app-route] (ecmascript)");
const QueryGenerator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/query-generator.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)").snowflake;
const { SnowflakeQueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/query-interface.js [app-route] (ecmascript)");
class SnowflakeDialect extends AbstractDialect {
    constructor(sequelize){
        super();
        this.sequelize = sequelize;
        this.connectionManager = new ConnectionManager(this, sequelize);
        this.queryGenerator = new QueryGenerator({
            _dialect: this,
            sequelize
        });
        this.queryInterface = new SnowflakeQueryInterface(sequelize, this.queryGenerator);
    }
}
SnowflakeDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {
    "VALUES ()": true,
    "LIMIT ON UPDATE": true,
    lock: true,
    forShare: "LOCK IN SHARE MODE",
    settingIsolationLevelDuringTransaction: false,
    inserts: {
        ignoreDuplicates: " IGNORE",
        updateOnDuplicate: false
    },
    index: {
        collate: false,
        length: true,
        parser: true,
        type: true,
        using: 1
    },
    constraints: {
        dropConstraint: false,
        check: false
    },
    indexViaAlter: true,
    indexHints: true,
    NUMERIC: true,
    GEOMETRY: false,
    JSON: false,
    REGEXP: true,
    schemas: true
});
SnowflakeDialect.prototype.defaultVersion = "5.7.0";
SnowflakeDialect.prototype.Query = Query;
SnowflakeDialect.prototype.QueryGenerator = QueryGenerator;
SnowflakeDialect.prototype.DataTypes = DataTypes;
SnowflakeDialect.prototype.name = "snowflake";
SnowflakeDialect.prototype.TICK_CHAR = '"';
SnowflakeDialect.prototype.TICK_CHAR_LEFT = SnowflakeDialect.prototype.TICK_CHAR;
SnowflakeDialect.prototype.TICK_CHAR_RIGHT = SnowflakeDialect.prototype.TICK_CHAR;
module.exports = SnowflakeDialect; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"sequelize","description":"Sequelize is a promise-based Node.js ORM tool for Postgres, MySQL, MariaDB, SQLite, Microsoft SQL Server, Amazon Redshift and Snowflakes Data Cloud. It features solid transaction support, relations, eager and lazy loading, read replication and more.","version":"6.37.7","funding":[{"type":"opencollective","url":"https://opencollective.com/sequelize"}],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"./lib/index.js","types":"./types/index.d.ts","type":"commonjs","exports":{".":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"./lib/*":{"types":"./types/*.d.ts","default":"./lib/*.js"},"./lib/errors":{"types":"./types/errors/index.d.ts","default":"./lib/errors/index.js"},"./package.json":"./package.json","./types/*":{"types":"./types/*.d.ts"}},"engines":{"node":">=10.0.0"},"files":["lib","types","index.js"],"license":"MIT","dependencies":{"@types/debug":"^4.1.8","@types/validator":"^13.7.17","debug":"^4.3.4","dottie":"^2.0.6","inflection":"^1.13.4","lodash":"^4.17.21","moment":"^2.29.4","moment-timezone":"^0.5.43","pg-connection-string":"^2.6.1","retry-as-promised":"^7.0.4","semver":"^7.5.4","sequelize-pool":"^7.1.0","toposort-class":"^1.0.1","uuid":"^8.3.2","validator":"^13.9.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^15.0.0","@commitlint/config-angular":"^15.0.0","@octokit/rest":"^18.12.0","@octokit/types":"^6.34.0","@types/chai":"^4.3.0","@types/lodash":"4.14.197","@types/mocha":"^9.0.0","@types/node":"^16.11.17","@types/sinon":"^10.0.6","@typescript-eslint/eslint-plugin":"^5.8.1","@typescript-eslint/parser":"^5.8.1","acorn":"^8.7.0","chai":"^4.3.7","chai-as-promised":"^7.1.1","chai-datetime":"^1.8.0","cheerio":"^1.0.0-rc.10","cls-hooked":"^4.2.2","copyfiles":"^2.4.1","cross-env":"^7.0.3","delay":"^5.0.0","esbuild":"0.14.3","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^8.5.0","eslint-plugin-jsdoc":"^37.4.0","eslint-plugin-mocha":"^9.0.0","expect-type":"^0.12.0","fast-glob":"^3.2.7","fs-jetpack":"^4.3.0","husky":"^7.0.4","ibm_db":"^2.8.1","js-combinatorics":"^0.6.1","lcov-result-merger":"^3.1.0","lint-staged":"^12.1.4","mariadb":"^2.5.5","markdownlint-cli":"^0.30.0","mocha":"^7.2.0","module-alias":"^2.2.2","mysql2":"^2.3.3","node-hook":"^1.0.0","nyc":"^15.1.0","oracledb":"^5.5.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.7.1","pg-hstore":"^2.3.4","rimraf":"^3.0.2","semantic-release":"^18.0.1","semantic-release-fail-on-major-bump":"^1.0.0","sinon":"^12.0.1","sinon-chai":"^3.7.0","snowflake-sdk":"^1.6.6","source-map-support":"^0.5.21","sqlite3":"^5.1.6","tedious":"8.3.0","typescript":"^4.5.4"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"ibm_db":{"optional":true},"snowflake-sdk":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true},"oracledb":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","pg","mssql","db2","ibm_db","sql","oracledb","sqlserver","snowflake","orm","nodejs","object relational mapper","database","db"],"commitlint":{"extends":["@commitlint/config-angular"],"rules":{"type-enum":[2,"always",["build","ci","docs","feat","fix","perf","refactor","revert","style","test","meta"]]}},"lint-staged":{"*!(d).[tj]s":"eslint"},"release":{"plugins":["@semantic-release/commit-analyzer","semantic-release-fail-on-major-bump","@semantic-release/release-notes-generator","@semantic-release/npm","@semantic-release/github"],"branches":["v6",{"name":"v6-beta","prerelease":"beta"}]},"publishConfig":{"tag":"latest"},"scripts":{"----------------------------------------- static analysis -----------------------------------------":"","lint":"eslint src test --quiet --fix","lint-docs":"markdownlint docs","test-typings":"tsc --noEmit --emitDeclarationOnly false && tsc -b test/tsconfig.json","----------------------------------------- documentation -------------------------------------------":"","docs":"sh docs.sh","----------------------------------------- tests ---------------------------------------------------":"","mocha":"mocha -r ./test/registerEsbuild","test-unit":"yarn mocha \"test/unit/**/*.test.[tj]s\"","test-integration":"yarn mocha \"test/integration/**/*.test.[tj]s\"","teaser":"node test/teaser.js","test":"npm run prepare && npm run test-typings && npm run teaser && npm run test-unit && npm run test-integration","----------------------------------------- coverage ------------------------------------------------":"","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \"test/integration/**/*.test.[tj]s\" && node -e \"require('fs').renameSync('coverage/lcov.info', 'coverage/integration.info')\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \"test/unit/**/*.test.[tj]s\" && node -e \"require('fs').renameSync('coverage/lcov.info', 'coverage/unit.info')\"","merge-coverage":"lcov-result-merger \"coverage/*.info\" \"coverage/lcov.info\"","----------------------------------------- local test dbs ------------------------------------------":"","start-mariadb":"bash dev/mariadb/10.3/start.sh","start-mysql":"bash dev/mysql/5.7/start.sh","start-mysql-8":"bash dev/mysql/8.0/start.sh","start-postgres":"bash dev/postgres/10/start.sh","start-mssql":"bash dev/mssql/2019/start.sh","start-db2":"bash dev/db2/11.5/start.sh","start-oracle-oldest":"bash dev/oracle/18-slim/start.sh","start-oracle-latest":"bash dev/oracle/23-slim/start.sh","stop-mariadb":"bash dev/mariadb/10.3/stop.sh","stop-mysql":"bash dev/mysql/5.7/stop.sh","stop-mysql-8":"bash dev/mysql/8.0/stop.sh","stop-postgres":"bash dev/postgres/10/stop.sh","stop-mssql":"bash dev/mssql/2019/stop.sh","stop-db2":"bash dev/db2/11.5/stop.sh","stop-oracle-oldest":"bash dev/oracle/18-slim/stop.sh","stop-oracle-latest":"bash dev/oracle/23-slim/stop.sh","restart-mariadb":"npm run start-mariadb","restart-mysql":"npm run start-mysql","restart-postgres":"npm run start-postgres","restart-mssql":"npm run start-mssql","restart-db2":"npm run start-db2","restart-oracle-oldest":"npm run start-oracle-oldest","restart-oracle-latest":"npm run start-oracle-latest","----------------------------------------- local tests ---------------------------------------------":"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-db2":"cross-env DIALECT=db2 npm run test-unit","test-unit-snowflake":"cross-env DIALECT=snowflake npm run test-unit","test-unit-oracle":"cross-env DIALECT=oracle npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite && npm run test-unit-snowflake && npm run test-unit-db2 && npm run test-unit-oracle","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-db2":"cross-env DIALECT=db2 npm run test-integration","test-integration-snowflake":"cross-env DIALECT=snowflake npm run test-integration","test-integration-oracle":"cross-env LD_LIBRARY_PATH=\"$PWD/.oracle/instantclient/\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm run test-integration","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-mssql":"cross-env DIALECT=mssql npm test","test-db2":"cross-env DIALECT=db2 npm test","test-oracle":"cross-env LD_LIBRARY_PATH=\"$PWD/.oracle/instantclient/\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm test","----------------------------------------- development ---------------------------------------------":"","sscce":"node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb node sscce.js","sscce-mysql":"cross-env DIALECT=mysql node sscce.js","sscce-postgres":"cross-env DIALECT=postgres node sscce.js","sscce-postgres-native":"cross-env DIALECT=postgres-native node sscce.js","sscce-sqlite":"cross-env DIALECT=sqlite node sscce.js","sscce-mssql":"cross-env DIALECT=mssql node sscce.js","sscce-db2":"cross-env DIALECT=db2 node sscce.js","sscce-oracle":"cross-env LD_LIBRARY_PATH=\"$PWD/.oracle/instantclient/\" DIALECT=oracle UV_THREADPOOL_SIZE=128 node sscce.js","prepare":"npm run build && husky install","build":"node ./build.js","---------------------------------------------------------------------------------------------------":""},"support":true});}),
"[project]/node_modules/sequelize/lib/sequelize.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const pgConnectionString = __turbopack_context__.r("[project]/node_modules/pg-connection-string/index.js [app-route] (ecmascript)");
const retry = __turbopack_context__.r("[project]/node_modules/retry-as-promised/dist/index.js [app-route] (ecmascript)").default;
const _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const Utils = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils.js [app-route] (ecmascript)");
const Model = __turbopack_context__.r("[project]/node_modules/sequelize/lib/model.js [app-route] (ecmascript)");
const DataTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/data-types.js [app-route] (ecmascript)");
const Deferrable = __turbopack_context__.r("[project]/node_modules/sequelize/lib/deferrable.js [app-route] (ecmascript)");
const ModelManager = __turbopack_context__.r("[project]/node_modules/sequelize/lib/model-manager.js [app-route] (ecmascript)");
const Transaction = __turbopack_context__.r("[project]/node_modules/sequelize/lib/transaction.js [app-route] (ecmascript)");
const QueryTypes = __turbopack_context__.r("[project]/node_modules/sequelize/lib/query-types.js [app-route] (ecmascript)");
const TableHints = __turbopack_context__.r("[project]/node_modules/sequelize/lib/table-hints.js [app-route] (ecmascript)");
const IndexHints = __turbopack_context__.r("[project]/node_modules/sequelize/lib/index-hints.js [app-route] (ecmascript)");
const sequelizeErrors = __turbopack_context__.r("[project]/node_modules/sequelize/lib/errors/index.js [app-route] (ecmascript)");
const Hooks = __turbopack_context__.r("[project]/node_modules/sequelize/lib/hooks.js [app-route] (ecmascript)");
const Association = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/index.js [app-route] (ecmascript)");
const Validator = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/validator-extras.js [app-route] (ecmascript)").validator;
const Op = __turbopack_context__.r("[project]/node_modules/sequelize/lib/operators.js [app-route] (ecmascript)");
const deprecations = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/deprecations.js [app-route] (ecmascript)");
const { QueryInterface } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/abstract/query-interface.js [app-route] (ecmascript)");
const { BelongsTo } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to.js [app-route] (ecmascript)");
const HasOne = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-one.js [app-route] (ecmascript)");
const { BelongsToMany } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/belongs-to-many.js [app-route] (ecmascript)");
const { HasMany } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/associations/has-many.js [app-route] (ecmascript)");
const { withSqliteForeignKeysOff } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js [app-route] (ecmascript)");
const { injectReplacements } = __turbopack_context__.r("[project]/node_modules/sequelize/lib/utils/sql.js [app-route] (ecmascript)");
class Sequelize {
    constructor(database, username, password, options){
        let config;
        if (arguments.length === 1 && typeof database === "object") {
            options = database;
            config = _.pick(options, "host", "port", "database", "username", "password");
        } else if (arguments.length === 1 && typeof database === "string" || arguments.length === 2 && typeof username === "object") {
            config = {};
            options = username || {};
            const urlParts = url.parse(arguments[0], true);
            options.dialect = urlParts.protocol.replace(/:$/, "");
            options.host = urlParts.hostname;
            if (options.dialect === "sqlite" && urlParts.pathname && !urlParts.pathname.startsWith("/:memory")) {
                const storagePath = path.join(options.host, urlParts.pathname);
                options.storage = path.resolve(options.storage || storagePath);
            }
            if (urlParts.pathname) {
                config.database = urlParts.pathname.replace(/^\//, "");
            }
            if (urlParts.port) {
                options.port = urlParts.port;
            }
            if (urlParts.auth) {
                const authParts = urlParts.auth.split(":");
                config.username = authParts[0];
                if (authParts.length > 1) config.password = authParts.slice(1).join(":");
            }
            if (urlParts.query) {
                if (urlParts.query.host) {
                    options.host = urlParts.query.host;
                }
                if (options.dialectOptions) {
                    Object.assign(options.dialectOptions, urlParts.query);
                } else {
                    options.dialectOptions = urlParts.query;
                    if (urlParts.query.options) {
                        try {
                            const o = JSON.parse(urlParts.query.options);
                            options.dialectOptions.options = o;
                        } catch (e) {}
                    }
                }
            }
            if ([
                "postgres",
                "postgresql"
            ].includes(options.dialect)) {
                Object.assign(options.dialectOptions, pgConnectionString.parse(arguments[0]));
            }
        } else {
            options = options || {};
            config = {
                database,
                username,
                password
            };
        }
        Sequelize.runHooks("beforeInit", config, options);
        this.options = __spreadValues({
            dialect: null,
            dialectModule: null,
            dialectModulePath: null,
            host: "localhost",
            protocol: "tcp",
            define: {},
            query: {},
            sync: {},
            timezone: "+00:00",
            standardConformingStrings: true,
            logging: console.log,
            omitNull: false,
            native: false,
            replication: false,
            ssl: void 0,
            pool: {},
            quoteIdentifiers: true,
            hooks: {},
            retry: {
                max: 5,
                match: [
                    "SQLITE_BUSY: database is locked"
                ]
            },
            transactionType: Transaction.TYPES.DEFERRED,
            isolationLevel: null,
            databaseVersion: 0,
            typeValidation: false,
            benchmark: false,
            minifyAliases: false,
            logQueryParameters: false,
            attributeBehavior: "throw"
        }, options);
        if (!this.options.dialect) {
            throw new Error("Dialect needs to be explicitly supplied as of v4.0.0");
        }
        if (this.options.dialect === "postgresql") {
            this.options.dialect = "postgres";
        }
        if (this.options.dialect === "sqlite" && this.options.timezone !== "+00:00") {
            throw new Error("Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.");
        }
        if (this.options.logging === true) {
            deprecations.noTrueLogging();
            this.options.logging = console.log;
        }
        this._setupHooks(options.hooks);
        this.config = {
            database: config.database || this.options.database,
            username: config.username || this.options.username,
            password: config.password || this.options.password || null,
            host: config.host || this.options.host,
            port: config.port || this.options.port,
            pool: this.options.pool,
            protocol: this.options.protocol,
            native: this.options.native,
            ssl: this.options.ssl,
            replication: this.options.replication,
            dialectModule: this.options.dialectModule,
            dialectModulePath: this.options.dialectModulePath,
            keepDefaultTimezone: this.options.keepDefaultTimezone,
            dialectOptions: this.options.dialectOptions
        };
        let Dialect;
        switch(this.getDialect()){
            case "mariadb":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mariadb/index.js [app-route] (ecmascript)");
                break;
            case "mssql":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mssql/index.js [app-route] (ecmascript)");
                break;
            case "mysql":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/mysql/index.js [app-route] (ecmascript)");
                break;
            case "oracle":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/oracle/index.js [app-route] (ecmascript)");
                break;
            case "postgres":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/postgres/index.js [app-route] (ecmascript)");
                break;
            case "sqlite":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/sqlite/index.js [app-route] (ecmascript)");
                break;
            case "db2":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/db2/index.js [app-route] (ecmascript)");
                break;
            case "snowflake":
                Dialect = __turbopack_context__.r("[project]/node_modules/sequelize/lib/dialects/snowflake/index.js [app-route] (ecmascript)");
                break;
            default:
                throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, oracle, postgres, db2 and sqlite.`);
        }
        this.dialect = new Dialect(this);
        this.dialect.queryGenerator.typeValidation = options.typeValidation;
        if (_.isPlainObject(this.options.operatorsAliases)) {
            deprecations.noStringOperators();
            this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);
        } else if (typeof this.options.operatorsAliases === "boolean") {
            deprecations.noBoolOperatorAliases();
        }
        this.queryInterface = this.dialect.queryInterface;
        this.models = {};
        this.modelManager = new ModelManager(this);
        this.connectionManager = this.dialect.connectionManager;
        Sequelize.runHooks("afterInit", this);
    }
    refreshTypes() {
        this.connectionManager.refreshTypeParser(DataTypes);
    }
    getDialect() {
        return this.options.dialect;
    }
    getDatabaseName() {
        return this.config.database;
    }
    getQueryInterface() {
        return this.queryInterface;
    }
    define(modelName, attributes, options = {}) {
        options.modelName = modelName;
        options.sequelize = this;
        const model = class extends Model {
        };
        model.init(attributes, options);
        return model;
    }
    model(modelName) {
        if (!this.isDefined(modelName)) {
            throw new Error(`${modelName} has not been defined`);
        }
        return this.modelManager.getModel(modelName);
    }
    isDefined(modelName) {
        return !!this.modelManager.models.find((model)=>model.name === modelName);
    }
    async query(sql, options) {
        options = __spreadValues(__spreadValues({}, this.options.query), options);
        if (options.instance && !options.model) {
            options.model = options.instance.constructor;
        }
        if (!options.instance && !options.model) {
            options.raw = true;
        }
        if (options.mapToModel) {
            options.fieldMap = _.get(options, "model.fieldAttributeMap", {});
        }
        options = _.defaults(options, {
            logging: Object.prototype.hasOwnProperty.call(this.options, "logging") ? this.options.logging : console.log,
            searchPath: Object.prototype.hasOwnProperty.call(this.options, "searchPath") ? this.options.searchPath : "DEFAULT"
        });
        if (!options.type) {
            if (options.model || options.nest || options.plain) {
                options.type = QueryTypes.SELECT;
            } else {
                options.type = QueryTypes.RAW;
            }
        }
        if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {
            delete options.searchPath;
        } else if (!options.searchPath) {
            options.searchPath = "DEFAULT";
        }
        if (typeof sql === "object") {
            if (sql.values !== void 0) {
                if (options.replacements !== void 0) {
                    throw new Error("Both `sql.values` and `options.replacements` cannot be set at the same time");
                }
                options.replacements = sql.values;
            }
            if (sql.bind !== void 0) {
                if (options.bind !== void 0) {
                    throw new Error("Both `sql.bind` and `options.bind` cannot be set at the same time");
                }
                options.bind = sql.bind;
            }
            if (sql.query !== void 0) {
                sql = sql.query;
            }
        }
        sql = sql.trim();
        if (options.replacements && options.bind) {
            throw new Error("Both `replacements` and `bind` cannot be set at the same time");
        }
        if (options.replacements) {
            sql = injectReplacements(sql, this.dialect, options.replacements);
        }
        let bindParameters;
        if (options.bind) {
            [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);
        }
        const checkTransaction = ()=>{
            if (options.transaction && options.transaction.finished && !options.completesTransaction) {
                const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);
                error.sql = sql;
                throw error;
            }
        };
        const retryOptions = __spreadValues(__spreadValues({}, this.options.retry), options.retry);
        return retry(async ()=>{
            if (options.transaction === void 0 && Sequelize._cls) {
                options.transaction = Sequelize._cls.get("transaction");
            }
            checkTransaction();
            const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));
            if (this.options.dialect === "db2" && options.alter) {
                if (options.alter.drop === false) {
                    connection.dropTable = false;
                }
            }
            const query = new this.dialect.Query(connection, this, options);
            try {
                await this.runHooks("beforeQuery", options, query);
                checkTransaction();
                return await query.run(sql, bindParameters);
            } finally{
                await this.runHooks("afterQuery", options, query);
                if (!options.transaction) {
                    this.connectionManager.releaseConnection(connection);
                }
            }
        }, retryOptions);
    }
    async set(variables, options) {
        options = __spreadValues(__spreadValues({}, this.options.set), typeof options === "object" && options);
        if (![
            "mysql",
            "mariadb"
        ].includes(this.options.dialect)) {
            throw new Error("sequelize.set is only supported for mysql or mariadb");
        }
        if (!options.transaction || !(options.transaction instanceof Transaction)) {
            throw new TypeError("options.transaction is required");
        }
        options.raw = true;
        options.plain = true;
        options.type = "SET";
        const query = `SET ${_.map(variables, (v, k)=>`@${k} := ${typeof v === "string" ? `"${v}"` : v}`).join(", ")}`;
        return await this.query(query, options);
    }
    escape(value) {
        return this.dialect.queryGenerator.escape(value);
    }
    async createSchema(schema, options) {
        return await this.getQueryInterface().createSchema(schema, options);
    }
    async showAllSchemas(options) {
        return await this.getQueryInterface().showAllSchemas(options);
    }
    async dropSchema(schema, options) {
        return await this.getQueryInterface().dropSchema(schema, options);
    }
    async dropAllSchemas(options) {
        return await this.getQueryInterface().dropAllSchemas(options);
    }
    async sync(options) {
        options = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.options), this.options.sync), options), {
            hooks: options ? options.hooks !== false : true
        });
        if (options.match) {
            if (!options.match.test(this.config.database)) {
                throw new Error(`Database "${this.config.database}" does not match sync match parameter "${options.match}"`);
            }
        }
        if (options.hooks) {
            await this.runHooks("beforeBulkSync", options);
        }
        if (options.force) {
            await this.drop(options);
        }
        if (this.modelManager.models.length === 0) {
            await this.authenticate(options);
        } else {
            const models = this.modelManager.getModelsTopoSortedByForeignKey();
            if (models == null) {
                return this._syncModelsWithCyclicReferences(options);
            }
            models.reverse();
            for (const model of models){
                await model.sync(options);
            }
        }
        if (options.hooks) {
            await this.runHooks("afterBulkSync", options);
        }
        return this;
    }
    async _syncModelsWithCyclicReferences(options) {
        if (this.dialect.name === "sqlite") {
            await withSqliteForeignKeysOff(this, options, async ()=>{
                for (const model of this.modelManager.models){
                    await model.sync(options);
                }
            });
            return;
        }
        for (const model of this.modelManager.models){
            await model.sync(__spreadProps(__spreadValues({}, options), {
                withoutForeignKeyConstraints: true
            }));
        }
        for (const model of this.modelManager.models){
            await model.sync(__spreadProps(__spreadValues({}, options), {
                force: false,
                alter: true
            }));
        }
    }
    async truncate(options) {
        const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();
        const models = sortedModels || this.modelManager.models;
        const hasCyclicDependencies = sortedModels == null;
        if (hasCyclicDependencies && (!options || !options.cascade)) {
            throw new Error('Sequelize#truncate: Some of your models have cyclic references (foreign keys). You need to use the "cascade" option to be able to delete rows from models that have cyclic references.');
        }
        if (hasCyclicDependencies && this.dialect.name === "sqlite") {
            return withSqliteForeignKeysOff(this, options, async ()=>{
                await Promise.all(models.map((model)=>model.truncate(options)));
            });
        }
        if (options && options.cascade) {
            for (const model of models)await model.truncate(options);
        } else {
            await Promise.all(models.map((model)=>model.truncate(options)));
        }
    }
    async drop(options) {
        if (options && options.cascade) {
            for (const model of this.modelManager.models){
                await model.drop(options);
            }
        }
        const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();
        if (sortedModels) {
            for (const model of sortedModels){
                await model.drop(options);
            }
        }
        if (this.dialect.name === "sqlite") {
            await withSqliteForeignKeysOff(this, options, async ()=>{
                for (const model of this.modelManager.models){
                    await model.drop(options);
                }
            });
            return;
        }
        for (const model of this.modelManager.models){
            const tableName = model.getTableName();
            const foreignKeys = await this.queryInterface.getForeignKeyReferencesForTable(tableName, options);
            await Promise.all(foreignKeys.map((foreignKey)=>{
                return this.queryInterface.removeConstraint(tableName, foreignKey.constraintName, options);
            }));
        }
        for (const model of this.modelManager.models){
            await model.drop(options);
        }
    }
    async authenticate(options) {
        options = __spreadValues({
            raw: true,
            plain: true,
            type: QueryTypes.SELECT
        }, options);
        await this.query(this.dialect.queryGenerator.authTestQuery(), options);
        return;
    }
    async databaseVersion(options) {
        return await this.getQueryInterface().databaseVersion(options);
    }
    random() {
        if ([
            "postgres",
            "sqlite",
            "snowflake"
        ].includes(this.getDialect())) {
            return this.fn("RANDOM");
        }
        return this.fn("RAND");
    }
    static fn(fn, ...args) {
        return new Utils.Fn(fn, args);
    }
    static col(col) {
        return new Utils.Col(col);
    }
    static cast(val, type) {
        return new Utils.Cast(val, type);
    }
    static literal(val) {
        return new Utils.Literal(val);
    }
    static and(...args) {
        return {
            [Op.and]: args
        };
    }
    static or(...args) {
        return {
            [Op.or]: args
        };
    }
    static json(conditionsOrPath, value) {
        return new Utils.Json(conditionsOrPath, value);
    }
    static where(attr, comparator, logic) {
        return new Utils.Where(attr, comparator, logic);
    }
    async transaction(options, autoCallback) {
        if (typeof options === "function") {
            autoCallback = options;
            options = void 0;
        }
        const transaction = new Transaction(this, options);
        if (!autoCallback) {
            await transaction.prepareEnvironment(false);
            return transaction;
        }
        return Sequelize._clsRun(async ()=>{
            await transaction.prepareEnvironment(true);
            let result;
            try {
                result = await autoCallback(transaction);
            } catch (err) {
                try {
                    await transaction.rollback();
                } catch (ignore) {}
                throw err;
            }
            await transaction.commit();
            return result;
        });
    }
    static useCLS(ns) {
        if (!ns || typeof ns !== "object" || typeof ns.bind !== "function" || typeof ns.run !== "function") throw new Error("Must provide CLS namespace");
        Sequelize._cls = ns;
        return this;
    }
    static _clsRun(fn) {
        const ns = Sequelize._cls;
        if (!ns) return fn();
        let res;
        ns.run((context)=>res = fn(context));
        return res;
    }
    log(...args) {
        let options;
        const last = _.last(args);
        if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, "logging")) {
            options = last;
            if (options.logging === console.log) {
                args.splice(args.length - 1, 1);
            }
        } else {
            options = this.options;
        }
        if (options.logging) {
            if (options.logging === true) {
                deprecations.noTrueLogging();
                options.logging = console.log;
            }
            if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {
                args = [
                    `${args[0]} Elapsed time: ${args[1]}ms`
                ];
            }
            options.logging(...args);
        }
    }
    close() {
        return this.connectionManager.close();
    }
    normalizeDataType(Type) {
        let type = typeof Type === "function" ? new Type() : Type;
        const dialectTypes = this.dialect.DataTypes || {};
        if (dialectTypes[type.key]) {
            type = dialectTypes[type.key].extend(type);
        }
        if (type instanceof DataTypes.ARRAY) {
            if (!type.type) {
                throw new Error("ARRAY is missing type definition for its values.");
            }
            if (dialectTypes[type.type.key]) {
                type.type = dialectTypes[type.type.key].extend(type.type);
            }
        }
        return type;
    }
    normalizeAttribute(attribute) {
        if (!_.isPlainObject(attribute)) {
            attribute = {
                type: attribute
            };
        }
        if (!attribute.type) return attribute;
        attribute.type = this.normalizeDataType(attribute.type);
        if (Object.prototype.hasOwnProperty.call(attribute, "defaultValue")) {
            if (typeof attribute.defaultValue === "function" && [
                DataTypes.NOW,
                DataTypes.UUIDV1,
                DataTypes.UUIDV4
            ].includes(attribute.defaultValue)) {
                attribute.defaultValue = new attribute.defaultValue();
            }
        }
        if (attribute.type instanceof DataTypes.ENUM) {
            if (attribute.values) {
                attribute.type.values = attribute.type.options.values = attribute.values;
            } else {
                attribute.values = attribute.type.values;
            }
            if (!attribute.values.length) {
                throw new Error("Values for ENUM have not been defined.");
            }
        }
        return attribute;
    }
}
Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;
Object.defineProperty(Sequelize, "version", {
    enumerable: true,
    get () {
        return __turbopack_context__.r("[project]/node_modules/sequelize/package.json (json)").version;
    }
});
Sequelize.options = {
    hooks: {}
};
Sequelize.Utils = Utils;
Sequelize.Op = Op;
Sequelize.TableHints = TableHints;
Sequelize.IndexHints = IndexHints;
Sequelize.Transaction = Transaction;
Sequelize.prototype.Sequelize = Sequelize;
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;
Sequelize.prototype.Validator = Sequelize.Validator = Validator;
Sequelize.Model = Model;
Sequelize.QueryInterface = QueryInterface;
Sequelize.BelongsTo = BelongsTo;
Sequelize.HasOne = HasOne;
Sequelize.HasMany = HasMany;
Sequelize.BelongsToMany = BelongsToMany;
Sequelize.DataTypes = DataTypes;
for(const dataType in DataTypes){
    Sequelize[dataType] = DataTypes[dataType];
}
Sequelize.Deferrable = Deferrable;
Sequelize.prototype.Association = Sequelize.Association = Association;
Sequelize.useInflection = Utils.useInflection;
Hooks.applyTo(Sequelize);
Hooks.applyTo(Sequelize.prototype);
Sequelize.Error = sequelizeErrors.BaseError;
for (const error of Object.keys(sequelizeErrors)){
    Sequelize[error] = sequelizeErrors[error];
}
module.exports = Sequelize;
module.exports.Sequelize = Sequelize;
module.exports.default = Sequelize; //# sourceMappingURL=sequelize.js.map
}),
"[project]/node_modules/sequelize/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/sequelize/lib/sequelize.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/sequelize/lib/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ABSTRACT",
    ()=>ABSTRACT,
    "ARRAY",
    ()=>ARRAY,
    "AccessDeniedError",
    ()=>AccessDeniedError,
    "AggregateError",
    ()=>AggregateError,
    "Association",
    ()=>Association,
    "AssociationError",
    ()=>AssociationError,
    "AsyncQueueError",
    ()=>AsyncQueueError,
    "BIGINT",
    ()=>BIGINT,
    "BLOB",
    ()=>BLOB,
    "BOOLEAN",
    ()=>BOOLEAN,
    "BaseError",
    ()=>BaseError,
    "BelongsTo",
    ()=>BelongsTo,
    "BelongsToMany",
    ()=>BelongsToMany,
    "BulkRecordError",
    ()=>BulkRecordError,
    "CHAR",
    ()=>CHAR,
    "CIDR",
    ()=>CIDR,
    "CITEXT",
    ()=>CITEXT,
    "ConnectionAcquireTimeoutError",
    ()=>ConnectionAcquireTimeoutError,
    "ConnectionError",
    ()=>ConnectionError,
    "ConnectionRefusedError",
    ()=>ConnectionRefusedError,
    "ConnectionTimedOutError",
    ()=>ConnectionTimedOutError,
    "DATE",
    ()=>DATE,
    "DATEONLY",
    ()=>DATEONLY,
    "DECIMAL",
    ()=>DECIMAL,
    "DOUBLE",
    ()=>DOUBLE,
    "DataTypes",
    ()=>DataTypes,
    "DatabaseError",
    ()=>DatabaseError,
    "Deferrable",
    ()=>Deferrable,
    "ENUM",
    ()=>ENUM,
    "EagerLoadingError",
    ()=>EagerLoadingError,
    "EmptyResultError",
    ()=>EmptyResultError,
    "Error",
    ()=>Error,
    "ExclusionConstraintError",
    ()=>ExclusionConstraintError,
    "FLOAT",
    ()=>FLOAT,
    "ForeignKeyConstraintError",
    ()=>ForeignKeyConstraintError,
    "GEOGRAPHY",
    ()=>GEOGRAPHY,
    "GEOMETRY",
    ()=>GEOMETRY,
    "HSTORE",
    ()=>HSTORE,
    "HasMany",
    ()=>HasMany,
    "HasOne",
    ()=>HasOne,
    "HostNotFoundError",
    ()=>HostNotFoundError,
    "HostNotReachableError",
    ()=>HostNotReachableError,
    "INET",
    ()=>INET,
    "INTEGER",
    ()=>INTEGER,
    "IndexHints",
    ()=>IndexHints,
    "InstanceError",
    ()=>InstanceError,
    "InvalidConnectionError",
    ()=>InvalidConnectionError,
    "JSON",
    ()=>JSON,
    "JSONB",
    ()=>JSONB,
    "MACADDR",
    ()=>MACADDR,
    "MEDIUMINT",
    ()=>MEDIUMINT,
    "Model",
    ()=>Model,
    "NOW",
    ()=>NOW,
    "NUMBER",
    ()=>NUMBER,
    "NUMERIC",
    ()=>NUMERIC,
    "Op",
    ()=>Op,
    "OptimisticLockError",
    ()=>OptimisticLockError,
    "QueryError",
    ()=>QueryError,
    "QueryInterface",
    ()=>QueryInterface,
    "QueryTypes",
    ()=>QueryTypes,
    "RANGE",
    ()=>RANGE,
    "REAL",
    ()=>REAL,
    "SMALLINT",
    ()=>SMALLINT,
    "STRING",
    ()=>STRING,
    "Sequelize",
    ()=>Sequelize,
    "SequelizeScopeError",
    ()=>SequelizeScopeError,
    "TEXT",
    ()=>TEXT,
    "TIME",
    ()=>TIME,
    "TINYINT",
    ()=>TINYINT,
    "TSVECTOR",
    ()=>TSVECTOR,
    "TableHints",
    ()=>TableHints,
    "TimeoutError",
    ()=>TimeoutError,
    "Transaction",
    ()=>Transaction,
    "UUID",
    ()=>UUID,
    "UUIDV1",
    ()=>UUIDV1,
    "UUIDV4",
    ()=>UUIDV4,
    "UniqueConstraintError",
    ()=>UniqueConstraintError,
    "UnknownConstraintError",
    ()=>UnknownConstraintError,
    "Utils",
    ()=>Utils,
    "VIRTUAL",
    ()=>VIRTUAL,
    "ValidationError",
    ()=>ValidationError,
    "ValidationErrorItem",
    ()=>ValidationErrorItem,
    "ValidationErrorItemOrigin",
    ()=>ValidationErrorItemOrigin,
    "ValidationErrorItemType",
    ()=>ValidationErrorItemType,
    "Validator",
    ()=>Validator,
    "and",
    ()=>and,
    "cast",
    ()=>cast,
    "col",
    ()=>col,
    "default",
    ()=>__TURBOPACK__default__export__,
    "fn",
    ()=>fn,
    "json",
    ()=>json,
    "literal",
    ()=>literal,
    "or",
    ()=>or,
    "useInflection",
    ()=>useInflection,
    "where",
    ()=>where
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sequelize/lib/index.js [app-route] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
const Sequelize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Sequelize;
const fn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].fn;
const col = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].col;
const cast = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].cast;
const literal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].literal;
const and = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].and;
const or = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].or;
const json = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].json;
const where = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].where;
const QueryInterface = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].QueryInterface;
const ABSTRACT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ABSTRACT;
const STRING = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].STRING;
const CHAR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].CHAR;
const TEXT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TEXT;
const NUMBER = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].NUMBER;
const TINYINT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TINYINT;
const SMALLINT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].SMALLINT;
const MEDIUMINT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].MEDIUMINT;
const INTEGER = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].INTEGER;
const BIGINT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BIGINT;
const FLOAT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].FLOAT;
const TIME = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TIME;
const DATE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DATE;
const DATEONLY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DATEONLY;
const BOOLEAN = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BOOLEAN;
const NOW = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].NOW;
const BLOB = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BLOB;
const DECIMAL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DECIMAL;
const NUMERIC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].NUMERIC;
const UUID = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UUID;
const UUIDV1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UUIDV1;
const UUIDV4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UUIDV4;
const HSTORE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].HSTORE;
const JSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].JSON;
const JSONB = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].JSONB;
const VIRTUAL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].VIRTUAL;
const ARRAY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ARRAY;
const ENUM = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ENUM;
const RANGE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].RANGE;
const REAL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].REAL;
const DOUBLE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DOUBLE;
const GEOMETRY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].GEOMETRY;
const GEOGRAPHY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].GEOGRAPHY;
const CIDR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].CIDR;
const INET = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].INET;
const MACADDR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].MACADDR;
const CITEXT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].CITEXT;
const TSVECTOR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TSVECTOR;
const Model = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Model;
const Transaction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Transaction;
const Association = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Association;
const BelongsTo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BelongsTo;
const HasOne = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].HasOne;
const HasMany = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].HasMany;
const BelongsToMany = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BelongsToMany;
const BaseError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BaseError;
const AggregateError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].AggregateError;
const AsyncQueueError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].AsyncQueueError;
const AssociationError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].AssociationError;
const BulkRecordError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].BulkRecordError;
const ConnectionError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ConnectionError;
const DatabaseError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DatabaseError;
const EagerLoadingError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].EagerLoadingError;
const EmptyResultError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].EmptyResultError;
const InstanceError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].InstanceError;
const OptimisticLockError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].OptimisticLockError;
const QueryError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].QueryError;
const SequelizeScopeError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].SequelizeScopeError;
const ValidationError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ValidationError;
const ValidationErrorItem = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ValidationErrorItem;
const AccessDeniedError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].AccessDeniedError;
const ConnectionAcquireTimeoutError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ConnectionAcquireTimeoutError;
const ConnectionRefusedError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ConnectionRefusedError;
const ConnectionTimedOutError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ConnectionTimedOutError;
const HostNotFoundError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].HostNotFoundError;
const HostNotReachableError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].HostNotReachableError;
const InvalidConnectionError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].InvalidConnectionError;
const ExclusionConstraintError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ExclusionConstraintError;
const ForeignKeyConstraintError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ForeignKeyConstraintError;
const TimeoutError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TimeoutError;
const UnknownConstraintError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UnknownConstraintError;
const UniqueConstraintError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].UniqueConstraintError;
const Error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Error;
const useInflection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].useInflection;
const Utils = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Utils;
const QueryTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].QueryTypes;
const Op = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Op;
const TableHints = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].TableHints;
const IndexHints = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].IndexHints;
const DataTypes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].DataTypes;
const Deferrable = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Deferrable;
const Validator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].Validator;
const ValidationErrorItemOrigin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ValidationErrorItemOrigin;
const ValidationErrorItemType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sequelize$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].ValidationErrorItemType;
}),
];

//# sourceMappingURL=node_modules_sequelize_215a7a02._.js.map